import os

from insights.util.subproc import call
from insights.client.constants import InsightsConstants as constants
from insights.core.exceptions import CalledProcessError
from insights.specs.datasources.malware_detection.config import logger


class YaraCommandBuilder:
    """
    Builds YARA command lines for scanning operations.

    Creates properly formatted YARA commands with appropriate flags,
    thread limits, timeouts, and rule files.
    """

    def __init__(self):
        """
        Initialize YARA command builder.
        """

        self.compiled_files = []
        self.non_compiled_files = []

        self.yara_cmd = []
        self.yara_compiled_cmds = []

    def build_commands(self, config):
        """Build YARA command line arguments"""
        base_args = [
            "nice",
            "-n",
            str(config.nice_value),
            config.yara_binary,
            "-s",
            "-N",  # Print strings and disable warnings
            "-a",
            str(config.scan_timeout),
            "-p",
            str(config.cpu_thread_limit),
            "-r",
            "-f",  # Recursive and fast mode
        ]

        # Build command for non-compiled rules
        if self.non_compiled_files:
            self.yara_cmd = base_args + self.non_compiled_files

        # Build commands for compiled rules (one per file due to YARA limitation)
        for compiled_file in self.compiled_files:
            compiled_cmd = base_args + ["-C", compiled_file]
            self.yara_compiled_cmds.append(compiled_cmd)

        logger.debug("Yara Non-compiled rules command: %s", self.yara_cmd)
        logger.debug("Yara compiled rules commands: %s", self.yara_compiled_cmds)

    def set_rules_files(self, rules_files, config):
        """Set the rules files and categorize them"""
        self._categorize_rules_files(rules_files)
        self._validate_rules_files(config, rules_files)
        self._adjust_cpu_limits(config)

    def _categorize_rules_files(self, rules_files):
        """Categorize rules files as compiled or non-compiled"""
        for rules_file in rules_files:
            if not os.path.exists(rules_file) or os.path.getsize(rules_file) == 0:
                logger.error("Rules file is empty or missing: " + rules_file)
                exit(constants.sig_kill_bad)

            file_output = call([["file", "-b", rules_file]]).strip().lower()

            if file_output.startswith("yara") or file_output == "data":
                self.compiled_files.append(rules_file)
            else:
                self.non_compiled_files.append(rules_file)

            logger.debug(
                "Rules file %s: %s (%s)",
                rules_file,
                file_output,
                "compiled" if rules_file in self.compiled_files else "source",
            )

    def _validate_rules_files(self, config, rules_files):
        """Validate that rules files can be used by YARA"""
        for rules_file in rules_files:
            compiled_flag = "-C" if rules_file in self.compiled_files else ""
            cmd = [config.yara_binary, "--fail-on-warnings", "-p", "1", "-f"]
            if compiled_flag:
                cmd.append(compiled_flag)
            cmd.extend([rules_file, "/dev/null"])

            try:
                call([cmd])
            except CalledProcessError as e:
                logger.error(
                    "Invalid rules file %s: %s", rules_file, str(e.output.decode())
                )
                exit(constants.sig_kill_bad)

    def _adjust_cpu_limits(self, config):
        """Adjust CPU thread limits based on system capacity"""
        try:
            nproc = int(call("nproc").strip())
            if nproc <= 2:
                config.cpu_thread_limit = 1
        except:
            config.cpu_thread_limit = 1

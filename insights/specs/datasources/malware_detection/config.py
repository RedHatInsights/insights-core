"""
Configuration management for malware detection.

This module handles configuration loading, validation, and default values
for the malware detection system. It provides Python 2.7 and 3.x compatibility.
"""

import os
import logging
import yaml

from insights.client.constants import InsightsConstants as constants
from insights.client.utilities import write_data_to_file

from insights.util.subproc import call

logger = logging.getLogger(__name__)

# Constants
MIN_YARA_VERSION = "4.1.0"
MALWARE_APP_URL = "https://console.redhat.com/insights/malware"
MALWARE_CONFIG_FILE = os.path.join(
    constants.default_conf_dir, "malware-detection-config.yml"
)
LAST_FILESYSTEM_SCAN_FILE = os.path.join(
    constants.default_conf_dir, ".last_malware-detection_filesystem_scan"
)
LAST_PROCESSES_SCAN_FILE = os.path.join(
    constants.default_conf_dir, ".last_malware-detection_processes_scan"
)
RULE_DOWNLOAD_DIR = constants.insights_core_lib_dir
DEFAULT_MALWARE_CONFIG = """
# Configuration file for the Red Hat Insights Malware Detection Client app
# File format is YAML
---
# Perform a simple test scan of the insights-client config directory and process to verify installation and scanning
# are working correctly.  The results from this scan do not show up in the webUI.
# Once verified, disable this option to perform actual malware scans.
test_scan: true

# Scan the filesystem?
# When it is false, the filesystem isn't scanned and the filesystem_* options that follow are ignored
scan_filesystem: true

# filesystem_scan_only: a single or list of files/directories to be scanned and no others, for example:
# filesystem_scan_only:
# - /var/www
# - /home
# ... means only scan files in /var/www and /home.  May also be written as filesystem_scan_only: [/var/www, /home]
# No value means scan all files and directories
filesystem_scan_only:

# filesystem_scan_exclude: a single or list of files/directories to be excluded from filesystem scanning
# If an item appears in both filesystem_scan_only and filesystem_scan_exclude, filesystem_scan_exclude takes precedence
# and the item will be excluded
# filesystem_scan_exclude is pre-populated with a list of top level directories that are recommended to be excluded
filesystem_scan_exclude:
- /proc
- /sys
- /cgroup
- /selinux
- /net
- /mnt
- /media

# filesystem_scan_since: scan files created or modified since X days ago or since the 'last' scan.
# Valid values are integers >= 1 or the string 'last'.  For example:
# filesystem_scan_since: 1
# ... means scan files created/modified since 1 day ago
# filesystem_scan_since: last
# ... means scan files created/modified since the last successful scan
# No value means scan all files regardless of created/modified date
filesystem_scan_since:

# Exclude mounted network/external filesystems mountpoints?
# Scanning files within mounted network filesystems may be slow and cause extra network traffic.
# They are excluded by default, meaning that files in network/externally mounted filesystems are not scanned.
# Their mountpoints will be added to the scan_exclude list of directories to be excluded from scanning
exclude_network_filesystem_mountpoints: true

# List of network/external filesystem types to search for mountpoints on the system.
# If any mountpoints are found for these filesystem types, the value of the exclude_network_filesystem_mountpoints
# option will determine if files within the mountpoints are scanned or not.
network_filesystem_types: [nfs, nfs4, cifs, smbfs, fuse.sshfs, ceph, glusterfs, gfs, gfs2]

# Scan the running processes?
# Scan_process is disabled by default to prevent an impact on system performance when scanning numerous or large processes.
# When it is false, no processes are scanned and the processes_scan_* options that follow are ignored
scan_processes: false

# processes_scan_only: processes to be scanned and no others, for example:
# processes_scan_only:
# - 123
# - 1..100
# - 10000..
# - docker
# - chrome
#... means only scan PID 123, PIDs from 1 to 100 inclusive, PIDs >= 10000 and process names containing the strings docker or chrome
# No value means scan all processes
processes_scan_only:

# processes_scan_exclude: processes to be excluded from scanning.  Uses the same syntax as processes_scan_only.
# If an item appears in both processes_scan_only and processes_scan_exclude, processes_scan_exclude takes precedence
# and the item will be excluded
# No value means don't exclude any processes
processes_scan_exclude:

# processes_scan_since: scan processes created since X days ago or since the 'last' scan.
# Valid values are integers >= 1 or the string 'last'.  For example:
# processes_scan_since: 1
# ... means scan processes created since 1 day ago
# processes_scan_since: last
# ... means scan processes created since the last successful scan
# No value means scan all processes regardless of created date
processes_scan_since:

# Add extra metadata about each scan match (if possible), eg file type & md5sum, matching line numbers, process name
# The extra metadata will display in the webUI along with the scan matches
add_metadata: true

# Abort a particular scan if it takes longer than scan_timeout seconds.  Default is 3600 seconds (1 hour)
scan_timeout: # 3600

# Run the yara process with this nice priority value.  Default is 19 (lowest priority)
nice_value: # 19

# The max number of CPUs threads used by yara when scanning.  Autodetected, but default is 2
cpu_thread_limit: # 2
rules_location: /etc/insights-client/signatures
use_remote_rules: true
""".lstrip()

# Environment variable type definitions for configuration parsing
# All config options have corresponding environment variables that need proper type conversion
ENV_VAR_TYPES = {
    "boolean": [
        "SCAN_FILESYSTEM",
        "SCAN_PROCESSES",
        "TEST_SCAN",
        "ADD_METADATA",
        "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS",
        "USE_REMOTE_RULES",
    ],
    "list": [
        "FILESYSTEM_SCAN_ONLY",
        "FILESYSTEM_SCAN_EXCLUDE",
        "PROCESSES_SCAN_ONLY",
        "PROCESSES_SCAN_EXCLUDE",
        "NETWORK_FILESYSTEM_TYPES",
    ],
    "integer": ["SCAN_TIMEOUT", "NICE_VALUE", "CPU_THREAD_LIMIT", "STRING_MATCH_LIMIT"],
    "int_or_str": ["FILESYSTEM_SCAN_SINCE", "PROCESSES_SCAN_SINCE"],
}


class MalwareConfig:

    def __init__(self, insights_config):
        # insights_config is used to access insights-client auth and network config when downloading rules
        self.insights_config = insights_config

        # constant variables
        self.min_yara_version = MIN_YARA_VERSION
        self.malware_app_url = MALWARE_APP_URL
        self.malware_config_file = MALWARE_CONFIG_FILE
        self.last_filesystem_scan_file = LAST_FILESYSTEM_SCAN_FILE
        self.last_processes_scan_file = LAST_PROCESSES_SCAN_FILE
        self.rule_download_dir = RULE_DOWNLOAD_DIR
        self.default_malware_config = DEFAULT_MALWARE_CONFIG

        # malware config
        self.config = self._load_or_create_malware_config()

        # Locate and validate YARA binary
        yara_binary_location, yara_version = self._find_yara()
        if not yara_binary_location:
            logger.error(
                "Couldn't find yara. Please ensure the yara package is installed"
            )
            exit(constants.sig_kill_bad)

        # Set location of yara binary and the version of yara
        self.yara_binary = yara_binary_location
        self.yara_version = yara_version

        self.nice_value = self._validate_option("nice_value", 19)
        self.scan_timeout = self._validate_option("scan_timeout", 3600)
        self.cpu_thread_limit = self._validate_option("cpu_thread_limit", 2)
        self.string_match_limit = self._validate_option("string_match_limit", 10)
        self.test_scan = self._get_config_option("test_scan", False)
        self.do_filesystem_scan = self._get_config_option("scan_filesystem", True)
        self.do_process_scan = self._get_config_option("scan_processes", False)
        self.filesystem_scan_only = self._get_config_option("filesystem_scan_only")
        self.processes_scan_only = self._get_config_option("processes_scan_only")
        self.filesystem_scan_exclude = self._get_config_option(
            "filesystem_scan_exclude"
        )
        self.processes_scan_exclude = self._get_config_option("processes_scan_exclude")
        self.filesystem_scan_since = self._get_config_option("filesystem_scan_since")
        self.processes_scan_since = self._get_config_option("processes_scan_since")
        self.exclude_network_filesystem_mountpoints = self._get_config_option(
            "exclude_network_filesystem_mountpoints"
        )
        self.network_filesystem_types = self._get_config_option(
            "network_filesystem_types"
        )
        # Depreciated options
        self.scan_only = self._get_config_option("scan_only")
        self.scan_exclude = self._get_config_option("scan_exclude")
        self.scan_since = self._get_config_option("scan_since")

        self.use_remote_rules = self._get_config_option("use_remote_rules", "True")
        self.remote_rules_location = self._get_config_option(
            "remote_rules_location", ""
        )
        self.rules_location = self._get_config_option(
            "rules_location", "/etc/insights-client/signatures"
        )

        ca_cert = self._get_ca_certificate()
        self.cert_verify = self._get_cert_verify_value()
        self.custom_cert = self._get_config_option("ca_cert", ca_cert)  # can be none
        # Check if we are adding extra metadata to each scan match
        self.add_metadata = self._get_config_option("add_metadata", False)
        self.string_match_limit = self._validate_option("string_match_limit", 10)

    def _load_or_create_malware_config(self):
        """
        Load the malware detection configuration file.

        Creates a default configuration file if one doesn't exist.

        Returns:
            dict: The loaded configuration as a dictionary

        Raises:
            SystemExit: If the configuration file cannot be loaded or parsed
        """
        # Create default config file if it doesn't exist
        if not os.path.isfile(MALWARE_CONFIG_FILE):
            logger.info(
                "Writing the malware-detection app default configuration to %s",
                MALWARE_CONFIG_FILE,
            )
            write_data_to_file(DEFAULT_MALWARE_CONFIG, MALWARE_CONFIG_FILE)
            os.chmod(MALWARE_CONFIG_FILE, 0o644)

        # Load and parse the configuration file
        try:
            with open(MALWARE_CONFIG_FILE) as config_file:
                return yaml.safe_load(config_file)
        except Exception as error:
            logger.error(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                MALWARE_CONFIG_FILE,
                str(error),
            )
            exit(constants.sig_kill_bad)

    def _get_config_option(self, option, default_value=None):
        """
        Get the value of a config option or if it doesn't exist or is None, the default_value
        """
        value = os.getenv(option.upper())
        if value is not None:
            return self._parse_env_var(option.upper(), value)
        value = self.config.get(option)
        return value if value is not None else default_value

    def _validate_option(self, option, value):
        try:
            return int(self._get_config_option(option, value))
        except Exception as e:
            logger.error("Problem setting configuration option %s: %s", option, str(e))
            exit(constants.sig_kill_bad)

    def _parse_env_var(self, env_var, value):
        """
        Parse environment variables to their appropriate types.

        Args:
            env_var (str): The environment variable name
            value (str): The raw string value from the environment

        Returns:
            The parsed value in the appropriate type (bool, int, list, str)

        Raises:
            SystemExit: If integer parsing fails
        """
        logger.debug("Found environment variable: %s, value: %s", env_var, value)

        # Parse boolean environment variables
        if env_var in ENV_VAR_TYPES["boolean"]:
            return value.lower() in ("true", "yes", "t", "y")

        # Parse list environment variables (comma-separated values)
        if env_var in ENV_VAR_TYPES["list"]:
            if value:
                return value.split(",") if "," in value else [value]
            else:
                return []

        # Parse scan_since variables (can be integer days or 'last')
        if env_var in ENV_VAR_TYPES["int_or_str"]:
            return int(value) if value.isdigit() else value

        # Parse integer environment variables
        if env_var in ENV_VAR_TYPES["integer"]:
            try:
                return int(value)
            except ValueError as error:
                logger.error(
                    "Problem parsing environment variable %s: %s", env_var, str(error)
                )
                exit(constants.sig_kill_bad)

        # Return string values as-is
        return value

    def _validate_yara_version(self, yara_binary_path):
        """
        Validate that YARA version meets minimum requirements.

        Args:
            yara_binary_path (str): Path to the YARA binary

        Returns:
            str: The YARA version string if valid

        Raises:
            SystemExit: If version is too old or cannot be determined
        """
        try:
            yara_version = call([[yara_binary_path, "--version"]]).strip()

            # Extract major.minor version and compare with minimum
            version_parts = yara_version.split(".")[:2]
            current_version = float(".".join(version_parts))
            minimum_version = float(MIN_YARA_VERSION[:3])

            if current_version < minimum_version:
                raise RuntimeError(
                    "Found {binary} with version {current}, but malware-detection "
                    "requires version >= {minimum}\n"
                    "Please install a later version of yara.".format(
                        binary=yara_binary_path,
                        current=yara_version,
                        minimum=MIN_YARA_VERSION,
                    )
                )

            return yara_version

        except RuntimeError as error:
            logger.error(str(error))
            exit(constants.sig_kill_bad)
        except Exception as error:
            logger.error(
                "Error getting the version of the specified yara binary %s: %s",
                yara_binary_path,
                str(error),
            )
            exit(constants.sig_kill_bad)

    def _find_yara(self):
        """
        Find and validate the YARA binary on the system.

        Searches for YARA in trusted system locations to prevent using malicious binaries.
        Does not use 'which' or system PATH for security reasons.

        Returns:
            tuple: (yara_binary_path, yara_version) if found and valid, (None, None) otherwise

        Note:
            Only searches in /bin/yara and /usr/bin/yara for security.
            Validates that version is >= MIN_YARA_VERSION.
        """

        # Search for YARA in trusted system locations only
        # /bin/yara and /usr/bin/yara exist if YARA is installed via package manager
        trusted_yara_locations = ["/bin/yara", "/usr/bin/yara"]

        for yara_path in trusted_yara_locations:
            if os.path.exists(yara_path):
                yara_version = self._validate_yara_version(yara_path)
                if yara_version:
                    logger.debug("Using yara binary: %s", yara_path)
                    return yara_path, yara_version

        # No valid YARA binary found
        return None, None

    def _get_cert_verify_value(self):
        """
        Get the SSL certificate verification setting from insights config.

        Returns:
            bool or str: SSL verification setting (True, False, or path to CA bundle)

        Note:
            Default is True if not set or empty.
            Handles string boolean values ("true"/"false").
            Can also be a path to a custom CA bundle file.
        """
        cert_verify = getattr(self.insights_config, "cert_verify", None)

        if cert_verify is None or cert_verify == "":
            return True
        elif isinstance(cert_verify, str) and cert_verify.lower() in ("true", "false"):
            return cert_verify.lower() == "true"
        else:
            return cert_verify

    def _get_ca_certificate(self):
        """Get the CA certificate bundle path"""
        ca_bundles = [
            "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem",
            "/etc/pki/tls/certs/ca-bundle.crt",
        ]
        for bundle in ca_bundles:
            if os.path.isfile(bundle):
                return bundle
        return None

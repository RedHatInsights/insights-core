import os
import logging
import yaml
from insights.util.subproc import call

from insights.client.constants import InsightsConstants as constants
from insights.client.utilities import write_data_to_file

logger = logging.getLogger(__name__)

MIN_YARA_VERSION = "4.1.0"
MALWARE_APP_URL = "https://console.redhat.com/insights/malware"
MALWARE_CONFIG_FILE = os.path.join(
    constants.default_conf_dir, "malware-detection-config.yml"
)
LAST_FILESYSTEM_SCAN_FILE = os.path.join(
    constants.default_conf_dir, ".last_malware-detection_filesystem_scan"
)
LAST_PROCESSES_SCAN_FILE = os.path.join(
    constants.default_conf_dir, ".last_malware-detection_processes_scan"
)
RULE_DOWNLOAD_DIR = constants.insights_core_lib_dir
DEFAULT_MALWARE_CONFIG = """
# Configuration file for the Red Hat Insights Malware Detection Client app
# File format is YAML
---
# Perform a simple test scan of the insights-client config directory and process to verify installation and scanning
# are working correctly.  The results from this scan do not show up in the webUI.
# Once verified, disable this option to perform actual malware scans.
test_scan: true

# Scan the filesystem?
# When it is false, the filesystem isn't scanned and the filesystem_* options that follow are ignored
scan_filesystem: true

# filesystem_scan_only: a single or list of files/directories to be scanned and no others, for example:
# filesystem_scan_only:
# - /var/www
# - /home
# ... means only scan files in /var/www and /home.  May also be written as filesystem_scan_only: [/var/www, /home]
# No value means scan all files and directories
filesystem_scan_only:

# filesystem_scan_exclude: a single or list of files/directories to be excluded from filesystem scanning
# If an item appears in both filesystem_scan_only and filesystem_scan_exclude, filesystem_scan_exclude takes precedence
# and the item will be excluded
# filesystem_scan_exclude is pre-populated with a list of top level directories that are recommended to be excluded
filesystem_scan_exclude:
- /proc
- /sys
- /cgroup
- /selinux
- /net
- /mnt
- /media

# filesystem_scan_since: scan files created or modified since X days ago or since the 'last' scan.
# Valid values are integers >= 1 or the string 'last'.  For example:
# filesystem_scan_since: 1
# ... means scan files created/modified since 1 day ago
# filesystem_scan_since: last
# ... means scan files created/modified since the last successful scan
# No value means scan all files regardless of created/modified date
filesystem_scan_since:

# Exclude mounted network/external filesystems mountpoints?
# Scanning files within mounted network filesystems may be slow and cause extra network traffic.
# They are excluded by default, meaning that files in network/externally mounted filesystems are not scanned.
# Their mountpoints will be added to the scan_exclude list of directories to be excluded from scanning
exclude_network_filesystem_mountpoints: true

# List of network/external filesystem types to search for mountpoints on the system.
# If any mountpoints are found for these filesystem types, the value of the exclude_network_filesystem_mountpoints
# option will determine if files within the mountpoints are scanned or not.
network_filesystem_types: [nfs, nfs4, cifs, smbfs, fuse.sshfs, ceph, glusterfs, gfs, gfs2]

# Scan the running processes?
# Scan_process is disabled by default to prevent an impact on system performance when scanning numerous or large processes.
# When it is false, no processes are scanned and the processes_scan_* options that follow are ignored
scan_processes: false

# processes_scan_only: processes to be scanned and no others, for example:
# processes_scan_only:
# - 123
# - 1..100
# - 10000..
# - docker
# - chrome
#... means only scan PID 123, PIDs from 1 to 100 inclusive, PIDs >= 10000 and process names containing the strings docker or chrome
# No value means scan all processes
processes_scan_only:

# processes_scan_exclude: processes to be excluded from scanning.  Uses the same syntax as processes_scan_only.
# If an item appears in both processes_scan_only and processes_scan_exclude, processes_scan_exclude takes precedence
# and the item will be excluded
# No value means don't exclude any processes
processes_scan_exclude:

# processes_scan_since: scan processes created since X days ago or since the 'last' scan.
# Valid values are integers >= 1 or the string 'last'.  For example:
# processes_scan_since: 1
# ... means scan processes created since 1 day ago
# processes_scan_since: last
# ... means scan processes created since the last successful scan
# No value means scan all processes regardless of created date
processes_scan_since:

# Add extra metadata about each scan match (if possible), eg file type & md5sum, matching line numbers, process name
# The extra metadata will display in the webUI along with the scan matches
add_metadata: true

# Abort a particular scan if it takes longer than scan_timeout seconds.  Default is 3600 seconds (1 hour)
scan_timeout: # 3600

# Run the yara process with this nice priority value.  Default is 19 (lowest priority)
nice_value: # 19

# The max number of CPUs threads used by yara when scanning.  Autodetected, but default is 2
cpu_thread_limit: # 2
rules_location: /etc/insights-client/signatures
use_remote_rules: true
""".lstrip()

# All the config options have corresponding environment variables
# Env vars are initially strings and need to be parsed to their appropriate type to match the yaml types
ENV_VAR_TYPES = {
    "boolean": [
        "SCAN_FILESYSTEM",
        "SCAN_PROCESSES",
        "TEST_SCAN",
        "ADD_METADATA",
        "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS",
        "USE_REMOTE_RULES",
    ],
    "list": [
        "FILESYSTEM_SCAN_ONLY",
        "FILESYSTEM_SCAN_EXCLUDE",
        "PROCESSES_SCAN_ONLY",
        "PROCESSES_SCAN_EXCLUDE",
        "NETWORK_FILESYSTEM_TYPES",
    ],
    "integer": ["SCAN_TIMEOUT", "NICE_VALUE", "CPU_THREAD_LIMIT", "STRING_MATCH_LIMIT"],
    "int_or_str": ["FILESYSTEM_SCAN_SINCE", "PROCESSES_SCAN_SINCE"],
}


def parse_env_var(env_var, value):
    """
    Parse specific environment variables to make sure they have appropriate values
    """
    logger.debug("Found environment variable: %s, value: %s", env_var, value)
    # Parse these env vars as booleans
    if env_var in ENV_VAR_TYPES["boolean"]:
        return value.lower() in ("true", "yes", "t", "y")

    # Parse these as lists by splitting at the commas
    if env_var in ENV_VAR_TYPES["list"]:
        if value:
            return value.split(",") if "," in value else [value]
        else:
            return []

    # Parse *_scan_since, can be either an int or a string (ie 'last')
    if env_var in ENV_VAR_TYPES["int_or_str"]:
        return int(value) if value.isdigit() else value

    # Parse these as ints
    if env_var in ENV_VAR_TYPES["integer"]:
        try:
            return int(value)
        except ValueError as e:
            logger.error("Problem parsing environment variable %s: %s", env_var, str(e))
            exit(constants.sig_kill_bad)

    # env_var value doesn't require parsing, just return it as is (ie. as a string)
    return value


def load_or_create_malware_config():
    # Load the malware-detection config file.  Write out a default one first if it doesn't already exist
    if not os.path.isfile(MALWARE_CONFIG_FILE):
        logger.info(
            "Writing the malware-detection app default configuration to %s",
            MALWARE_CONFIG_FILE,
        )
        write_data_to_file(DEFAULT_MALWARE_CONFIG, MALWARE_CONFIG_FILE)
        os.chmod(MALWARE_CONFIG_FILE, 0o644)

    try:
        with open(MALWARE_CONFIG_FILE) as m:
            return yaml.safe_load(m)
    except Exception as e:
        logger.error(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            MALWARE_CONFIG_FILE,
            str(e),
        )
        exit(constants.sig_kill_bad)


def find_yara():
    """
    Find the yara binary in particular locations on the local system.  Don't use 'which yara'
    and rely on the system path in case it finds a malicious yara.
    Also, don't let the user specify where yara is, again in case it is a malicious version of yara
    If found, check it's version >= MIN_YARA_VERSION
    """

    def yara_version_ok(yara):
        # Check the installed yara version >= MIN_YARA_VERSION
        yara_version = call([[yara, "--version"]]).strip()
        try:
            # Check the installed yara X.Y version > the minimal recommended yara version
            if float(".".join(yara_version.split(".")[:2])) < float(
                    MIN_YARA_VERSION[:3]
            ):
                raise RuntimeError(
                    "Found %s with version %s, but malware-detection requires version >= %s\n"
                    "Please install a later version of yara."
                    % (yara, yara_version, MIN_YARA_VERSION)
                )
        except RuntimeError as e:
            logger.error(str(e))
            exit(constants.sig_kill_bad)
        except Exception as e:
            logger.error(
                "Error getting the version of the specified yara binary %s: %s",
                yara,
                str(e),
            )
            exit(constants.sig_kill_bad)
        # If we are here then the version of yara was ok
        return yara_version

    # Try to find yara in only these usual locations.
    # /bin/yara and /usr/bin/yara will exist if yara is installed via rpm
    # /usr/local/bin/yara will (likely) exist if the user has compiled and installed yara manually
    for yara in ["/bin/yara", "/usr/bin/yara"]:
        if os.path.exists(yara):
            yara_version = yara_version_ok(yara)
            if yara_version:
                logger.debug("Using yara binary: %s", yara)
                return yara, yara_version

    return None, None

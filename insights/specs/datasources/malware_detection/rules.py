import os
import logging
from glob import glob
from tempfile import gettempdir
from insights.client.constants import InsightsConstants as constants
import re
import time

try:
    # python 2
    from urlparse import urlparse, urlunparse
except ImportError:
    # python 3
    from urllib.parse import urlparse, urlunparse

logger = logging.getLogger(__name__)


RULE_DOWNLOAD_DIR = constants.insights_core_lib_dir


def remove_old_rules_files():
    """
    The rules file that is downloaded from the backend should be automatically removed when the
    malware-detection client exits.
    However, it can happen that the rules file isn't removed for some reason, so remove any existing
    rules files before beginning a new scan, otherwise they may show up as matches in the scan results.
    """
    old_rules_files = sum(
        [
            glob(os.path.join(path, rules))
            for path in (
                RULE_DOWNLOAD_DIR,
                "/tmp",
                "/var/tmp",
                "/usr/tmp",
                gettempdir(),
            )
            for rules in (
                "malware-detection_yara_rules.*",
                ".tmpmdsigs*",
                "tmp_malware-detection-client_rules.*",
            )
        ],
        [],
    )
    for old_rules_file in old_rules_files:
        if os.path.exists(old_rules_file):
            logger.debug("Removing old rules file %s", old_rules_file)
            os.remove(old_rules_file)


def find_rules_in_directory(rules_dir):
    """
    Find all rule files within the specified directory.
    If directory path is provided by `self.rules_dir_location`,
    it is assumed client wants to include local rules kept on a disk for the scan.
    """
    # Look for files that match the pattern for YARA rules files (.yar and .yc)
    # Define the patterns you want to match
    patterns = ["*.yar", "*.yc", "*.yara"]

    # Use list comprehension to concatenate the results of all glob calls
    rule_files = sum(
        [glob(os.path.join(rules_dir, pattern)) for pattern in patterns], []
    )

    if not rule_files:
        logger.warning("No rule files found in directory: %s", rules_dir)
    else:
        logger.debug("Found rule files: %s", rule_files)

    return rule_files


def is_local_file(location):
    """
    If rules_location starts with a /, assume its a file rather than a URL
    """
    return location.startswith("/")


def use_local_rules(rules_location):
    """
    Remove any extra slashes from the file name and from the start too (normpath doesn't remove those)
    """
    rules_file = os.path.normpath(rules_location).replace("//", "/")
    if os.path.isdir(rules_file):
        logger.debug("Using rules directory: %s", rules_file)
        # It is a directory with rules
        return find_rules_in_directory(rules_file)
    else:
        if not os.path.isfile(rules_file):
            logger.error("Couldn't find specified rules file: %s", rules_file)
            exit(constants.sig_kill_bad)
        logger.debug("Using specified rules file: %s", rules_file)
        # It is single rules file
        return [rules_file]


def set_remote_rules_location(
    insights_config, remote_rules_location="", yara_version=""
):
    """
    If we are here, then we are downloading the rules from the malware backend
    """
    signatures_file = "signatures.yar"
    signatures_file += "?yara_version=" + yara_version

    if not remote_rules_location:
        remote_rules_location = (
            "https://console.redhat.com/api/malware-detection/v1/" + signatures_file
        )
        if "/redhat_access/" in insights_config.base_url:
            # Satellite URLs have '/redhat_access/' in the base_url config option
            remote_rules_location = (
                insights_config.base_url + "/malware-detection/v1/" + signatures_file
            )
        elif any(
            [
                url in insights_config.base_url
                for url in ["console.stage.", "cloud.stage."]
            ]
        ):
            # For downloading rules in the stage environment, use the URL of base_url (after finding it)
            base_url = urlparse(insights_config.base_url)
            remote_rules_location = (
                base_url.netloc
                or base_url.scheme
                or base_url.path.split("/")[0]
                or "cert.console.stage.redhat.com"
            )
            remote_rules_location += "/api/malware-detection/v1/" + signatures_file
    return remote_rules_location


def validate_rules_location(insights_config, remote_rules_location):
    """
    Make sure the rules_location starts with https://
    """
    if not re.match("^https?://", remote_rules_location):
        remote_rules_location = "https://" + remote_rules_location

    # If talking direct to C.R.C with cert auth or basic auth without a username/password, append 'cert.' to the url
    if remote_rules_location.startswith("https://console.redhat.com"):
        authmethod = (
            insights_config.authmethod
            if hasattr(insights_config, "authmethod")
            else "CERT"
        )
        username = (
            insights_config.username if hasattr(insights_config, "username") else ""
        )
        password = (
            insights_config.password if hasattr(insights_config, "password") else ""
        )
        if authmethod == "CERT" or (
            authmethod == "BASIC" and not (username or password)
        ):
            parsed_url = urlparse(remote_rules_location)
            if not parsed_url.netloc.startswith("cert."):
                remote_rules_location = urlunparse(
                    parsed_url._replace(netloc="cert." + parsed_url.netloc)
                )
        return remote_rules_location, authmethod
    return remote_rules_location, ""


def set_url_path(url, path="graphql"):
    """
    Change the last item in the 'url' to 'path'
    For example if url=http://localhost:3000/api/malware/signatures.yar and path=test-rule.yar
    The returned url would be http://localhost:3000/api/malware/test-rule.yar
    """
    if url.endswith(path):
        return url
    # Unconventional perhaps, but this seems to work ok with both URL and file paths
    return os.path.join(os.path.dirname(url), path)


def handle_test_scan(test_scan, remote_rules_location):
    if test_scan:
        remote_rules_location = set_url_path(remote_rules_location, "test-rule.yar")
    return test_scan, remote_rules_location


def get_ca_certificate():
    """
    Shouldn't need this, but left here for insurance: https://access.redhat.com/solutions/6997170
    If a custom CA cert is being used, eg on a Satellite, then SSL errors may occur when downloading the rules
    The CA cert needs to be added to a CA bundle (with update-ca-trust) and the bundle used for cert verification
    """
    ca_bundles = [
        "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem",
        "/etc/pki/tls/certs/ca-bundle.crt",
    ]
    for ca_bundle in ca_bundles:
        if os.path.isfile(ca_bundle):
            return ca_bundle
    return None


def get_cert_verify_value(insights_config):
    cert_verify = insights_config.cert_verify
    if cert_verify is None or cert_verify == "":
        cert_verify = True
    elif cert_verify.lower() in ("true", "false"):
        cert_verify = cert_verify.lower() == "true"
    return cert_verify


def download_rules(
    conn,
    insights_config,
    log_rule_contents,
    remote_rules_location,
    cert_verify,
    custom_cert,
):

    for attempt in range(1, insights_config.retries + 1):
        try:
            response = conn.get(
                remote_rules_location,
                log_response_text=log_rule_contents,
                verify=cert_verify,
                stream=True,
            )
            if response.status_code != 200:
                raise Exception(
                    "%s %s: %s" % (response.status_code, response.reason, response.text)
                )
            break
        except Exception as e:
            if attempt < insights_config.retries:
                logger.debug(
                    "Unable to download rules from %s: %s",
                    remote_rules_location,
                    str(e),
                )
                logger.debug("Trying again in %d seconds ...", attempt)
                time.sleep(attempt)
            else:
                logger.error(
                    "Unable to download rules from %s: %s",
                    remote_rules_location,
                    str(e),
                )
                exit(constants.sig_kill_bad)

            if re.search("SSL.*verify.failed", str(e), re.IGNORECASE):
                # Kept as a fallback in case SSL errors still occur - add the custom CA cert to the trusted certs
                cert_verify = custom_cert
                logger.debug("Trying cert_verify value %s ...", custom_cert)
    return response

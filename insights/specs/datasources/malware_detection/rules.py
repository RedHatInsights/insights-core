"""
YARA rules management for malware detection.

This module handles downloading, validation, and management of YARA rules
from both local and remote sources. It provides secure rule handling with
proper Python 2.7 and 3.x compatibility.
"""

import os
import re
import time
import logging
import fnmatch
from glob import glob
from tempfile import NamedTemporaryFile, gettempdir

try:
    # Python 2
    from urlparse import urlparse, urlunparse
except ImportError:
    # Python 3
    from urllib.parse import urlparse, urlunparse

from insights.client.connection import InsightsConnection
from insights.client.constants import InsightsConstants as constants

logger = logging.getLogger(__name__)


class RuleManager:
    """
    Manages YARA rule loading and downloading.

    Handles both local and remote rule sources, including rule validation,
    disabled rule management, and temporary file cleanup.
    """

    def __init__(self, insights_config):
        """
        Initialize rule manager.
        """
        self.insights_config = insights_config

        # Rule files and settings
        self.rules_files = []
        self.disabled_rules = []

        # Network connection for remote rules
        self.conn = (
            InsightsConnection(self.insights_config) if self.insights_config else None
        )
        self.temp_rules_file = None

    def cleanup_old_rules(self, config):
        """Remove old rules files"""
        patterns = [
            "malware-detection_yara_rules.*",
            ".tmpmdsigs*",
            "tmp_malware-detection-client_rules.*",
        ]

        search_dirs = [
            config.rule_download_dir,
            "/tmp",
            "/var/tmp",
            "/usr/tmp",
            gettempdir(),
        ]

        for directory in search_dirs:
            for pattern in patterns:
                for old_file in glob(
                    os.path.join(directory, pattern)
                ):  # pragma: no cover
                    if os.path.exists(old_file):
                        logger.debug("Removing old rules file: " + old_file)
                        os.remove(old_file)

    def is_local_file(self, location):
        """
        Determine if a location represents a local file path or a remote URL.

        Args:
            location (str): The location string to check

        Returns:
            bool: True if location appears to be a local file path, False otherwise

        Note:
            Uses simple heuristic: local paths start with '/'
        """
        return location.startswith("/")

    def find_local_rules(self, rules_location):
        """Find rules in local directory or file"""
        # Remove any extra slashes from the file name and from the start too (abspath doesn't remove those)
        rules_path = os.path.abspath(rules_location).replace("//", "/")

        if os.path.isdir(rules_path):
            patterns = ["*.yar", "*.yc", "*.yara"]
            rule_files = []
            for root, dirnames, filenames in os.walk(rules_path):
                for pattern in patterns:
                    for filename in fnmatch.filter(filenames, pattern):
                        rule_files.append(os.path.join(root, filename))

            if not rule_files:
                logger.warning("No rule files found in directory: " + rules_location)
            self.rules_files.extend(rule_files)

        elif os.path.isfile(rules_path):
            logger.debug("Using rules file: " + rules_location)
            self.rules_files.append(rules_path)

    def build_remote_rules_url(self, config):
        """Build the remote rules download URL"""
        if config.remote_rules_location:
            return

        signatures_file = "signatures.yar"
        if config.yara_version:
            signatures_file += "?yara_version=" + config.yara_version
        base_url = self.insights_config.base_url

        if "/redhat_access/" in base_url:
            config.remote_rules_location = (
                base_url + "/malware-detection/v1/" + signatures_file
            )
        elif any(url in base_url for url in ["console.stage.", "cloud.stage."]):
            parsed = urlparse(base_url)
            netloc = (
                parsed.netloc
                or parsed.scheme
                or parsed.path.split("/")[0]
                or "cert.console.stage.redhat.com"
            )
            config.remote_rules_location = (
                netloc + "/api/malware-detection/v1/" + signatures_file
            )
        else:
            config.remote_rules_location = (
                "https://console.redhat.com/api/malware-detection/v1/" + signatures_file
            )

    def validate_and_adjust_url(self, config):
        """Validate and adjust the rules URL for authentication"""
        if not re.match("^https?://", config.remote_rules_location):
            config.remote_rules_location = "https://" + config.remote_rules_location

        if config.remote_rules_location.startswith("https://console.redhat.com"):
            authmethod = getattr(self.insights_config, "authmethod", "CERT")
            username = getattr(self.insights_config, "username", "")
            password = getattr(self.insights_config, "password", "")

            if authmethod == "CERT" or (
                authmethod == "BASIC" and not (username or password)
            ):
                parsed = urlparse(config.remote_rules_location)
                if not parsed.netloc.startswith("cert."):
                    config.remote_rules_location = urlunparse(
                        parsed._replace(netloc="cert." + parsed.netloc)
                    )
            if authmethod == "CERT":
                self.insights_config.authmethod = "CERT"

    def alter_remote_url_to_test(self, config):
        """Modify the rules URL for test scan mode.

        Note:
            In test mode, changes the URL to download test-rule.yar instead of signatures.yar.
            This allows testing the malware detection system without using production rules.
        """
        config.remote_rules_location = self._change_url_path(
            config.remote_rules_location, "test-rule.yar"
        )

    def download_rules(self, config):
        """Download rules from remote URL"""
        for attempt in range(1, self.insights_config.retries + 1):
            try:
                response = self.conn.get(
                    config.remote_rules_location,
                    log_response_text=config.test_scan,
                    verify=config.cert_verify,
                    stream=True,
                )
                if response.status_code != 200:
                    raise Exception(
                        "%s %s: %s"
                        % (response.status_code, response.reason, response.text)
                    )
                break
            except Exception as e:  # pragma: no cover
                if attempt < self.insights_config.retries:
                    logger.debug(
                        "Unable to download rules from %s: %s",
                        config.remote_rules_location,
                        str(e),
                    )
                    logger.debug("Trying again in %d seconds ...", attempt)
                    time.sleep(attempt)
                else:
                    logger.error(
                        "Unable to download rules from %s: %s",
                        config.remote_rules_location,
                        str(e),
                    )
                    exit(constants.sig_kill_bad)

                if re.search("SSL.*verify.failed", str(e), re.IGNORECASE):
                    # Kept as a fallback in case SSL errors still occur - add the custom CA cert to the trusted certs
                    config.cert_verify = config.custom_cert
                    logger.debug("Trying cert_verify value %s ...", config.cert_verify)

        self.temp_rules_file = NamedTemporaryFile(
            prefix="malware-detection_yara_rules.",
            mode="wb",
            delete=True,
            dir=config.rule_download_dir,
        )
        self.temp_rules_file.write(response.content)
        self.temp_rules_file.flush()

        self.rules_files.append(self.temp_rules_file.name)

    def get_disabled_rules(self, config):
        """Get list of disabled rules from GraphQL endpoint"""
        if not self.conn:  # pragma: no cover
            return

        graphql_url = self._change_url_path(config.remote_rules_location, "graphql")
        query = "query { rulesList(condition: {isDisabled: true}) { name } }"

        for attempt in range(1, self.insights_config.retries + 1):
            try:
                response = self.conn.post(
                    graphql_url,
                    json={"query": query},
                    headers={"Content-Type": "application/json"},
                    verify=config.cert_verify,
                    stream=True,
                )

                if response.status_code == 200:
                    payload = response.json()
                    rules_list = payload.get("data", {}).get("rulesList", [])
                    disabled_rules = [rule["name"].lower() for rule in rules_list]
                    logger.debug("Disabled rules: " + str(disabled_rules))
                    self.disabled_rules = sorted(disabled_rules)
                else:
                    raise Exception(
                        str(response.status_code) + str(response.reason)
                    )  # pragma: no cover

            except Exception as e:  # pragma: no cover
                if attempt < self.insights_config.retries:
                    logger.debug(
                        "Failed to get disabled rules from "
                        + str(graphql_url)
                        + " (attempt "
                        + str(attempt)
                        + "): "
                        + str(e)
                    )
                    time.sleep(attempt)
                else:
                    logger.debug("Unable to get disabled rules list. Skipping ...")
                    break

    @staticmethod
    def _change_url_path(url, new_path):
        """Change the last component of a URL path"""
        if url.endswith(new_path):
            return url
        return os.path.join(os.path.dirname(url), new_path)

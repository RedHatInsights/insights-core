"""
Malware Detection Scanner
Combines filesystem and process scanning functionality with YARA rules.
Compatible with Python 2.7+ and Python 3.x
"""

import os
import logging
import time
from datetime import datetime
from glob import glob
from tempfile import NamedTemporaryFile, gettempdir

from insights.client.utilities import get_time
from insights.client.constants import InsightsConstants as constants
from insights.util.subproc import call
from insights.core.exceptions import CalledProcessError
from insights.specs.datasources.malware_detection import scan_utils

logger = logging.getLogger(__name__)


class FilesystemScanner:
    """
    Handles filesystem scanning operations.

    Manages directory traversal, file filtering, timestamp checking,
    and execution of YARA scans on filesystem objects.
    """

    def scan_filesystem(
        self, config, scan_config, yara_cmd, rules_files, disabled_rules, results_parser
    ):
        """
        Process the filesystem items to scan.

        Args:
            scan_config: ScanManager instance containing configuration
            yara_cmd: Base YARA command list
            rules_files: List of YARA rules files
            disabled_rules: List of disabled rule names
            results_parser: Parser for scan results

        Returns:
            bool: True if scan completed successfully, False otherwise
        """
        logger.debug("Starting filesystem scan with command: %s", yara_cmd)

        # Exclude rules files from scanning unless explicitly included
        self._exclude_rules_files(scan_config, rules_files)

        # Exclude insights-client log files
        self._exclude_log_files(scan_config)

        # Process inclusion/exclusion lists
        scan_dict = scan_utils.process_include_exclude_items(
            include_items=scan_config.scan_fsobjects,
            exclude_items=scan_config.filesystem_scan_exclude_list,
            exclude_mountpoints=scan_config.network_filesystem_mountpoints,
        )

        if not scan_dict:
            config.do_filesystem_scan = False
            return False

        logger.debug(
            "Filesystem objects to be scanned in: %s", sorted(scan_dict.keys())
        )
        logger.info("Starting filesystem scan...")

        fs_scan_start = time.time()

        for toplevel_dir in sorted(scan_dict):
            if not self._scan_directory(
                config,
                scan_config,
                yara_cmd,
                scan_dict,
                toplevel_dir,
                disabled_rules,
                results_parser,
            ):
                continue
        fs_scan_end = time.time()
        logger.info(
            "Filesystem scan completed in: %s",
            time.strftime("%H:%M:%S", time.gmtime(fs_scan_end - fs_scan_start)),
        )
        return True

    def _exclude_rules_files(self, scan_config, rules_files):
        """Exclude YARA rules files from scanning unless explicitly included."""
        potential_tmp_dirs = set([gettempdir(), "/tmp", "/var/tmp", "/usr/tmp"])

        for rule_file in rules_files:
            rules_file_name = os.path.basename(rule_file)

            # Generate potential locations for rule files
            potential_rules_files = set(
                [os.path.join(d, rules_file_name) for d in potential_tmp_dirs]
                + [rule_file]
            )

            # Add existing files to exclusion list if not in scan objects
            existing_rules_files = [
                f for f in potential_rules_files if os.path.isfile(f)
            ]
            for rules_file in existing_rules_files:
                if rules_file not in scan_config.scan_fsobjects:
                    scan_config.filesystem_scan_exclude_list.append(rules_file)
                    logger.debug("Excluding rules file: %s", rules_file)

    def _exclude_log_files(self, scan_config):
        """Exclude insights-client log files from scanning."""
        insights_log_files = glob(constants.default_log_file + "*")
        scan_config.filesystem_scan_exclude_list.extend(
            list(set(insights_log_files) - set(scan_config.scan_fsobjects))
        )

    def _scan_directory(
        self,
        config,
        scan_config,
        yara_cmd,
        scan_dict,
        toplevel_dir,
        disabled_rules,
        results_parser,
    ):
        """
        Scan a single directory with YARA.

        Returns:
            bool: True if scan completed without critical errors
        """
        cmd = yara_cmd[:]
        dir_scan_start = time.time()

        specified_log_txt = "specified " if "include" in scan_dict[toplevel_dir] else ""
        # Handle timestamp-based scanning
        if scan_config.filesystem_scan_since_dict["timestamp"]:
            logger.info(
                "Scanning %sfiles in %s modified since %s...",
                specified_log_txt,
                toplevel_dir,
                scan_config.filesystem_scan_since_dict["datetime"],
            )
            scan_list_file = self._create_modified_files_list(
                scan_config, scan_dict, toplevel_dir
            )
        else:
            logger.info("Scanning %sfiles in %s...", specified_log_txt, toplevel_dir)
            scan_list_file = self._create_scan_list(scan_dict, toplevel_dir, cmd)

        if scan_list_file:
            cmd.extend(["--scan-list", scan_list_file.name])

        # Execute YARA scan
        return self._execute_yara_scan(
            config,
            scan_config,
            cmd,
            toplevel_dir,
            disabled_rules,
            results_parser,
            dir_scan_start,
        )

    def _create_modified_files_list(self, scan_config, scan_dict, toplevel_dir):
        """Create a temporary file list of recently modified files."""
        scan_list_file = NamedTemporaryFile(
            prefix="{}_scan_list.".format(os.path.basename(toplevel_dir)),
            mode="w",
            delete=True,
        )

        if "include" in scan_dict[toplevel_dir]:
            scan_utils.find_modified_include_items(
                scan_dict[toplevel_dir]["include"],
                scan_config.filesystem_scan_since_dict["timestamp"],
                scan_list_file,
            )
        else:
            scan_utils.find_modified_in_directory(  # pragma: no cover
                toplevel_dir,
                scan_config.filesystem_scan_since_dict["timestamp"],
                scan_list_file,
            )

        scan_list_file.flush()
        return scan_list_file

    def _create_scan_list(self, scan_dict, toplevel_dir, cmd):
        """Create a scan list file for specific includes or return None for directory scan."""
        if "include" in scan_dict[toplevel_dir]:
            scan_list_file = NamedTemporaryFile(
                prefix="{}_scan_list.".format(os.path.basename(toplevel_dir)),
                mode="w",
                delete=True,
            )
            scan_list_file.write("\n".join(scan_dict[toplevel_dir]["include"]))
            scan_list_file.flush()
            return scan_list_file
        else:
            cmd.append(toplevel_dir)
            return None

    def _execute_yara_scan(
        self,
        config,
        scan_config,
        cmd,
        toplevel_dir,
        disabled_rules,
        results_parser,
        dir_scan_start,
    ):
        """Execute the YARA scan command and process results."""
        logger.debug("YARA command: %s", cmd)

        try:
            output = call([cmd]).strip()
        except CalledProcessError as cpe:  # pragma: no cover
            logger.debug("Unable to scan %s: %s", toplevel_dir, cpe.output.strip())
            return False

        try:
            results_parser.parse_scan_output(output.strip(), disabled_rules)
        except Exception as e:  # pragma: no cover
            results_parser.potential_matches += 1
            logger.exception(
                "Rule match(es) potentially found in %s but problems parsing results: %s. Skipping...",
                toplevel_dir,
                str(e),
            )

        # Log timing and check for timeout
        dir_scan_end = time.time()
        scan_duration = dir_scan_end - dir_scan_start
        logger.info("Scan time for %s: %d seconds", toplevel_dir, scan_duration)

        if scan_duration >= config.scan_timeout - 2:  # pragma: no cover
            logger.warning(
                "Scan of %s timed-out after %d seconds and may not have been fully scanned. "
                "Consider increasing scan_timeout in %s",
                toplevel_dir,
                config.scan_timeout,
                config.malware_config_file,
            )

        return True


class ProcessScanner(object):
    """
    Handles process scanning operations.

    Manages process enumeration, filtering, and execution of YARA
    scans on running processes.
    """

    def scan_processes(
        self, config, scan_config, yara_cmd, disabled_rules, results_parser
    ):
        """
        Scan running processes with YARA.

        Args:
            scan_config: ScanManager instance containing configuration
            yara_cmd: Base YARA command list
            disabled_rules: List of disabled rule names
            results_parser: Parser for scan results

        Returns:
            bool: True if scan completed successfully, False otherwise
        """
        # Get list of PIDs to scan
        if not self._prepare_scan_pids(config, scan_config):
            return False

        # Filter by process start time if specified
        if not self._filter_pids_by_start_time(config, scan_config):  # pragma: no cover
            return False

        logger.info("Starting processes scan...")
        pids_scan_start = time.time()

        for scan_pid in scan_config.scan_pids:
            self._scan_single_process(
                config, yara_cmd, scan_pid, disabled_rules, results_parser
            )

        pids_scan_end = time.time()
        logger.info(
            "Processes scan completed in: %s",
            time.strftime("%H:%M:%S", time.gmtime(pids_scan_end - pids_scan_start)),
        )
        return True

    def _prepare_scan_pids(self, config, scan_config):
        """Prepare the list of PIDs to scan and apply exclusions."""
        # Get all PIDs if none specified
        if not scan_config.scan_pids:
            scan_config.scan_pids = [
                entry for entry in os.listdir("/proc") if entry.isdigit()
            ]

        # Exclude current process unless it's a test scan
        if not config.test_scan:
            scan_config.processes_scan_exclude_list.append(str(os.getpid()))

        # Apply exclusions
        scan_config.scan_pids = sorted(
            list(
                set(scan_config.scan_pids)
                - set(scan_config.processes_scan_exclude_list)
            ),
            key=lambda pid: int(pid),
        )

        if not scan_config.scan_pids:
            logger.error("No processes to scan - all excluded by configuration")
            config.do_process_scan = False
            return False

        return True

    def _filter_pids_by_start_time(self, config, scan_config):
        """Filter PIDs by process start time if configured."""
        if not (
            hasattr(scan_config, "processes_scan_since_dict")
            and scan_config.processes_scan_since_dict["timestamp"]
        ):
            return True

        try:  # pragma: no cover
            ps_output = call([["ps", "-eo", "pid=", "-o", "lstart="]]).splitlines()
            all_proc_starts = [
                (str(parts[0]), str(parts[1]))
                for parts in [line.strip().split(" ", 1) for line in ps_output]
            ]

            scan_since_pids = []
            for proc_pid, proc_start in all_proc_starts:
                try:
                    proc_start_secs = float(
                        datetime.strptime(proc_start, "%a %b %d %H:%M:%S %Y").strftime(
                            "%s"
                        )
                    )
                    if (
                        proc_start_secs
                        >= scan_config.processes_scan_since_dict["timestamp"]
                    ):
                        scan_since_pids.append(proc_pid)
                except (ValueError, TypeError) as e:
                    logger.debug(
                        "Error parsing process start time for PID %s: %s", proc_pid, e
                    )
                    continue

            # Intersection of current scan PIDs and recently started PIDs
            scan_config.scan_pids = sorted(
                list(set(scan_config.scan_pids) & set(scan_since_pids)),
                key=lambda pid: int(pid),
            )

            if not scan_config.scan_pids:
                logger.error(
                    "No processes to scan - none started since %s",
                    scan_config.processes_scan_since_dict["datetime"],
                )
                config.do_process_scan = False
                return False

        except CalledProcessError as e:  # pragma: no cover
            logger.error("Error getting process information: %s", e)
            return False

        return True

    def _scan_single_process(
        self, config, yara_cmd, scan_pid, disabled_rules, results_parser
    ):
        """Scan a single process with YARA."""
        pid_scan_start = time.time()
        logger.info("Scanning process %s...", scan_pid)

        cmd = yara_cmd + [str(scan_pid)]
        logger.debug("YARA command: %s", cmd)

        try:
            output = call([cmd]).strip()
        except CalledProcessError as cpe:  # pragma: no cover
            logger.debug("Unable to scan process %s: %s", scan_pid, cpe.output.strip())
            return

        try:
            results_parser.parse_scan_output(output, disabled_rules)
        except Exception as e:  # pragma: no cover
            results_parser.potential_matches += 1
            logger.exception(
                "Rule match(es) potentially found in process %s but problems parsing results: %s. Skipping...",
                scan_pid,
                str(e),
            )

        # Log timing and check for timeout
        pid_scan_end = time.time()
        scan_duration = pid_scan_end - pid_scan_start
        logger.info("Scan time for process %s: %d seconds", scan_pid, scan_duration)

        if scan_duration >= config.scan_timeout - 2:  # pragma: no cover
            logger.warning(
                "Scan of process %s timed-out after %d seconds and may not have been fully scanned. "
                "Consider increasing scan_timeout in %s",
                scan_pid,
                config.scan_timeout,
                config.malware_config_file,
            )


class ScanManager:
    """
    Main scan configuration and execution manager.

    Handles configuration parsing, scan orchestration, and coordination
    between filesystem and process scanners.
    """

    def __init__(self):
        """
        Initialize scan configuration manager.
        """

        # Scan lists (populated during configuration parsing)
        self.filesystem_scan_exclude_list = []
        self.processes_scan_exclude_list = []
        self.scan_fsobjects = []
        self.scan_pids = []

        # Timing dictionaries for scan-since functionality
        self.filesystem_scan_since_dict = {}
        self.processes_scan_since_dict = {}
        self.network_filesystem_mountpoints = []

        # Initialize scanners
        self.filesystem_scanner = FilesystemScanner()
        self.process_scanner = ProcessScanner()

    def parse_test_scan_option(self, config):
        """Configure scanner for test scan mode."""
        self.filesystem_scan_since_dict = {"timestamp": None}
        self.processes_scan_since_dict = {"timestamp": None}

        # For test scan, scan the config file and current process
        if os.path.isfile(config.malware_config_file):
            config.do_filesystem_scan = True
            self.scan_fsobjects = [config.malware_config_file]
        else:
            config.do_filesystem_scan = False
            self.scan_fsobjects = []

        config.do_process_scan = True
        self.scan_pids = [str(os.getpid())]

        logger.info(
            "\nPerforming test scan of %sthe current process (PID %s) "
            "to verify malware-detection app functionality...\n",
            (
                "{} and ".format(self.scan_fsobjects[0])
                if config.do_filesystem_scan
                else ""
            ),
            self.scan_pids[0],
        )

    def parse_scan_options(self, config):
        """
        Initialize scan flags, lists, and configuration options.
        Validates configuration and prepares scanner for execution.
        """
        if not (config.do_filesystem_scan or config.do_process_scan):
            logger.error(
                "Both scan_filesystem and scan_processes are disabled. Nothing to scan."
            )
            exit(constants.sig_kill_bad)

        # Check for deprecated options
        self._check_deprecated_options(config)

        # Parse scan-only options
        parse_filesystem_ok = self._parse_filesystem_scan_only_option(config)
        parse_processes_ok = self._parse_processes_scan_only_option(config)

        # Validate scan configuration
        if not self._validate_scan_configuration(
            config, parse_filesystem_ok, parse_processes_ok
        ):
            exit(constants.sig_kill_bad)

        # Update scan flags based on parsing results
        if not parse_filesystem_ok:
            config.do_filesystem_scan = False
        if not parse_processes_ok:
            config.do_process_scan = False

        # Parse remaining configuration options
        self._parse_filesystem_scan_exclude_option(config)
        self._parse_processes_scan_exclude_option(config)
        self._parse_filesystem_scan_since_option(config)
        self._parse_processes_scan_since_option(config)
        self._parse_exclude_network_filesystem_mountpoints_option(config)

        # exclude rules directory from scans
        if config.rules_location:
            self.filesystem_scan_exclude_list.append(config.rules_location)

    def run_scan(
        self, config, yara_commander, rules_files, disabled_rules, results_parser
    ):
        """
        Execute the configured scans.

        Args:
            yara_commander: YARA command builder instance
            rules_files: List of YARA rules files
            disabled_rules: List of disabled rule names
            results_parser: Results parser instance

        Returns:
            tuple: (filesystem_scan_start_time, processes_scan_start_time)
        """
        if (
            not config.do_filesystem_scan and not config.do_process_scan
        ):  # pragma: no cover
            logger.error("No scans configured to run.")
            exit(constants.sig_kill_bad)

        logger.debug("YARA rules found: %s", rules_files)

        filesystem_scan_start = None
        processes_scan_start = None

        # Execute filesystem scan
        if config.do_filesystem_scan:
            filesystem_scan_start = get_time()
            self._run_filesystem_scans(
                config, yara_commander, rules_files, disabled_rules, results_parser
            )

        # Execute process scan
        if config.do_process_scan:
            processes_scan_start = get_time()
            self._run_process_scans(
                config, yara_commander, disabled_rules, results_parser
            )

        return filesystem_scan_start, processes_scan_start

    def _check_deprecated_options(self, config):
        """Check for deprecated configuration options and inform user."""
        deprecated_options = ["scan_exclude", "scan_only", "scan_since"]

        for option in deprecated_options:
            if getattr(config, option):
                logger.error(
                    "The '%s' option has been replaced with 'filesystem_%s' and 'processes_%s' options in %s",
                    option,
                    option,
                    option,
                    config.malware_config_file,
                )
                logger.error(
                    "Please remove %s file and a new config file will be created with updated options",
                    config.malware_config_file,
                )
                exit(constants.sig_kill_bad)

    def _validate_scan_configuration(
        self, config, parse_filesystem_ok, parse_processes_ok
    ):
        """Validate the overall scan configuration."""
        if not (parse_filesystem_ok or parse_processes_ok):  # pragma: no cover
            logger.error(
                "Nothing to scan with filesystem_scan_only and processes_scan_only options"
            )
            return False

        if not (parse_filesystem_ok or config.do_process_scan):
            logger.error(
                "Nothing to scan with filesystem_scan_only option and scan_processes disabled"
            )
            return False

        if not (config.do_filesystem_scan or parse_processes_ok):
            logger.error(
                "Nothing to scan with processes_scan_only option and scan_filesystem disabled"
            )
            return False

        return True

    def _run_filesystem_scans(
        self, config, yara_commander, rules_files, disabled_rules, results_parser
    ):
        """Execute all filesystem scans (regular and compiled rules)."""
        if yara_commander.yara_cmd:
            self.filesystem_scanner.scan_filesystem(
                config,
                self,
                yara_commander.yara_cmd,
                rules_files,
                disabled_rules,
                results_parser,
            )

        # Run scans with compiled rules
        for cmd in yara_commander.yara_compiled_cmds:
            self.filesystem_scanner.scan_filesystem(
                config, self, cmd, rules_files, disabled_rules, results_parser
            )

    def _run_process_scans(
        self, config, yara_commander, disabled_rules, results_parser
    ):
        """Execute all process scans (regular and compiled rules)."""
        if yara_commander.yara_cmd:
            self.process_scanner.scan_processes(
                config, self, yara_commander.yara_cmd, disabled_rules, results_parser
            )

        # Run scans with compiled rules
        for cmd in yara_commander.yara_compiled_cmds:
            self.process_scanner.scan_processes(
                config, self, cmd, disabled_rules, results_parser
            )

    def _parse_filesystem_scan_only_option(self, config):
        """
        Parse filesystem_scan_only option to get list of files/directories to scan.

        Returns:
            bool: True if parsing successful or option not specified, False if failed
        """
        filesystem_scan_only = config.filesystem_scan_only
        if not filesystem_scan_only:
            return True

        if not config.do_filesystem_scan:
            logger.error(
                "Skipping filesystem_scan_only option because scan_filesystem is false"
            )
            return False

        # Process as list of files/directories
        if not isinstance(filesystem_scan_only, list):
            filesystem_scan_only = [filesystem_scan_only]

        for item in filesystem_scan_only:
            # Normalize path
            item = os.path.normpath(item).replace("//", "/")

            if not os.path.exists(item):
                logger.info("Skipping missing filesystem_scan_only item: '%s'", item)
            elif os.path.islink(item):
                logger.info(
                    "Skipping symlink filesystem_scan_only item: '%s'. Use non-symlink items",
                    item,
                )
            else:
                self.scan_fsobjects.append(item)

        if self.scan_fsobjects:
            logger.info(
                "Scanning only specified filesystem item%s: %s",
                "s" if len(self.scan_fsobjects) > 1 else "",
                self.scan_fsobjects,
            )
            return True
        else:
            logger.info(
                "Unable to find items specified for the filesystem_scan_only option."
            )
            return False

    def _parse_processes_scan_only_option(self, config):
        """
        Parse processes_scan_only option to get list of processes to scan.

        Returns:
            bool: True if parsing successful or option not specified, False if failed
        """
        processes_scan_only = config.processes_scan_only
        if not processes_scan_only:
            return True

        if not config.do_process_scan:
            logger.error(
                "Skipping processes_scan_only option because scan_processes is false"
            )
            return False

        pids = self._parse_processes_scan_option(processes_scan_only)

        if pids:
            self.scan_pids = sorted(set(pids), key=lambda pid: int(pid))
            logger.info(
                "Scanning only specified process ID%s: %s",
                "s" if len(self.scan_pids) > 1 else "",
                self.scan_pids,
            )
            return True
        else:
            logger.error(
                "Unable to find items specified for the processes_scan_only option"
            )
            return False

    @staticmethod
    def _parse_processes_scan_option(option_items):
        """
        Parse process scan options (PIDs, ranges, or process names).

        Args:
            option_items: List of items (PIDs, ranges like '10..100', or process names)

        Returns:
            list: List of PID strings that match the criteria
        """
        pids = []

        try:
            ps_output = call([["ps", "-eo", "pid=", "-o", "comm="]]).splitlines()
            proc_names = [
                (int(parts[0]), str(parts[1]))
                for parts in [line.split() for line in ps_output]
                if len(parts) >= 2
            ]
            proc_pids = [proc[0] for proc in proc_names]
        except (CalledProcessError, ValueError) as e:  # pragma: no cover
            logger.error("Error getting process list: %s", e)
            return []

        if not isinstance(option_items, list):
            option_items = [str(option_items)]

        for item in option_items:
            if isinstance(item, float):
                # Handle floats so they don't cause exceptions
                item = str(item)

            if isinstance(item, int) or str(item).isdigit():
                # If it's digit, assume it represents a process ID
                if int(item) in proc_pids:
                    logger.debug("Found PID %s", item)
                    pids.append(str(item))
                else:
                    logger.info("Skipping missing PID: %s", item)

            elif ".." in str(item):
                # Assume the item represents a range of process IDs
                try:
                    start_str, end_str = str(item).split("..", 1)
                    start = 1 if not start_str else int(start_str.strip("."))

                    if not end_str:
                        # Read max PID from system
                        try:
                            with open("/proc/sys/kernel/pid_max", "r") as f:
                                end = int(f.read().strip())
                        except (IOError, ValueError):  # pragma: no cover
                            end = 32768  # Default fallback
                    else:
                        end = int(end_str.strip("."))

                    pid_matches = [
                        str(proc) for proc in proc_pids if start <= proc <= end
                    ]

                    logger.debug("Found PID(s) in range '%s': %s", item, pid_matches)
                    if pid_matches:
                        pids.extend(pid_matches)
                    else:  # pragma: no cover
                        logger.info("No PIDs found in range '%s'", item)

                except (ValueError, IndexError) as err:
                    logger.error(
                        "Unable to parse '%s' in to a range of PIDs: %s", item, err
                    )
                    continue

            else:
                # Process name
                pid_matches = [
                    str(proc[0]) for proc in proc_names if str(item) in proc[1]
                ]
                if pid_matches:
                    pids.extend(pid_matches)
                    logger.debug(
                        "Found PID(s) for process name '%s': %s", item, pid_matches
                    )
                else:
                    logger.info("No PID matches found for process name '%s'", item)

        return pids

    def _parse_filesystem_scan_exclude_option(self, config):
        """Parse filesystem_scan_exclude option for files/directories to exclude."""
        if not config.do_filesystem_scan:
            return

        filesystem_scan_exclude = config.filesystem_scan_exclude
        if not filesystem_scan_exclude:
            return

        if not isinstance(filesystem_scan_exclude, list):  # pragma: no cover
            filesystem_scan_exclude = [filesystem_scan_exclude]

        for item in filesystem_scan_exclude:
            item = os.path.normpath(item).replace("//", "/")

            if not os.path.exists(item):
                logger.info("Skipping missing filesystem_scan_exclude item: '%s'", item)
            elif os.path.islink(item):
                logger.info(
                    "Skipping symlink filesystem_scan_exclude item: '%s'. Use non-symlink items",
                    item,
                )
            else:
                self.filesystem_scan_exclude_list.append(item)

        if self.filesystem_scan_exclude_list:
            logger.info(
                "Excluding specified filesystem item%s: %s",
                "s" if len(self.filesystem_scan_exclude_list) > 1 else "",
                self.filesystem_scan_exclude_list,
            )
        else:
            logger.info(
                "Unable to find items specified for the filesystem_scan_exclude option"
            )

    def _parse_processes_scan_exclude_option(self, config):
        """Parse processes_scan_exclude option for processes to exclude."""
        if not config.do_process_scan:
            return

        processes_scan_exclude = config.processes_scan_exclude
        if not processes_scan_exclude:
            return

        pids = self._parse_processes_scan_option(processes_scan_exclude)
        if pids:
            self.processes_scan_exclude_list = sorted(
                set(pids), key=lambda pid: int(pid)
            )
            logger.info(
                "Excluding specified process ID%s: %s",
                "s" if len(self.processes_scan_exclude_list) > 1 else "",
                self.processes_scan_exclude_list,
            )
        else:
            logger.info(
                "Unable to find items specified for the processes_scan_exclude option"
            )

    def _parse_filesystem_scan_since_option(self, config):
        """Parse filesystem_scan_since option for scanning recently modified files."""
        if not config.do_filesystem_scan:
            return

        self.filesystem_scan_since_dict = {"timestamp": None, "datetime": None}
        filesystem_scan_since = config.filesystem_scan_since

        if filesystem_scan_since is not None:
            timestamp = scan_utils.get_scan_since_timestamp(
                config, "filesystem_scan_since", filesystem_scan_since
            )
            if timestamp:
                self.filesystem_scan_since_dict["timestamp"] = timestamp
                self.filesystem_scan_since_dict["datetime"] = datetime.fromtimestamp(
                    timestamp
                ).strftime("%Y-%m-%d %H:%M:%S")

                if isinstance(filesystem_scan_since, str):
                    submessage = "last successful scan on "
                else:
                    submessage = "{} day{} ago on ".format(
                        filesystem_scan_since, "s" if filesystem_scan_since > 1 else ""
                    )

                logger.info(
                    "Scanning files created/modified since %s%s",
                    submessage,
                    self.filesystem_scan_since_dict["datetime"],
                )

    def _parse_processes_scan_since_option(self, config):
        """Parse processes_scan_since option for scanning recently started processes."""
        if not config.do_process_scan:
            return

        self.processes_scan_since_dict = {"timestamp": None, "datetime": None}
        processes_scan_since = config.processes_scan_since

        if processes_scan_since is not None:
            timestamp = scan_utils.get_scan_since_timestamp(
                config, "processes_scan_since", processes_scan_since
            )
            if timestamp:
                self.processes_scan_since_dict["timestamp"] = timestamp
                self.processes_scan_since_dict["datetime"] = datetime.fromtimestamp(
                    timestamp
                ).strftime("%Y-%m-%d %H:%M:%S")

                if isinstance(processes_scan_since, str):  # pragma: no cover
                    submessage = "last successful scan on "
                else:
                    submessage = "{} day{} ago on ".format(
                        processes_scan_since, "s" if processes_scan_since > 1 else ""
                    )

                logger.info(
                    "Scanning processes started since %s%s",
                    submessage,
                    self.processes_scan_since_dict["datetime"],
                )

    def _parse_exclude_network_filesystem_mountpoints_option(self, config):
        """
        Parse exclude_network_filesystem_mountpoints option.

        If enabled, gets list of network filesystem mountpoints to exclude from scanning.
        Uses network_filesystem_types option to determine which filesystem types to look for.
        """
        if not config.do_filesystem_scan:
            return

        self.network_filesystem_mountpoints = []

        if not config.exclude_network_filesystem_mountpoints:
            return

        network_filesystem_types = config.network_filesystem_types
        if not network_filesystem_types:
            logger.error("No value specified for 'network_filesystem_types' option")
            exit(constants.sig_kill_bad)

        # Convert to comma-separated string if it's a list
        if isinstance(network_filesystem_types, list):
            network_filesystem_types = ",".join(network_filesystem_types)

        cmd = ["findmnt", "-t", network_filesystem_types, "-n", "-o", "TARGET"]
        logger.debug(
            "Command to find network filesystem mountpoints: %s", " ".join(cmd)
        )

        try:
            output = call([cmd])
        except CalledProcessError as err:  # pragma: no cover
            logger.error(
                "Unable to get network filesystem mountpoints: %s", err.output.strip()
            )
            exit(constants.sig_kill_bad)

        self.network_filesystem_mountpoints = (
            str(output).strip().split("\n") if output else []
        )

        if self.network_filesystem_mountpoints:
            logger.info(
                "Excluding network filesystem mountpoints: %s",
                self.network_filesystem_mountpoints,
            )
        else:
            logger.debug("No mounted network filesystems found")

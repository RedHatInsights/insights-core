"""
Utility functions for malware detection file and process scanning.

This module provides utilities for:
- Processing include/exclude directory lists
- Finding recently modified files
- Managing scan timestamps
- Directory scanning logic

Compatible with Python 2.7 and 3.x.
"""

import os
import logging
import time
from datetime import datetime

from insights.client.constants import InsightsConstants as constants

logger = logging.getLogger(__name__)


def get_toplevel_dirs():
    """
    Get all top-level directories under root (/).

    Returns:
        list: Sorted list of top-level directories, excluding symlinks

    Example:
        ['/bin', '/boot', '/dev', '/etc', '/home', '/lib', ...]
    """
    root_contents = os.listdir("/")

    # Build full paths and filter out symlinks
    toplevel_dirs = []
    for item in root_contents:
        full_path = "/" + item
        if not os.path.islink(full_path):
            toplevel_dirs.append(full_path)

    return sorted(toplevel_dirs)


def is_same_file_or_root(file1, file2):
    """
    Check if two filesystem paths refer to the same file or if file1 is root.

    Handles permission errors that can occur with FUSE mounted filesystems.
    Falls back to string comparison if os.path.samefile fails.

    Args:
        file1 (str): First file path
        file2 (str): Second file path

    Returns:
        bool: True if paths are the same or if file1 is root, False otherwise
    """
    try:
        return os.path.samefile(file1, file2) or os.path.samefile(file1, "/")
    except Exception as error:
        logger.debug(
            "Encountered exception running os.path.samefile('%s', '%s'): %s. "
            "Trying string comparison...",
            file1,
            file2,
            str(error),
        )
        return file1 == file2 or file1 == "/"


def get_parent_dirs(item, parent_dir_list, base_case="/"):
    """
    Build a list of parent directories for a filesystem item.

    Recursively builds the path from base_case (root) to the item.

    Args:
        item (str): The filesystem item path
        parent_dir_list (list): List to populate with parent directories
        base_case (str): Base directory to stop at (default: "/")

    Example:
        get_parent_dirs('/path/to/some/item', []) results in:
        ['/path', '/path/to', '/path/to/some', '/path/to/some/item']

    Note:
        Modifies parent_dir_list in place
    """
    if is_same_file_or_root(item, base_case):
        return

    # Recursively process parent directory first
    get_parent_dirs(os.path.dirname(item), parent_dir_list, base_case)
    parent_dir_list.append(item)


def process_include_items(include_items=None):
    """
    Process include items to get a list of directories to be scanned.

    Args:
        include_items (list, optional): List of directory/file paths to include.
                                      Defaults to None.

    Returns:
        list: List of directories to be scanned (never empty)

    Note:
        If no valid items are provided, returns all top-level directories.
        Root directory ('/') takes precedence over all other items.
        Skips symlinks, comments, and non-existent paths.
    """
    if include_items is None:
        include_items = []

    default_values = get_toplevel_dirs()

    logger.debug("Parsing include items...")
    parsed_list = []

    for item in include_items:
        item = item.strip()

        # Skip empty items and comments
        if not item or item.startswith("#"):
            continue

        # Normalize path
        include_item = os.path.normpath(item).replace("//", "/")

        if not os.path.exists(include_item):
            logger.debug("Skipping missing item '%s' ...", include_item)
            continue

        # Skip partial paths (must be absolute)
        if not include_item.startswith("/"):
            logger.debug("Skipping partial directory path '%s' ...", include_item)
            continue

        # Skip symbolic links
        if os.path.islink(include_item):
            logger.debug("Skipping link '%s' ...", include_item)
            continue

        # Root directory overrides everything else
        if include_item == "/":
            logger.debug(
                "Found root directory in list of items to scan. "
                "Ignoring the other items ..."
            )
            parsed_list = default_values
            break

        parsed_list.append(include_item)

    # Use defaults if no valid items were found
    if not parsed_list:
        logger.debug(
            "No items specified to be scanned. Using default values %s...",
            default_values,
        )
        parsed_list = default_values
    else:
        # Remove duplicates and child items
        parsed_list = remove_child_items(sorted(list(set(parsed_list))))

    logger.debug("Include items: %s", parsed_list)
    return parsed_list


def process_exclude_items(exclude_items=None):
    """
    Process exclude items to get list of directories to NOT be scanned.

    Args:
        exclude_items (list, optional): List of directory/file paths to exclude.
                                      Defaults to None.

    Returns:
        list: List of directories to exclude from scanning (may be empty)

    Note:
        Root directory ('/') in exclude list expands to all top-level directories.
        Skips partial paths, comments, and non-existent paths.
    """
    if exclude_items is None:
        exclude_items = []

    logger.debug("Parsing exclude items...")
    parsed_list = []

    for item in exclude_items:
        item = item.strip()

        # Skip empty items and comments
        if not item or item.startswith("#"):
            continue

        # Normalize path
        exclude_item = os.path.normpath(item).replace("//", "/")

        if not os.path.exists(exclude_item):
            logger.debug("Skipping missing item '%s' ...", exclude_item)
            continue

        # Root directory means exclude everything
        if exclude_item == "/":
            logger.debug(
                "Found root directory in the exclude list. "
                "Expanding it to all toplevel directories ..."
            )
            parsed_list = get_toplevel_dirs()
            break

        # Skip partial paths (must be absolute)
        if not exclude_item.startswith("/"):
            logger.debug("Skipping partial directory path '%s' ...", exclude_item)
            continue

        parsed_list.append(exclude_item)

    if not parsed_list:
        logger.debug("No items specified to be excluded")
    else:
        # Remove duplicates and child items
        parsed_list = remove_child_items(sorted(list(set(parsed_list))))

    logger.debug("Exclude items: %s", parsed_list)
    return parsed_list


def remove_child_items(item_list):
    """
    Remove duplicate items and child directories from a list of filesystem paths.

    Args:
        item_list (list): List of filesystem paths

    Returns:
        list: Cleaned list with no duplicates or child directories

    Example:
        Input: ['/path/to/some/item/child', '/path/to/another/item', '/path/to/some/item']
        Output: ['/path/to/another/item', '/path/to/some/item']

    Note:
        If root ("/") is present, it takes precedence over all other items.
        Only keeps items with full paths (starting with "/").
    """
    # Root directory overrides everything
    if "/" in item_list:
        return ["/"]

    # Filter to only full paths and remove duplicates
    full_path_items = []
    for item in item_list:
        if item.startswith("/"):
            full_path_items.append(item)

    item_list = sorted(list(set(full_path_items)))
    items_to_remove = set()

    # Find child directories to remove
    for i, parent_item in enumerate(item_list[:-1]):
        for child_item in item_list[i + 1 :]:
            if parent_item != child_item and child_item.startswith(parent_item + "/"):
                items_to_remove.add(child_item)

    # Remove child directories
    for remove_item in items_to_remove:
        item_list.remove(remove_item)

    return sorted(list(set(item_list)))


def remove_included_excluded_items(included_items, excluded_items):
    """
    Remove included items that are in the exclude list or are children of excluded items.

    Args:
        included_items (list): List of items to include in scanning
        excluded_items (list): List of items to exclude from scanning

    Returns:
        list: Cleaned included_items with excluded items removed

    Note:
        Automatically cleans up both lists to remove child items.
        An included item is removed if it matches an excluded item exactly
        or if it's a child of an excluded item.
    """
    # Clean up the lists to remove duplicates and child items
    included_items = remove_child_items(
        included_items[:]
    )  # Copy to avoid modifying original
    excluded_items = remove_child_items(excluded_items)

    items_to_remove = set()

    # Find included items that should be excluded
    for included_item in included_items:
        for excluded_item in excluded_items:
            # Remove if exact match or if included item is child of excluded item
            if excluded_item == included_item or included_item.startswith(
                excluded_item + "/"
            ):
                items_to_remove.add(included_item)
                break  # No need to check other excluded items

    # Remove the excluded items from included list
    for remove_item in items_to_remove:
        included_items.remove(remove_item)

    return included_items


def process_include_exclude_items(
    include_items=[], exclude_items=[], exclude_mountpoints=[]
):
    """
    Process the include and exclude items, where the exclude items are effectively subtracted from the include_items.
    It builds a scan_dict dictionary of items to scan keyed by the filesystem top level directories.
    Only the toplevel directories from items in the include_items list will be present in scan_dict.
    scan_dict = {'/boot': {'include': ['/boot/include/me', ...], 'exclude: ['/boot/exclude/me', ...]},
                 '/etc': {'include': ['/etc/include/me', ...], 'exclude: ['/etc/exclude/me', ...]},
                 ...
    :return: scan_dict
    """
    # Get a list of excluded items from the exclude file and network filesystem mountpoints
    initial_exclude_list = process_exclude_items(exclude_items)
    final_exclude_list = remove_child_items(
        list(set(exclude_mountpoints) | set(initial_exclude_list))
    )
    logger.debug("Final exclude items: %s", final_exclude_list)

    # Get a list of included items from the include file, minus the excluded items
    initial_include_list = process_include_items(include_items)
    if not initial_include_list:
        logger.error(
            "No filesystem items to scan because the include items doesn't contain any valid items"
        )
        return {}
    final_include_list = remove_included_excluded_items(
        initial_include_list, final_exclude_list
    )
    logger.debug(
        "Final include items after removing exclude items: %s", final_include_list
    )
    if not final_include_list:
        logger.error(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )
        return {}

    # This is the dictionary that will hold all the items to scan (after processing the include and exclude items)
    # It will be keyed by each of the toplevel directories containing items to scan
    # yara will scan each of the toplevel dir's 'include' keys (if present), or just the toplevel dir itself
    scan_dict = {}

    # Populate the scan_dict by creating keys for each toplevel directory of the items to include/scan
    # Create an 'include' key for each toplevel directory containing items to include in that toplevel directory
    logger.debug("Populating scan_dict's include items ...")
    for include_item in final_include_list:
        item_subpaths = []
        get_parent_dirs(include_item, item_subpaths)
        include_item_toplevel_dir = item_subpaths[0]
        if include_item_toplevel_dir not in scan_dict:
            # Create an 'include' key if the item to scan isn't just the toplevel directory itself
            scan_dict[include_item_toplevel_dir] = (
                {"include": set([include_item])}
                if include_item != include_item_toplevel_dir
                else {}
            )
        else:
            scan_dict[include_item_toplevel_dir]["include"].add(include_item)

    logger.debug("Scan dict after adding include items: %s", scan_dict)

    # Populate an 'exclude' key for the toplevel dirs in the scan_dict that also have items to exclude
    # Or remove the toplevel dirs from the scan dict where the toplevel dir itself is to be excluded
    logger.debug("Populating scan_dict's exclude items ...")
    for exclude_item in final_exclude_list:
        item_subpaths = []
        get_parent_dirs(exclude_item, item_subpaths)
        exclude_item_toplevel_dir = item_subpaths[0]
        if exclude_item_toplevel_dir not in scan_dict:
            # This exclude_item's toplevel dir isn't in the scan dict, so skip it (since its not being included)
            continue
        if "exclude" not in scan_dict[exclude_item_toplevel_dir]:
            # Create the 'exclude' key if it doesn't already exist
            scan_dict[exclude_item_toplevel_dir]["exclude"] = {
                "items": [],
                "subpaths": set([]),
            }

        scan_dict[exclude_item_toplevel_dir]["exclude"]["items"].append(exclude_item)

        # Add the list of subpaths leading to this exclude item.
        # The subpaths are needed later for listing the contents each subpath
        scan_dict[exclude_item_toplevel_dir]["exclude"]["subpaths"].update(
            item_subpaths
        )

    logger.debug("Scan dict after adding exclude items: %s", scan_dict)

    # For each toplevel dir with items to exclude, re-populate the include key with directory content listings
    # of the subpaths, minus the items to exclude and only including items to include.  Yep, its complicated.
    # These directory listings will be used with yara's --scan-list option
    logger.debug(
        "Re-populating scan_dict's include items with directory content listings to pass to yara ..."
    )
    for toplevel_dir in scan_dict:
        if "exclude" not in scan_dict[toplevel_dir]:
            continue

        # Get directory listings of each of the subpaths
        if "include" in scan_dict[toplevel_dir]:
            scan_items = set(scan_dict[toplevel_dir]["include"])
        else:
            scan_items = set([])
        toplevel_dir_exclude = scan_dict[toplevel_dir]["exclude"]
        for exclude_item in toplevel_dir_exclude["items"]:
            subpaths = []
            get_parent_dirs(exclude_item, subpaths)
            for i, subpath in enumerate(subpaths[:-1]):
                dir_list = os.listdir(subpath)
                dir_list = sorted(map(lambda x: subpath + "/" + x, dir_list))
                dir_list.remove(subpaths[i + 1])
                scan_items.update(dir_list)

        # Go through the list of scan items and remove any exclude items or exclude item subpaths
        for scan_item in list(scan_items):
            for exclude_item in toplevel_dir_exclude["items"]:
                if scan_item == exclude_item or scan_item.startswith(
                    exclude_item + "/"
                ):
                    scan_items.remove(scan_item)
                    break
            else:
                for exclude_subpath in toplevel_dir_exclude["subpaths"]:
                    if scan_item == exclude_subpath:
                        scan_items.remove(scan_item)

        # If there is an include list, make sure the scan_items only include items in the include list
        if "include" in scan_dict[toplevel_dir]:
            for maybe_include in list(scan_items):
                if os.path.islink(maybe_include) or (
                    not os.path.isfile(maybe_include)
                    and not os.path.isdir(maybe_include)
                ):
                    scan_items.remove(maybe_include)
                    continue
                if any(
                    [
                        maybe_include == definitely_include
                        or maybe_include.startswith(definitely_include + "/")
                        for definitely_include in scan_dict[toplevel_dir]["include"]
                    ]
                ):
                    continue
                else:
                    scan_items.remove(maybe_include)

        # Overwrite the existing include key list with the new list of scan_items
        scan_dict[toplevel_dir]["include"] = sorted(list(scan_items))

    logger.debug("Final scan_dict: %s", scan_dict)
    return scan_dict


def get_scan_since_timestamp(config, scan_since_option, since):
    """
    Convert scan_since option to a Unix timestamp.

    Args:
        config: MalwareConfig: config attributes
        scan_since_option (str): Either 'filesystem_scan_since' or 'processes_scan_since'
        since: Integer (days back) or string 'last' (last successful scan)

    Returns:
        float or None: Unix timestamp for the cutoff time, or None if invalid

    Raises:
        SystemExit: If invalid values are provided

    Note:
        For integer values: returns timestamp for N days ago
        For 'last': reads timestamp from last successful scan file
    """
    SECONDS_PER_DAY = 86400
    now = time.time()

    # Determine which timestamp file to use
    timestamp_file = (
        config.last_filesystem_scan_file
        if scan_since_option == "filesystem_scan_since"
        else config.last_processes_scan_file
    )

    def _parse_last_scan_timestamp(scan_since_option, lastscan_str):
        """Parse the last scan timestamp from file content."""
        try:  # pragma: no cover
            lastscan_seconds = float(
                datetime.strptime(lastscan_str, "%Y-%m-%dT%H:%M:%S.%f").strftime("%s")
            )
            if lastscan_seconds > now:
                raise RuntimeError("Last scan time is in the future.")
            return lastscan_seconds
        except Exception as error:
            logger.error(
                "Error getting time of last malware scan: %s. "
                "Ignoring '%s: last' option...",
                str(error),
                scan_since_option,
            )
            return None

    # Handle 'last' option
    if isinstance(since, str) and since.lower().startswith("l"):
        if os.path.isfile(timestamp_file):  # pragma: no cover
            with open(timestamp_file) as timestamp_file_handle:
                lastscan = timestamp_file_handle.readline().strip()
            return _parse_last_scan_timestamp(scan_since_option, lastscan)
        else:
            logger.info(
                "File %s doesn't exist for '%s: last' option. Continuing...",
                timestamp_file,
                scan_since_option,
            )
            return None

    # Handle invalid string values
    elif isinstance(since, str):
        logger.error(
            "Unknown value '%s' for %s option. "
            "Valid values are integers >= 1 and 'last'",
            since,
            scan_since_option,
        )
        exit(constants.sig_kill_bad)

    # Handle integer values (days back)
    try:
        since_int = int(since)
        if since_int >= 1:
            return now - (since_int * SECONDS_PER_DAY)
        else:
            raise ValueError(
                "Invalid {option} value {value}. "
                "Valid values are integers >= 1 and 'last'".format(
                    option=scan_since_option, value=since
                )
            )
    except ValueError as error:
        logger.error(str(error))
        exit(constants.sig_kill_bad)


def is_recent_mtime(item, timestamp):
    """
    Check if a file has been modified more recently than the given timestamp.

    Args:
        item (str): Path to the file to check
        timestamp (float): Unix timestamp to compare against

    Returns:
        bool: True if file exists, is a regular file (not link/pipe), and was
              modified after timestamp. False otherwise.

    Note:
        Ignores symlinks and non-regular files for security reasons.
    """
    return (
        os.path.exists(item)
        and not os.path.islink(item)
        and os.path.isfile(item)
        and os.path.getmtime(item) > timestamp
    )


def find_modified_in_directory(directory, timestamp, output_file):
    """
    Find files modified after timestamp in a directory tree.

    Recursively walks through directory and writes paths of recently
    modified files to the output file.

    Args:
        directory (str): Root directory to search
        timestamp (float): Unix timestamp cutoff
        output_file (file): Open file object to write results to

    Note:
        Uses os.walk for recursive traversal.
        Each matching file path is written on a separate line.
    """
    for root, dirs, files in os.walk(directory):
        for filename in files:
            file_path = os.path.join(root, filename)
            if is_recent_mtime(file_path, timestamp):
                output_file.write(file_path + "\n")


def find_modified_include_items(item_list, timestamp, output_file):
    """
    Find recently modified files from a list of files and directories.

    Args:
        item_list (list): List of file/directory paths to check
        timestamp (float): Unix timestamp cutoff
        output_file (file): Open file object to write results to

    Note:
        For directories: recursively finds all modified files within
        For files: checks if the individual file was modified
        Results are written one path per line to output_file
    """
    for item in item_list:
        if os.path.isdir(item):
            find_modified_in_directory(item, timestamp, output_file)
        elif is_recent_mtime(item, timestamp):
            output_file.write(item + "\n")

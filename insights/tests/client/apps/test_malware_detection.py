import os
import re
import sys

import pytest
import yaml
import time
import string
import random
import fileinput
from datetime import datetime
from mock.mock import patch, Mock, ANY
try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from insights.client.apps.manifests import manifests, content_types
from insights.util.subproc import call, CalledProcessError
from insights.client.config import InsightsConfig
from insights.tests.helpers import getenv_bool

from insights.client.apps.malware_detection import (
    DEFAULT_MALWARE_CONFIG, MalwareDetectionClient, InsightsConnection,
    get_toplevel_dirs, get_parent_dirs, remove_child_items, remove_included_excluded_items,
    process_include_items, process_exclude_items, process_include_exclude_items
)

# Temporary directory for testing stuff in
RANDOM_STRING = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))
TEMP_TEST_DIR = "/tmp/malware-detection_test_dir_%s" % RANDOM_STRING

YARA = '/bin/yara'  # Fake yara executable
RULES_FILE = os.path.join(TEMP_TEST_DIR, 'rules.yar')
TEST_RULE_FILE = os.path.join(TEMP_TEST_DIR, 'test-rule.yar')
TEST_RULE_SCRIPT = os.path.join(TEMP_TEST_DIR, 'test-rule_process_match.sh')
CONFIG = yaml.safe_load(DEFAULT_MALWARE_CONFIG)  # Config 'returned' from _load_config
TEMP_CONFIG_FILE = os.path.join(TEMP_TEST_DIR, 'malware-detection-config.yml')
TEST_PID = str(os.getpid())  # This running processes ID

# Get the number of CPU threads to run yara
CPUS = 1 if int(call('nproc').strip()) <= 2 else 2

# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = ['/boot', '/dev', '/etc', '/home', '/opt', '/proc', '/root', '/sys', '/tmp', '/usr', '/var']
INCLUDED_TLDS = ['/boot', '/etc', '/home', '/opt', '/root', '/tmp', '/usr', '/var']  # after removing exclude items
DEFAULT_SCAN_EXCLUDE = ['/cgroup', '/dev', '/media', '/mnt', '/net', '/proc', '/selinux', '/sys']

# Various patch targets
LOGGER_TARGET = "insights.client.apps.malware_detection.logger"
LOAD_CONFIG_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._load_config"
FIND_YARA_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._find_yara"
GET_RULES_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._get_rules"
BUILD_YARA_COMMAND_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._build_yara_command"
FINDMNT_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._parse_exclude_network_filesystem_mountpoints_option"

# Run the test_processes_scan_since test?
TEST_PROCESSES_SCAN_SINCE = getenv_bool("TEST_PROCESSES_SCAN_SINCE", False)

# Are we running on RHEL6? (well actually, with python 2.6)
IS_RHEL6 = sys.version_info < (2, 7)
SKIP_IF_RHEL6_REASON = "The malware-detection client isn't supported on RHEL6 / python 2.6"


@pytest.fixture
def create_test_files():
    # Write the test files to the temp directory
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    with open(TEMP_CONFIG_FILE, 'w') as tcf:
        tcf.write(DEFAULT_MALWARE_CONFIG)
    test_files = [(MATCHING_ENTITY_FILE, MATCHING_ENTITY_FILE_CONTENTS),
                  (ANOTHER_MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE_CONTENTS),
                  (TEST_RULE_FILE, TEST_RULE_FILE_CONTENTS),
                  (TEST_RULE_SCRIPT, TEST_RULE_SCRIPT_CONTENTS)]
    for test_file, contents in test_files:
        if not os.path.exists(test_file):
            with open(test_file, 'w') as f:
                f.write(contents)
    os.chmod(TEST_RULE_SCRIPT, 0o755)
    yield
    os.system('rm -rf %s' % TEMP_TEST_DIR)


@pytest.fixture
def extract_tmp_files():
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    os.system("echo '%s' | base64 -d - | tar -C %s -zxf -" % (SCAN_FILES_BASE64, TEMP_TEST_DIR))
    yield
    os.system('rm -rf %s' % TEMP_TEST_DIR)


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
class TestDefaultValues:
    def test_default_spec(self):
        # Read in the default malware spec and check its values
        manifest = yaml.safe_load(manifests['malware-detection'])
        content_type = content_types['malware-detection']
        assert content_type == "application/vnd.redhat.malware-detection.results+tgz"
        specs = manifest['plugins']['configs']
        for spec in ['mac_addresses', 'etc_machine_id', 'hostname', 'bios_uuid', 'machine_id', 'ip_addresses',
                     'subscription_manager_id']:
            assert {'enabled': True, 'name': 'insights.specs.default.DefaultSpecs.%s' % spec} in specs
            assert {'enabled': True, 'name': 'insights.specs.Specs.%s' % spec} in specs

    def test_default_options(self):
        # Read in the default malware_detection_config options and check their values
        assert CONFIG['test_scan'] is True
        assert CONFIG['scan_filesystem'] is True
        assert CONFIG['scan_processes'] is False
        assert CONFIG['filesystem_scan_only'] is None
        assert CONFIG['processes_scan_only'] is None
        assert CONFIG['filesystem_scan_since'] is None
        assert CONFIG['processes_scan_since'] is None
        assert all([x in CONFIG['filesystem_scan_exclude']
                    for x in ['/proc', '/sys', '/cgroup', '/selinux', '/net', '/mnt', '/media', '/dev']])
        assert CONFIG['processes_scan_exclude'] is None
        assert CONFIG['exclude_network_filesystem_mountpoints'] is True

    @patch(BUILD_YARA_COMMAND_TARGET)
    @patch(GET_RULES_TARGET, return_value=TEST_RULE_FILE)
    @patch(FIND_YARA_TARGET, return_value=YARA)
    @patch(LOGGER_TARGET)
    def test_running_default_options(self, log_mock, yara, rules, cmd, create_test_files):
        # Try running malware-detection with the default options
        # With the default options, test_scan is true, so some of the option values will be changed for that and
        # will be different from those in the default config file.
        # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
        # Use a real config file so scan_fsobjects will be populated properly
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == YARA
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True
        assert mdc.scan_fsobjects == [TEMP_CONFIG_FILE]
        assert mdc.scan_pids == [TEST_PID]
        assert mdc.filesystem_scan_since_dict == {'timestamp': None}
        assert mdc.filesystem_scan_exclude_list == []
        assert mdc.processes_scan_exclude_list == []
        assert mdc.processes_scan_since_dict == {'timestamp': None}
        assert mdc.network_filesystem_mountpoints == []
        assert mdc.scan_timeout == 3600
        assert mdc.nice_value == 19

        with patch("insights.client.apps.malware_detection.call") as call_mock:
            # Mock all the calls to 'call' to get the yara matches and the metadata about the matches for the test scan
            # 1st call is yara output from scanning TEST_RULE_FILE, calls 2-6 are to get its metadata
            # 7th call is yara output from scanning the current process and 8th is to get its metadata
            call_mock.side_effect = ["TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client" % TEST_RULE_FILE,
                                     "ASCII text", "text/plain; charset=us-ascii", "d5b0aeb3e18df68f47287e14ef144489",
                                     "2:74:Malware Detection Client",
                                     "// Verifies the Red Hat Insights Malware Detection Client app is present on the system",
                                     "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client" % TEST_PID,
                                     "python insights_client/run.py --collector malware-detection"]
            mutation = mdc.run()
        log_mock.info.assert_any_call("Found %d rule match%s.", 2, "es")
        assert 'ruleName: "TEST_RedHatInsightsMalwareDetection"' in mutation
        assert 'source: "%s"' % TEST_RULE_FILE in mutation
        assert 'source: "%s"' % TEST_PID in mutation
        assert re.search('metadata:.*line_number', mutation)
        assert re.search('metadata:.*process_name', mutation)


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch(LOGGER_TARGET)
class TestFindYara:

    def test_find_yara_binary(self, log_mock, conf, rules, cmd):
        # Testing finding yara with correct version
        with patch('os.path.exists', return_value=True):
            with patch("insights.client.apps.malware_detection.call", return_value='4.1'):
                mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == '/bin/yara'
        cmd.assert_called()

        # 'Find' yara in /usr/local/bin/yara (fails to 'find' /bin/yara and /usr/bin/yara)
        with patch('os.path.exists', side_effect=[False, False, True]):
            with patch("insights.client.apps.malware_detection.call", return_value='4.1'):
                mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == '/usr/local/bin/yara'
        cmd.assert_called()

    def test_find_unsupported_yara(self, log_mock, conf, rules, cmd):
        # Test finding unsupported yara version
        with patch('os.path.exists', return_value=True):
            with patch("insights.client.apps.malware_detection.call", return_value='3.10'):
                with pytest.raises(SystemExit):
                    MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Found /bin/yara with version 3.10, but malware-detection requires version >= 4.1.0\n"
                                          "Please install a later version of yara.")
        cmd.assert_not_called()

    def test_find_invalid_yara(self, log_mock, conf, rules, cmd):
        # Test finding a binary called yara, but its not yara
        with patch('os.path.exists', return_value=True):
            with patch("insights.client.apps.malware_detection.call", return_value='not yara 1.2.3'):
                with pytest.raises(SystemExit):
                    MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error getting the version of the specified yara binary %s: %s", "/bin/yara", ANY)
        cmd.assert_not_called()

    def test_cant_find_yara(self, log_mock, conf, rules, cmd):
        # Test can't find yara on the system
        with patch('os.path.exists', return_value=False):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Couldn't find yara.  Please ensure the yara package is installed")
        cmd.assert_not_called()

    @patch("os.path.exists", return_value=True)
    @patch("insights.client.apps.malware_detection.call")  # mock call to 'yara --version'
    def test_invalid_yara_versions(self, version_mock, exists_mock, log_mock, conf, rules, cmd):
        # Test checking the version of yara
        # Invalid versions of yara
        for version in ['4.0.99', '4']:
            version_mock.return_value = version
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        cmd.assert_not_called()  # We won't get to the build_yara_cmd method because we exit before its called

        # Valid versions of yara
        for version in ['4.1', '10.0.0']:
            version_mock.return_value = version
            mdc = MalwareDetectionClient(None)
            assert mdc.yara_binary == '/bin/yara'
        cmd.assert_called()


# Use patch.object, just because I wanted to try using patch.object instead of using patch all the time :shrug:
@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch('os.remove')  # Mock os.remove so it doesn't actually try to remove any existing files
@patch.object(MalwareDetectionClient, '_parse_exclude_network_filesystem_mountpoints_option')
@patch.object(InsightsConnection, 'get', return_value=Mock(status_code=200, content=b"Rule Content"))
@patch.object(InsightsConnection, 'get_proxies')
@patch.object(InsightsConnection, '_init_session', return_value=Mock())
@patch.object(MalwareDetectionClient, '_build_yara_command')
@patch.object(MalwareDetectionClient, '_find_yara', return_value=YARA)
@patch.object(MalwareDetectionClient, '_load_config', return_value=CONFIG)
class TestGetRules:
    """ Testing the _get_rules method """

    @patch.dict(os.environ, {'TEST_SCAN': 'true'})
    def test_download_rules_cert_auth(self, conf, yara, cmd, session, proxies, get, findmnt, remove):
        # Test the standard rules_location urls, but will result in cert auth being used to download the rules
        # Test with insights-config None, expect an error when trying to use the insights-config object
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        session.assert_not_called()

        # With default insights config and test scan true ...
        # Expect to use cert auth because no username or password specified and expect to download test-rule.yar
        mdc = MalwareDetectionClient(InsightsConfig())
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
        assert mdc.rules_file.startswith('/tmp')  # rules will be saved into a temp file
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)

        # With authmethod=CERT, expect 'cert.' to be prefixed to the url
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)

        # With authmethod=BASIC and test scan false ...
        # Expect to still use cert auth because no username or password specified
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='BASIC'))
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar", log_response_text=False)

        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar", log_response_text=False)

    @patch.dict(os.environ, {'TEST_SCAN': 'true'})
    @patch(LOGGER_TARGET)
    def test_download_rules_basic_auth(self, log_mock, conf, yara, cmd, session, proxies, get, findmnt, remove):
        # Test the standard rules_location urls, with basic auth attempting to be used to download the rules
        # Basic auth is used by default, but needs to have a valid username and password for it to work
        # Without a username and password, then cert auth will be used

        # Test with just a username specified - expect basic auth to be used but fails
        get.return_value = Mock(status_code=401, reason="Unauthorized", text="No can do")
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(username='user'))
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)
        log_mock.error.assert_called_with("%s %s: %s", 401, "Unauthorized", ANY)

        # Test with just a password specified - expect basic auth to be used but fails
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(password='pass'))
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)
        log_mock.error.assert_called_with("%s %s: %s", 401, "Unauthorized", ANY)

        # Test with 'incorrect' username and/or password - expect basic auth failure
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(username='user', password='badpass'))
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)
        log_mock.error.assert_called_with("%s %s: %s", 401, "Unauthorized", ANY)

        # Test with 'correct' username and password - expect basic auth success
        get.return_value = Mock(status_code=200, content=b"Rule Content")
        mdc = MalwareDetectionClient(InsightsConfig(username='user', password='goodpass'))
        assert mdc.rules_location == "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/test-rule.yar", log_response_text=True)

    @patch.dict(os.environ, {'TEST_SCAN': 'true', 'RULES_LOCATION': 'console.redhat.com/rules.yar'})
    def test_get_rules_missing_protocol(self, conf, yara, cmd, session, proxies, get, findmnt, remove):
        # Non-standard rules URLS - without https:// at the start and not signatures.yar
        # test-scan true and BASIC auth by default expect test-rule.yar and no 'cert.' in URL
        mdc = MalwareDetectionClient(InsightsConfig(username='user', password='pass'))
        assert mdc.rules_location == "https://console.redhat.com/test-rule.yar"
        get.assert_called_with("https://console.redhat.com/test-rule.yar", log_response_text=True)

        # test-scan false and CERT auth - expect 'cert.' prefixed to the URL and not test-rule.yar
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/rules.yar"
        get.assert_called_with("https://cert.console.redhat.com/rules.yar", log_response_text=False)

    @patch.dict(os.environ, {'TEST_SCAN': 'false', 'RULES_LOCATION': 'http://localhost/rules.yar'})
    @patch(LOGGER_TARGET)
    def test_download_failures(self, log_mock, conf, yara, cmd, session, proxies, get, findmnt, remove):
        from requests.exceptions import ConnectionError, Timeout
        # Test various problems downloading rules
        # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
        get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        log_mock.error.assert_called_with("%s %s: %s", 404, "Not found", "Nup")
        assert get.call_count == 1

        # Test other errors downloading rules from the backend - these are more likely to occur
        # Firstly handling an error like connection refused (Couldn't connect)
        get.side_effect = [ConnectionError("Couldn't connect"), Timeout("Timeout")]
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(username='user', password='pass'))
        log_mock.error.assert_called_with("Unable to download rules from %s: %s",
                                          os.environ['RULES_LOCATION'], "Couldn't connect")
        assert get.call_count == 2

        # Then handling a Timeout error
        # Note, because we aren't downloading from console.redhat.com, there won't be 'cert.*' appended to the URL
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        log_mock.error.assert_called_with("Unable to download rules from %s: %s",
                                          os.environ['RULES_LOCATION'], "Timeout")
        assert get.call_count == 3

    @patch.dict(os.environ, {'TEST_SCAN': 'true', 'RULES_LOCATION': '//console.redhat.com/rules.yar'})
    @patch("os.path.isfile", return_value=True)
    def test_get_rules_location_as_file(self, isfile, conf, yara, cmd, session, proxies, get, findmnt, remove):
        # Test using files for rules_location, esp irregular file names
        # rules_location that starts with a '/' is assumed to be a file, even if its a double '//'
        # Re-writing the rule to be test-rule.yar doesn't apply to local files
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == "//console.redhat.com/rules.yar"
        assert mdc.rules_file == "/console.redhat.com/rules.yar"
        get.assert_not_called()

        # Just to confirm the filename stays the same for regardless of test_rule value
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == "//console.redhat.com/rules.yar"
        assert mdc.rules_file == "/console.redhat.com/rules.yar"
        get.assert_not_called()

    @patch.dict(os.environ, {'TEST_SCAN': 'true'})
    @patch(LOGGER_TARGET)
    def test_via_satellite_proxy(self, log_mock, conf, yara, cmd, session, proxies, get, findmnt, remove):
        # Test recognizing and handling of Satellite URLs.
        # Satellite URLs have '/redhat_access/' in their path (which is how the Satellite knows to redirect the
        # query to C.R.C).
        # For malware-detection requests through a Satellite we append the malware-detection path and add https://
        satellite_url = 'satellite.example.com:443/redhat_access/r/insights/platform'

        # Firstly try with test-rule
        replaced_url = "https://satellite.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/test-rule.yar"
        mdc = MalwareDetectionClient(InsightsConfig(base_url=satellite_url, verbose=True))
        assert mdc.rules_location == replaced_url
        get.assert_called_with(replaced_url, log_response_text=True)
        log_mock.debug.assert_called_with("Downloading rules from: %s", replaced_url)

        # Then with the actual rules file
        os.environ['TEST_SCAN'] = 'false'
        replaced_url = "https://satellite.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/signatures.yar"
        mdc = MalwareDetectionClient(InsightsConfig(base_url=satellite_url, verbose=True))
        assert mdc.rules_location == replaced_url
        get.assert_called_with(replaced_url, log_response_text=False)
        log_mock.debug.assert_called_with("Downloading rules from: %s", replaced_url)


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestBuildYaraCmd:

    @patch('os.path.getsize')
    def test_build_yara_command_success(self, size, conf, yara, rules):
        expected_yara_cmd = "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1}".format(YARA, RULES_FILE)
        size.return_value = 1
        # Use side_effect with 3 'call' values because build_yara_command calls 'call' 3 times ...
        # 1 to get the type of the rules file; 2 to see if the rules files contains valid rules; 3 to call nproc
        # Test with text rules file - file type is 'ascii'
        with patch("insights.client.apps.malware_detection.call", side_effect=['ascii', 'ok', '2']) as call_mock:
            mdc = MalwareDetectionClient(None)
            assert call_mock.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ''

        # Test with 'compiled' rules file - file type is 'Yara 3.x'
        with patch("insights.client.apps.malware_detection.call", side_effect=['Yara 3.X', 'ok', '2']) as call_mock:
            mdc = MalwareDetectionClient(None)
            assert call_mock.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ' -C'

        # Another test with compiled rules file - file type is 'data'
        with patch("insights.client.apps.malware_detection.call", side_effect=['data', 'ok', '2']) as call_mock:
            mdc = MalwareDetectionClient(None)
            assert call_mock.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ' -C'

    @patch(LOGGER_TARGET)
    @patch('os.path.getsize')
    def test_build_yara_command_fail(self, size_mock, log_mock, conf, yara, rules):
        # Test with empty rules file, ie file size is 0
        size_mock.return_value = 0
        with patch("insights.client.apps.malware_detection.call", side_effect=['wtf?', 'yikes', '2']) as call_mock:
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            call_mock.assert_called_once()  # Only 1 call to 'call' before we exit
        log_mock.error.assert_called_with("Rules file %s is empty", RULES_FILE)

        # Test with empty rules files, ie the file type is 'empty'
        size_mock.return_value = 1
        with patch("insights.client.apps.malware_detection.call", side_effect=['empty', 'yikes', '2']) as call_mock:
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            call_mock.assert_called_once()  # Only 1 call to 'call' before we exit
        log_mock.error.assert_called_with("Rules file %s is empty", RULES_FILE)

        # Test with 'invalid' rules file - raise CalledProcessError when running command
        with patch("insights.client.apps.malware_detection.call") as call_mock:
            call_mock.side_effect = ['yara', CalledProcessError(1, 'cmd', 'invalid'), '2']
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            assert call_mock.call_count == 2  # 2 calls to 'call' before we exit
        log_mock.error.assert_called_with("Unable to use rules file %s: %s", RULES_FILE, "invalid")


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch.dict(os.environ, {'TEST_SCAN': 'false', 'EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS': 'false'})
class TestMalwareDetectionOptions:

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    def test_running_modified_options(self, conf, yara, rules, cmd):
        # Disable test_scan and the mdc attribute values should mostly match what's in the config file
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_file == RULES_FILE
        assert mdc.yara_binary == YARA
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []
        assert mdc.filesystem_scan_since_dict == {'timestamp': None, 'datetime': None}
        assert all([d in mdc.filesystem_scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])
        # filesystem_scan_* attributes will exist whereas processes_scan_* will not
        assert all([hasattr(mdc, 'filesystem_scan_' + attr) is True and hasattr(mdc, 'processes_scan_' + attr) is False
                    for attr in ('exclude_list', 'since_dict')])

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch(LOGGER_TARGET)
    def test_scan_only_options(self, log_mock, conf, yara, rules, cmd):
        # Test various combinations of filesystem_scan_only, process_scan_only, scan_filesystem & scan_processes
        # Firstly, test the default option values
        mdc = MalwareDetectionClient(None)
        assert mdc.do_filesystem_scan is True
        assert mdc.scan_fsobjects == []
        assert mdc.do_process_scan is False
        assert mdc.scan_pids == []

        # Add some directories
        os.environ['FILESYSTEM_SCAN_ONLY'] = '/tmp,/var'
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/tmp', '/var']

        # Disable filesystem scanning and only expect the process to be scanned
        os.environ['SCAN_FILESYSTEM'] = 'false'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Both scan_filesystem and scan_processes are disabled.  Nothing to scan.")

        # Add scan_only for a process
        os.environ['PROCESSES_SCAN_ONLY'] = '1'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Both scan_filesystem and scan_processes are disabled.  Nothing to scan.")

        # Enable process scanning and now the scan_only value should be used
        os.environ['SCAN_PROCESSES'] = 'true'
        mdc = MalwareDetectionClient(None)
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True
        assert mdc.scan_pids == ['1']

    @patch(LOGGER_TARGET)
    @patch.dict(os.environ)
    def test_removed_config_values(self, log_mock, yara, rules, cmd, create_test_files):
        # If the user uses old config items, eg scan_only and scan_exclude, then notify them
        with open(TEMP_CONFIG_FILE, 'a') as f:
            f.write('scan_only: /tmp\nscan_exclude: /home\n')
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_any_call("The 'scan_only' option has been replaced with the 'filesystem_scan_only' and 'processes_scan_only' options in " + TEMP_CONFIG_FILE)
        log_mock.error.assert_called_with("Please remove the %s file and a new config file will be written with the new options", TEMP_CONFIG_FILE)

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "#scan_only: /tmp" if line.startswith("scan_only: ") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_any_call("The 'scan_exclude' option has been replaced with the 'filesystem_scan_exclude' and 'processes_scan_exclude' options in " + TEMP_CONFIG_FILE)

        os.environ['SCAN_ONLY'] = '/tmp'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "#scan_exclude: /home" if line.startswith("scan_exclude: ") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_any_call("The 'scan_only' option has been replaced with the 'filesystem_scan_only' and 'processes_scan_only' options in " + TEMP_CONFIG_FILE)

        del os.environ['SCAN_ONLY']
        os.environ['FILESYSTEM_SCAN_ONLY'] = '/tmp'
        os.environ['SCAN_EXCLUDE'] = '/home'
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_any_call("The 'scan_exclude' option has been replaced with the 'filesystem_scan_exclude' and 'processes_scan_exclude' options in " + TEMP_CONFIG_FILE)

        del os.environ['SCAN_EXCLUDE']
        os.environ['FILESYSTEM_SCAN_EXCLUDE'] = '/home'
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.filesystem_scan_exclude_list == ['/home']

    @patch(LOGGER_TARGET)
    def test_invalid_config_values(self, log_mock, yara, rules, cmd, create_test_files):
        # Check the malware client app behaves in a predictable way if the user specifies invalid option values
        # in the config file.  Some of these will fail yaml parsing, others will fail type checking

        # Invalid value for nice - fails casting to an integer
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: nineteen" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Problem setting configuration option %s: %s", "nice_value", ANY)
        yara.assert_called_once()  # It failed after the _find_yara method

        # Missing colon for nice_value option - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "nice_value 19\n" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, mixing single item and list items - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: 19\n" if line.startswith("nice_value") else line
            line = "filesystem_scan_only: /bad\n- /bad" if line.startswith("filesystem_scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not a list item -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "filesystem_scan_only:" if line.startswith("filesystem_scan_only:") else line
            line = "/bad" if line.startswith("- /bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not enough spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "-/bad" if line.startswith("/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, using tabs instead of spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "\t- /bad" if line.startswith("-/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

    # Patch the os.environ dict so all the changes are only temporary
    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch.dict(os.environ)
    def test_using_env_vars(self, conf, yara, rules, cmd):
        # Set certain option values via environment variables
        env_var_list = [('RULES_LOCATION', RULES_FILE), ('TEST_SCAN', 'hello'),  # will be interpreted as false
                        ('SCAN_FILESYSTEM', 'YES'), ('SCAN_PROCESSES', 'T'),
                        ('FILESYSTEM_SCAN_ONLY', '/tmp'), ('FILESYSTEM_SCAN_EXCLUDE', '/tmp'),
                        ('PROCESSES_SCAN_ONLY', '1,2'), ('PROCESSES_SCAN_EXCLUDE', '2,1'),
                        ('FILESYSTEM_SCAN_SINCE', '2'), ('PROCESSES_SCAN_SINCE', '10'),
                        ('SCAN_TIMEOUT', '1800'), ('CPU_THREAD_LIMIT', '1')]
        for key, value in env_var_list:
            os.environ[key] = value

        mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == YARA
        assert mdc.rules_file == RULES_FILE
        assert mdc.test_scan is False
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.filesystem_scan_exclude_list == ['/tmp']
        assert mdc.scan_pids == ['1', '2']
        assert mdc.processes_scan_exclude_list == ['1', '2']
        assert mdc.filesystem_scan_since_dict['timestamp'] < time.time() - (2 * 86400)
        assert mdc.processes_scan_since_dict['timestamp'] < time.time() - (10 * 86400)
        assert mdc.scan_timeout == 1800
        # Not env vars, but just checking they have the expected values
        assert mdc.nice_value == 19
        assert mdc.cpu_thread_limit == 1

        # Start a filesystem scan and expect scan_only and scan_exclude to cancel each other out
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False

        # Start a process scan and expect scan_only and scan_exclude to cancel each other out
        mdc.scan_processes()
        assert mdc.do_process_scan is False

        # Test when SCAN_ONLY and SCAN_EXCLUDE values are comma separated
        # No items will be scanned because '/' is to be excluded
        for key, value in [('FILESYSTEM_SCAN_ONLY', '/tmp,/,/var/tmp'),
                           ('FILESYSTEM_SCAN_EXCLUDE', '/home,/,/fred,barney')]:
            os.environ[key] = value
        mdc = MalwareDetectionClient(None)
        assert mdc.do_filesystem_scan is True
        assert mdc.scan_fsobjects == ['/tmp', '/', '/var/tmp']
        assert mdc.filesystem_scan_exclude_list == ['/home', '/']
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False

        # Test when FILESYSTEM_SCAN_ONLY is empty, so no items will be scanned because '/' is to be excluded
        os.environ['FILESYSTEM_SCAN_ONLY'] = ''
        mdc = MalwareDetectionClient(None)
        assert mdc.do_filesystem_scan is True
        assert mdc.scan_fsobjects == []
        assert mdc.filesystem_scan_exclude_list == ['/home', '/']
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False

        # Test when FILESYSTEM_SCAN_EXCLUDE is empty
        os.environ['FILESYSTEM_SCAN_EXCLUDE'] = ''
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == []
        assert mdc.filesystem_scan_exclude_list == []

        # Test when FILESYSTEM_SCAN_EXCLUDE is empty
        os.environ['PROCESSES_SCAN_ONLY'] = 'systemd,2,3..10'
        os.environ['PROCESSES_SCAN_EXCLUDE'] = '3..100,systemd,2'
        mdc = MalwareDetectionClient(None)
        assert all([pid in mdc.scan_pids for pid in ['1', '2', '3']])
        assert all([pid in mdc.processes_scan_exclude_list for pid in ['1', '2', '3']])

        # Further testing of list type env vars
        os.environ['NETWORK_FILESYSTEM_TYPES'] = ''
        assert mdc._get_config_option('network_filesystem_types') == []
        os.environ['NETWORK_FILESYSTEM_TYPES'] = 'nfs'
        assert mdc._get_config_option('network_filesystem_types') == ['nfs']
        os.environ['NETWORK_FILESYSTEM_TYPES'] = 'nfs,nfs4'
        assert mdc._get_config_option('network_filesystem_types') == ['nfs', 'nfs4']

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch(LOGGER_TARGET)
    @patch.dict(os.environ, {'TEST_SCAN': 'false', 'NICE_VALUE': 'nineteen', 'FILESYSTEM_SCAN_SINCE': 'blast'})
    def test_invalid_env_vars(self, log_mock, conf, yara, rules, cmd):
        # NICE_VALUE and FILESYSTEM_SCAN_SINCE have invalid values
        # First time through the NICE_VALUE should generate an error
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Problem parsing environment variable %s: %s", "NICE_VALUE", ANY)

        # Set NICE_VALUE to proper value to avoid it giving an error this time.
        # Only FILESYSTEM_SCAN_SINCE should generate an error
        os.environ['NICE_VALUE'] = '19'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Unknown value '%s' for %s option.  "
                                          "Valid values are integers >= 1 and 'last'", "blast", "filesystem_scan_since")

        # Fix FILESYSTEM_SCAN_SINCE to proper value to avoid it giving an error this time.
        # Give an invalid value for PROCESSES_SCAN_SINCE, but need to enable SCAN_PROCESSES too
        os.environ['FILESYSTEM_SCAN_SINCE'] = 'last'
        os.environ['SCAN_PROCESSES'] = 'true'
        os.environ['PROCESSES_SCAN_SINCE'] = '0'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        log_mock.error.assert_called_with("Invalid processes_scan_since value 0.  Valid values are integers >= 1 and 'last'")

        # Disable SCAN_PROCESSES and the invalid PROCESSES_SCAN_SINCE doesn't raise an error anymore
        # because it isn't even parsed
        os.environ['SCAN_PROCESSES'] = 'false'
        mdc = MalwareDetectionClient(None)
        assert hasattr(mdc, 'processes_scan_since_dict') is False

    def test_filesystem_scan_only_root(self, yara, rules, cmd, create_test_files):
        # Nothing special about root when parsing the filesystem_scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        filesystem_scan_only = '/'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "filesystem_scan_only: %s" % filesystem_scan_only if line.startswith("filesystem_scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == [filesystem_scan_only]
        # This is called by scan_filesystem to convert '/' into its top level subdirectories
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

        # Multiple directories aren't consolidated until later
        filesystem_scan_only = ['/', '/tmp', '/home']
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "filesystem_scan_only: %s" % filesystem_scan_only if line.startswith("filesystem_scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == filesystem_scan_only
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

    @patch(LOGGER_TARGET)
    def test_filesystem_scan_exclude_root(self, log_mock, yara, rules, cmd, create_test_files):
        # Nothing special about root when parsing the filesystem_scan_exclude option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # Add '/' to the list of filesystem_scan_exclude items.  Add it directly after the filesystem_scan_exclude: line
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /" if line.startswith("filesystem_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert '/' in mdc.filesystem_scan_exclude_list
        # When scan_filesystem is run, '/' will be expanded into toplevel directories that cancel out everything
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert scan_dict == {}
        log_mock.error.assert_called_with("No filesystem items to scan because the specified exclude items cancel them out")

    @patch(LOGGER_TARGET)
    def test_filesystem_scan_only_exclude_nullify(self, log_mock, yara, rules, cmd, create_test_files):
        # Testing filesystem scan_only and scan_exclude items such that the exclude items nullify the scan_only items
        # In which case there will be nothing to scan
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /var/log\n- /usr/lib/systemd\n- /tmp" if line.startswith("filesystem_scan_only:") else line
            line = line + "\n- /tmp/\n- /usr/lib/\n- /var/log" if line.startswith("filesystem_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.filesystem_scan_exclude_list for x in ['/tmp', '/usr/lib', '/var/log']])
        # The exclude list covers all the items to be scanned, thus there is nothing to scan
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False
        log_mock.error.assert_called_with("No filesystem items to scan because the specified exclude items cancel them out")

        # Both filesystem scan_only and scan_exclude contain root
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- /" if line.startswith("filesystem_scan_only:") else line
            line = line + "\n- /" if line.startswith("filesystem_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/', '/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.filesystem_scan_exclude_list for x in ['/', '/tmp', '/usr/lib', '/var/log']])
        # Because both lists contain /, they will cancel each other out and there is nothing to scan
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False
        log_mock.error.assert_called_with("No filesystem items to scan because the specified exclude items cancel them out")

    @patch("insights.client.apps.malware_detection.call")
    @patch(LOGGER_TARGET)
    def test_network_filesystem_mountpoints(self, log_mock, call_mock, yara, rules, cmd, extract_tmp_files, create_test_files):
        # Test the exclude_network_filesystem_mountpoints option by 'creating' various mountpoints to exclude
        os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS'] = 'true'  # Override the default setting for this test class
        scan_me_scan_me = os.path.join(TEMP_TEST_DIR, 'scan_me/scan_me')
        scan_me_too = os.path.join(TEMP_TEST_DIR, 'scan_me_too')
        scan_me_not_mnt = os.path.join(TEMP_TEST_DIR, 'scan_me_not')
        dont_scan_me_mnt = os.path.join(TEMP_TEST_DIR, 'scan_me/dont_scan_me')

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE if line.startswith('---') else line
            line = "filesystem_scan_only: %s" % TEMP_TEST_DIR if line.startswith("filesystem_scan_only:") else line
            print(line)

        # This is the mocked output returned from the findmnt command
        call_mock.return_value = '%s\n%s\n' % (scan_me_not_mnt, dont_scan_me_mnt)

        # Setting exclude_network_filesystem_mountpoints to false means we don't care about excluding mountpoints
        os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS'] = 'false'
        os.environ['NETWORK_FILESYSTEM_TYPES'] = ''
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.network_filesystem_mountpoints == []

        # Removing the env var (it'll be true from the config file) but still not having any
        # network_filesystem_types value will generate an error
        del os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS']
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_called_with("No value specified for 'network_filesystem_types' option")

        # Ok, now with exclude mountpoints true and a value for types we will produce a list of mountpoints
        os.environ['NETWORK_FILESYSTEM_TYPES'] = 'nfs'
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.network_filesystem_mountpoints == [scan_me_not_mnt, dont_scan_me_mnt]

        # Now we can process all the include and exclude items to build the scan_dict of things to scan
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list,
                                                  exclude_mountpoints=mdc.network_filesystem_mountpoints)

        # The exclude_mountpoints will be added to the list of items to exclude
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted([scan_me_not_mnt, dont_scan_me_mnt])
        assert all([x in scan_dict['/tmp']['include'] for x in [scan_me_scan_me, scan_me_too]])
        # scan_me dir won't be in the list of include items because it has a sub-item to be excluded
        assert os.path.join(TEMP_TEST_DIR, 'scan_me') not in scan_dict['/tmp']['include']

        # Now make TEMP_TEST_DIR a mountpoint and it will cancel out TEMP_TEST_DIR for scan_only
        call_mock.return_value = '%s\n' % TEMP_TEST_DIR
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.network_filesystem_mountpoints == [TEMP_TEST_DIR]
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list,
                                                  exclude_mountpoints=mdc.network_filesystem_mountpoints)
        assert scan_dict == {}
        log_mock.error.assert_called_with("No filesystem items to scan because the specified exclude items cancel them out")

    def test_processes_scan_options(self, yara, rules, cmd, create_test_files):
        # Test the processes scan options
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_filesystem: false" if line.startswith("scan_filesystem:") else line
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            line = "processes_scan_only: 1\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: 1\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_pids == ['1']
        assert mdc.processes_scan_exclude_list == ['1']

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only: 1..10\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: 1..10\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert all([pid in mdc.scan_pids for pid in ['1', '2']])
        assert len(mdc.processes_scan_exclude_list) > 1
        assert all([pid in mdc.processes_scan_exclude_list for pid in ['1', '2']])

        # Test an open ended range, but really just saves typing '1' - scan all processes from 1 to 10
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only: ..10\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: ..10\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert all([int(pid) <= 10 for pid in mdc.scan_pids])
        assert len(mdc.processes_scan_exclude_list) > 1
        assert all([int(pid) <= 10 for pid in mdc.processes_scan_exclude_list])

        # Testing an open ended range - scan all processes from 101 to the max_pid value
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only: 101..\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: 101..\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert all([int(pid) > 100 for pid in mdc.scan_pids])
        assert len(mdc.processes_scan_exclude_list) > 1
        assert all([int(pid) > 100 for pid in mdc.processes_scan_exclude_list])

        # Not invalid ranges, just testing them to confirm they are handled gracefully
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only: 1...10\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: .1.....10.\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert all([int(pid) <= 10 for pid in mdc.scan_pids])
        assert len(mdc.processes_scan_exclude_list) > 1
        assert all([int(pid) <= 10 for pid in mdc.processes_scan_exclude_list])

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only: systemd\n" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude: systemd\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert '1' in mdc.scan_pids
        assert len(mdc.processes_scan_exclude_list) > 1
        assert '1' in mdc.processes_scan_exclude_list

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_only:\n- 2\n- 3..10\n- systemd" if line.startswith("processes_scan_only:") else line
            line = "processes_scan_exclude:\n- systemd\n- 2\n- 3..10" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert len(mdc.scan_pids) > 1
        assert all([pid in mdc.scan_pids for pid in ['1', '2', '3']])
        assert len(mdc.processes_scan_exclude_list) > 1
        assert all([pid in mdc.processes_scan_exclude_list for pid in ['1', '2', '3']])

    @patch(LOGGER_TARGET)
    def test_processes_scan_options_invalid_or_missing_values(self, log_mock, yara, rules, cmd, create_test_files):
        # Test the processes scan options
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_filesystem: false" if line.startswith("scan_filesystem:") else line
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            line = line + "\n- pid2\n- three..10\n- 20.50\n- notsystemd" if line.startswith("processes_scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        log_mock.error.assert_any_call("Unable to parse '%s' in to a range of PIDs: %s", 'three..10', ANY)
        log_mock.error.assert_any_call("Unable to find the items specified for the processes_scan_only option.  Skipping ...")
        log_mock.error.assert_any_call("Nothing to scan with processes_scan_only option and scan_filesystem is disabled")

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- 1" if line.startswith("processes_scan_only:") else line
            line = line + "\n- -1\n- 3..ten\n- 123 systemd" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_pids == ['1']
        assert mdc.processes_scan_exclude_list == []
        log_mock.error.assert_any_call("Unable to parse '%s' in to a range of PIDs: %s", '3..ten', ANY)
        log_mock.error.assert_any_call("Unable to find the items specified for the processes_scan_exclude option.  Skipping ...")


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=TEST_RULE_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOGGER_TARGET)
@patch.dict(os.environ)
class TestProcessScanning:

    def test_scan_processes(self, log_mock, yara, rules, cmd, create_test_files):
        # Test scanning processes to test which processes are going to be scanned
        os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS'] = 'false'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True
        assert mdc.scan_pids == []
        assert mdc.processes_scan_exclude_list == []

        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch("insights.client.apps.malware_detection.call", return_value=""):
            mdc.scan_processes()
        assert mdc.processes_scan_exclude_list == [TEST_PID]
        assert len(mdc.scan_pids) > 1
        assert '1' in mdc.scan_pids
        assert TEST_PID not in mdc.scan_pids

        # Exclude some processes via the config file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_exclude: 1\n" if line.startswith("processes_scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.processes_scan_exclude_list == ['1']
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch("insights.client.apps.malware_detection.call", return_value=""):
            mdc.scan_processes()
        assert mdc.processes_scan_exclude_list == ['1', TEST_PID]
        assert len(mdc.scan_pids) > 1
        assert all([x not in mdc.scan_pids for x in ['1', TEST_PID]])

        # Exclude some processes via env vars
        os.environ['PROCESSES_SCAN_EXCLUDE'] = 'systemd,3..10'
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert all([pid in mdc.processes_scan_exclude_list for pid in ['1', '3']])
        assert '2' not in mdc.processes_scan_exclude_list
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch("insights.client.apps.malware_detection.call", return_value=""):
            mdc.scan_processes()
        assert all([pid in mdc.processes_scan_exclude_list for pid in ['1', '3', TEST_PID]])
        assert len(mdc.scan_pids) > 1
        assert all([x not in mdc.scan_pids for x in ['1', '3', TEST_PID]])
        assert '2' in mdc.scan_pids

    @pytest.mark.skipif(not TEST_PROCESSES_SCAN_SINCE, reason='test_processes_scan_since is slowish and could potentially fail')
    def test_processes_scan_since(self, log_mock, yara, rules, cmd, create_test_files):
        # Firstly, start the TEST_RULE_SCRIPT process then scan_only that process
        # Expect that we'll find it
        os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
        ps_call_output = call([['ps', '-eo', 'pid=', '-o', 'lstart=']])
        os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS'] = 'false'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_filesystem: false" if line.startswith("scan_filesystem:") else line
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            line = "processes_scan_only: test-rule" if line.startswith("processes_scan_only:") else line
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True
        # Match TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_pids) == 1

        # Now find processes started since the last scan, specifically the TEST_RULE_SCRIPT process
        # However expect to not find it because it wasn't started since the last_scan date
        last_scan = time.time()
        last_scan_fmt = datetime.fromtimestamp(last_scan).strftime('%Y-%m-%d %H:%M:%S')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_since: last" if line.startswith("processes_scan_since:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient(None)
        assert mdc.processes_scan_since_dict['timestamp'] == last_scan
        assert mdc.processes_scan_since_dict['datetime'] == last_scan_fmt
        # Still match the TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_pids) == 1
        # But when we run scan_processes() it won't be found because it wasn't started since the last scan
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch("insights.client.apps.malware_detection.call", return_value=ps_call_output):
            mdc.scan_processes()
        assert len(mdc.scan_pids) == 0
        log_mock.error.assert_called_with("No processes to scan because none were started since %s", last_scan_fmt)

        # Now find processes started since one day ago, specifically the TEST_RULE_SCRIPT process
        # Expect to find it this time it was started since a day ago
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "processes_scan_since: 1" if line.startswith("processes_scan_since:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        # Still match the TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_pids) == 1
        with patch("insights.client.apps.malware_detection.call") as call_mock:
            # Patch calls to 'call' within the scan_processes function
            # The first call is to ps to get the process list, which is what we want
            # The second call is to yara, which we want to ignore since yara may not be installed
            call_mock.side_effect = [ps_call_output, ""]
            mdc.scan_processes()
        # Expect to find the TEST_RULE_SCRIPT process because it was started since a day ago
        assert len(mdc.scan_pids) == 1

        # Start another process and this time there will be a TEST_RULE_SCRIPT process started since last_scan date
        time.sleep(2)  # Wait a second to ensure the last_scan time is greater than the process start time
        os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
        ps_call_output = call([['ps', '-eo', 'pid=', '-o', 'lstart=']])
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient(None)
        # Match 2 TEST_RULE_SCRIPT processes from processes_scan_only
        assert len(mdc.scan_pids) == 2
        # But when we run scan_processes() only the latest one will be found
        with patch("insights.client.apps.malware_detection.call") as call_mock:
            call_mock.side_effect = [ps_call_output, ""]
            mdc.scan_processes()
        # Only find the latest TEST_RULE_SCRIPT process
        assert len(mdc.scan_pids) == 1


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch('os.remove')  # Mock os.remove so it doesn't actually try to remove any existing files
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOGGER_TARGET)
class TestFilesystemScanning:

    def test_scan_rules_file_with_extra_slashes(self, log_mock, yara, cmd, remove, create_test_files):
        # Test scanning RULES_FILE with an extra slash only in the rules_location one
        # Even with the extra slashes in the rules_location there will be rules matched
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE.replace('/', '//') if line.startswith('---') else line
            line = "filesystem_scan_only: %s" % TEST_RULE_FILE if line.startswith("filesystem_scan_only:") else line
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            line = "exclude_network_filesystem_mountpoints: false" if line.startswith("exclude_network_filesystem_mountpoints:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == TEST_RULE_FILE.replace('/', '//')
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.scan_fsobjects == [TEST_RULE_FILE]
        with patch("insights.client.apps.malware_detection.call") as call_mock:
            # Mock the scan match data from yara
            call_mock.return_value = "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client" % TEST_RULE_FILE
            mdc.scan_filesystem()
        rule_match = mdc.host_scan['TEST_RedHatInsightsMalwareDetection']
        assert rule_match[0]['source'] == TEST_RULE_FILE
        assert rule_match[0]['string_data'] == "Malware Detection Client"
        assert rule_match[0]['string_identifier'] == '$re1'
        assert rule_match[0]['string_offset'] == 74
        log_mock.info.assert_any_call("Matched rule %s in %s %s", "TEST_RedHatInsightsMalwareDetection", "file", TEST_RULE_FILE)

    def test_scan_root_with_extra_slashes(self, log_mock, yara, cmd, remove, create_test_files):
        # Testing we handle the situation where items in filesystem_scan_only & scan_exclude contain multiple slashes
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE if line.startswith('---') else line
            line = line + "- //\n" if line.startswith("filesystem_scan_only:") else line
            line = line + "- //\n" if line.startswith("filesystem_scan_exclude:") else line
            line = "exclude_network_filesystem_mountpoints: false" if line.startswith("exclude_network_filesystem_mountpoints:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/']
        assert '/' in mdc.filesystem_scan_exclude_list
        # Chaos monkey - modify scan_fsobjects and filesystem_scan_exclude_list AFTER they have been verified
        # Assert that they still work and cancel each other out
        mdc.scan_fsobjects = ['//']
        mdc.filesystem_scan_exclude_list = ['//']
        mdc.scan_filesystem()
        assert mdc.do_filesystem_scan is False
        log_mock.error.assert_called_with("No filesystem items to scan because the specified exclude items cancel them out")

    @patch('insights.client.apps.malware_detection.NamedTemporaryFile')
    @patch("insights.client.apps.malware_detection.call", return_value="")
    def test_filesystem_scan_since_tmp_files(self, call_mock, tmp_file_mock, log_mock, yara, cmd, remove, extract_tmp_files, create_test_files):
        # Set filesystem_scan_only, filesystem_scan_exclude options to some of the tmp files and then 'scan' them
        # Then touch files to test the filesystem_scan_since option and make sure that only the touched files will be scanned
        yara_file_list = os.path.join(TEMP_TEST_DIR, 'yara_file_list')
        scan_me_file = os.path.join(TEMP_TEST_DIR, 'scan_me/scan_me_file')
        scan_me_too_file = os.path.join(TEMP_TEST_DIR, 'scan_me_too/scan_me_too_file')
        filesystem_scan_only = tuple(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me', 'scan_me_too']))
        filesystem_scan_exclude = tuple(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                            ['scan_me_not', 'scan_me/dont_scan_me', 'scan_me_too/dont_scan_me_too']))

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE if line.startswith('---') else line
            line = line + '- %s\n- %s' % filesystem_scan_only if line.startswith("filesystem_scan_only:") else line
            line = line + "- %s\n- %s\n- %s" % filesystem_scan_exclude if line.startswith("filesystem_scan_exclude:") else line
            line = "exclude_network_filesystem_mountpoints: false" if line.startswith("exclude_network_filesystem_mountpoints:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        # Ensure the correct scan include and exclude values are set
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted(filesystem_scan_exclude)

        # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
        # Also mock out the call to yara but we don't return anything since we aren't testing it
        with open(yara_file_list, 'w') as f:
            tmp_file_mock.return_value = f
            mdc.scan_filesystem()
        with open(yara_file_list, 'r') as f:
            contents = f.read().splitlines()
        # Ensure that a number of files are in the list of files passed to yara to scan
        assert len(contents) > 2
        assert all([x in contents for x in [scan_me_file, scan_me_too_file]])

        # With the same filesystem scan_only and scan_exclude values, add filesystem_scan_since: last into the mix and set
        # the last scan time to now.  There should be no matches because no files have been modified since now
        last_scan = time.time()
        last_scan_fmt = datetime.fromtimestamp(last_scan).strftime('%Y-%m-%d %H:%M:%S')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "filesystem_scan_since: last" if line.startswith("filesystem_scan_since:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient(None)
        assert mdc.filesystem_scan_since_dict['timestamp'] == last_scan
        assert mdc.filesystem_scan_since_dict['datetime'] == last_scan_fmt
        log_mock.info.assert_called_with("Scan for files created/modified since %s%s", ANY, ANY)

        # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
        # Also mock out the call to yara, but we don't return anything since we aren't testing it
        with open(yara_file_list, 'w') as f:
            tmp_file_mock.return_value = f
            mdc.scan_filesystem()
        with open(yara_file_list, 'r') as f:
            contents = f.read().splitlines()
        # Ensure no files were passed to yara to scan because none were modified since 'last_scan'
        assert not contents

        # Try again, keeping the same last_scan time, but this time touch 2 files
        # Confirm that only these 2 files appear in the list of files to be passed to yara
        os.system('touch %s %s' % (scan_me_file, scan_me_too_file))
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient(None)

        with open(yara_file_list, 'w') as f:
            tmp_file_mock.return_value = f
            mdc.scan_filesystem()
        with open(yara_file_list, 'r') as f:
            contents = f.read().splitlines()
        # Ensure the scan_me_file was passed to yara to scan because it was 'modified' since 'last_scan'
        assert len(contents) == 2
        assert contents == [scan_me_file, scan_me_too_file]

        # Touch some files that are excluded from scanning so even though they have been modified, they won't be
        # in the list of files to scan that is passed to yara
        os.system('touch %s %s %s' % (os.path.join(TEMP_TEST_DIR, 'scan_me/dont_scan_me/matching_entity'),
                                      os.path.join(TEMP_TEST_DIR, 'scan_me_not/matching_entity'),
                                      os.path.join(TEMP_TEST_DIR, "scan_me_too/dont_scan_me_too/'another matching_entity'")))
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient(None)

        with open(yara_file_list, 'w') as f:
            tmp_file_mock.return_value = f
            mdc.scan_filesystem()
        with open(yara_file_list, 'r') as f:
            contents = f.read().splitlines()
        # Ensure both scan_me_file and scan_me_too_file were passed to yara because both were modified since last_scan
        assert len(contents) == 2
        assert contents == [scan_me_file, scan_me_too_file]

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch.dict(os.environ)
    def test_rule_n_glob_files_excluded(self, conf, log_mock, yara, cmd, remove, extract_tmp_files, create_test_files):
        # Fake a scan but make sure we are excluding the rules file and globbed files (they are supposed to be
        # insights log files, but that's hard to mock).
        # Also test we are not excluding ones we actually want to scan
        glob_files = [os.path.join(TEMP_TEST_DIR, 'scan_me', f) for f in ['new_file', 'old_file']]
        os.environ['TEST_SCAN'] = 'false'
        os.environ['EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS'] = 'false'
        os.environ['RULES_LOCATION'] = TEST_RULE_FILE
        os.environ['FILESYSTEM_SCAN_ONLY'] = "%s,%s" % (TEMP_TEST_DIR, glob_files[1])  # we actually want to scan glob_files[1]
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.scan_fsobjects == [TEMP_TEST_DIR, glob_files[1]]

        # Patch the call to glob so it returns a specific list of files
        # Patch the calls for running yara and have it return no matches
        with patch("insights.client.apps.malware_detection.glob", return_value=glob_files):
            with patch("insights.client.apps.malware_detection.call", return_value=""):
                mdc.scan_filesystem()
        assert mdc.rules_file in mdc.filesystem_scan_exclude_list
        assert glob_files[0] in mdc.filesystem_scan_exclude_list
        # Make sure glob_files[1] isn't excluded because we actually want to scan that file
        assert glob_files[1] not in mdc.filesystem_scan_exclude_list

        # This time patch glob so it returns an empty list, ie simulating no extra files to exclude
        mdc = MalwareDetectionClient(None)
        with patch("insights.client.apps.malware_detection.glob", return_value=[]):
            with patch("insights.client.apps.malware_detection.call", return_value=""):
                mdc.scan_filesystem()
        assert mdc.rules_file in mdc.filesystem_scan_exclude_list
        # None of the glob files should be excluded this time
        assert all([f not in mdc.filesystem_scan_exclude_list for f in glob_files])


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
class TestFilesystemIncludeExcludeMethods:

    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list)
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/usr/lib')
        assert sorted(parent_dir_list) == ['/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/var')
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = ['/path/to/some/item/child', '/path/to/another/item', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = ['/var/lib64', '/home/bob', '/var/lib/docker', '/home/bob', '/var/lib',
                 '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child', '/var/lib63/im ok', '/var/lib64/im not']
        assert remove_child_items(items) == ['/home/bob', '/home/bobby-droptables', '/var/lib',
                                             '/var/lib63/im ok', '/var/lib64']

        # /path is common to both so that will be all that is returned
        items = ['/path/to/another/item', '/path/to/some/item', '/path']
        assert remove_child_items(items) == ['/path']

        # The root directory will always win
        items = ['/path/to/another/item', '/path/to/some/item', '/']
        assert remove_child_items(items) == ['/']

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ['/path/to/another/item', '', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

    def test_remove_included_excluded_items(self):
        include_items = ['/home/bob', '/tmp', '/var/www/html']
        exclude_items = ['/home/bo', '/home/bob/exclude', '/home/bobby', '/temp', '/var/www']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/home/bob', '/tmp']

        # Some fairly random lists similar to before
        include_items = ['/var/lib64/docker', r'/home/bob/this\ is\ bobs/child', '/var/lib/docker', '/home/bob',
                         '/var/lib', '/usr']
        exclude_items = ['/var/lib/docker2', '/home/bob', '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child',
                         '/var/lib63/im ok', '/var/lib64/im not', '/boot']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/usr', '/var/lib', '/var/lib64/docker']

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    def test_process_include_items(self):
        # Call process_include_items with variously populated lists
        # Add some valid entries to include_items list, esp subdirectories
        include_items = ['/etc/pam.d', '/tmp', '/var/log/']
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/pam.d', '/tmp', '/var/log']

        # Add some more subdirectories
        include_items.extend(['/etc/alternatives', '/tmp', '/var/lib/'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/alternatives', '/etc/pam.d', '/tmp', '/var/lib', '/var/log']

        # Add some top level directories to override the subdirectories
        include_items.extend(['/etc', '/var'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries that will get ignored
        include_items.extend(['..', '/var/run', '/missing'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory (/) which will override all the other entries
        include_items.append('/')
        processed_items = process_include_items(include_items)
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    def test_process_exclude_items(self):
        # Call process_exclude_items with variously populated lists
        # No entries to exclude
        processed_items = process_exclude_items()
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ['/etc/ssh', '/tmp', '/var/run/']
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/ssh', '/tmp', '/var/run']

        # Add some more subdirectories
        exclude_items.extend(['/etc/alternatives', '/tmp', '/var/lock/'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/alternatives', '/etc/ssh', '/tmp', '/var/lock', '/var/run']

        # Add some top level directories to override the subdirectories
        exclude_items.extend(['/etc', '/var'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries to exclude items, which will be ignored
        exclude_items.extend(['..', '/missing'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory, which will expand to all top level directories
        exclude_items.append('/')
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == get_toplevel_dirs()


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(FINDMNT_TARGET)
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {'TEST_SCAN': 'false'})
class TestFilesystemIncludeExcludeProcessing:

    def test_process_include_exclude_items_simple(self, conf, yara, rules, cmd, findmnt):
        # Test the process_include_exclude_items function with simple modified include and exclude items
        # Simple in that the include and exclude files are modified in such a way that
        # directory listings aren't required get the list of included files
        # Add a single toplevel directory to the include file - expect only a single directory to scan
        mdc = MalwareDetectionClient(None)
        mdc.scan_fsobjects = ['/etc']
        mdc.filesystem_scan_exclude_list = []
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']
        assert 'include' not in scan_dict['/etc']
        assert 'exclude' not in scan_dict['/etc']

        # Add some extra subdirectories to scan
        mdc.scan_fsobjects.extend(['/var/lib', '/var/log'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(list(scan_dict['/var']['include'])) == ['/var/lib', '/var/log']
        assert 'exclude' not in scan_dict['/var']

        # Add some extra directories to exclude that won't impact the already included directories
        mdc.filesystem_scan_exclude_list.extend(['/tmp', '/var/run'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(scan_dict['/var']['include']) == ['/var/lib', '/var/log']
        assert scan_dict['/var']['exclude']['items'] == ['/var/run']

        # Exclude /var which will remove it from the list of directories to scan
        mdc.filesystem_scan_exclude_list.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']

        # Exclude /etc which means there will be no directories to scan
        mdc.filesystem_scan_exclude_list.append('/etc')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert scan_dict == {}

    def test_process_include_exclude_items_complex(self, conf, yara, rules, cmd, findmnt):
        # Test the process function with modified include and exclude files that will require more complex
        # processing to generate the list of items to be scanned
        # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
        # We don't need to list the contents of the /var directory
        mdc = MalwareDetectionClient(None)
        mdc.scan_fsobjects = ['/var/lib', '/var/log']
        mdc.filesystem_scan_exclude_list = ['/var/lib/systemd', '/var/lib/misc/', '/var/log/wtmp']

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        # The exclude items shouldn't be in the include items
        # Nor should other items that aren't in the explicitly included items
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp',
                              '/var/cache', '/var/lib', '/var/log', '/var/tmp', '/tmp']])
        # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
        # but not the excluded items, eg /var/log/wtmp
        assert all([x in scan_dict['/var']['include'] for x in ['/var/lib/dbus', '/var/log/lastlog']])

        # Change the include directory to /var
        # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
        # Because now we have to list the contents of the /var and /var/lib directories
        mdc.scan_fsobjects.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.filesystem_scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp', '/var/lib', '/var/log', '/tmp']])
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/cache', '/var/tmp', '/var/lib/dbus', '/var/log/lastlog']])

    def test_process_include_exclude_tmp_files(self, conf, yara, rules, cmd, findmnt, extract_tmp_files):
        # Test the including/excluding some of the files in the tmp archive
        # Specifically tests excluding link files (good or broken) and pipe files (as well as explicit exclude items)

        include_items = list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me', 'scan_me_too']))
        exclude_items = list(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                 ['scan_me_not', 'scan_me/dont_scan_me', 'scan_me_too/dont_scan_me_too']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted(exclude_items)

        include_files = sorted(list(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                        ['scan_me/new_file', 'scan_me/old_file', 'scan_me/scan_me',
                                         'scan_me/scan_me_file', 'scan_me_too/new_file', 'scan_me_too/old_file',
                                         'scan_me_too/scan_me_too', 'scan_me_too/scan_me_too_file'])))
        dont_include_files = sorted(list(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                             ['scan_me/link_file', 'scan_me/pipe_file', 'scan_me/broken_link',
                                              'scan_me/dont_scan_me', 'scan_me_too/link_file', 'scan_me_too/pipe_file',
                                              'scan_me_too/broken_link', 'scan_me_too/dont_scan_me_too'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])

        # Another test to assert a bug I found is fixed ... due to only having scan_items = set([])
        # Basically include_files should = ['scan_me/scan_me'] but the bug made include_files = []
        include_items = list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me/scan_me']))
        exclude_items = list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me_not']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)

        include_files = sorted(list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me/scan_me'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        dont_include_files = sorted(list(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                             ['scan_me/scan_me_file', 'scan_me/dont_scan_me', 'scan_me/scan_me/here_i_am'])))
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])


@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
@patch(FINDMNT_TARGET)
@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {'TEST_SCAN': 'false'})
class TestParseScanOutput:

    def test_contrived_scan_output(self, conf, yara, rules, cmd, findmnt):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
        mdc = MalwareDetectionClient(None)
        mdc.add_metadata = False
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        assert mdc.matches == 8

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        assert len(rule_match) == 1
        assert 'e-r-r-o-r s-c-a-n-n-i-n-g' in rule_match[0]['source']
        assert rule_match[0]['string_data'] == "matches 'this' rule"
        assert rule_match[0]['string_identifier'] == '$match'
        assert rule_match[0]['string_offset'] == 291

        # 14 matching strings for 'Rule'
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 14
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == 'string match in the file "matching_entity"'
        assert rule_match[0]['string_identifier'] == '$match0'
        assert rule_match[0]['string_offset'] == 21
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "another string match in matching_entity"
        assert rule_match[1]['string_identifier'] == '$match1'
        assert rule_match[1]['string_offset'] == 83
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == 'string with different types of quotes \'here\' and "here"'
        assert rule_match[2]['string_identifier'] == '$match2'
        assert rule_match[2]['string_offset'] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[3]['string_identifier'] == '$match3'
        assert rule_match[3]['string_offset'] == 2
        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains ="
        assert rule_match[4]['string_identifier'] == '$grep1'
        assert rule_match[4]['string_offset'] == 97
        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == "contains .+"
        assert rule_match[6]['string_identifier'] == '$grep2'
        assert rule_match[6]['string_offset'] == 153
        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_data'] == 'contains "'
        assert rule_match[8]['string_identifier'] == '$grep3'
        assert rule_match[8]['string_offset'] == 213
        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_data'] == "contains '"
        assert rule_match[9]['string_identifier'] == '$grep4'
        assert rule_match[9]['string_offset'] == 241
        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_data'] == 'contains ()[]'
        assert rule_match[10]['string_identifier'] == '$grep5'
        assert rule_match[10]['string_offset'] == 269
        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_data'] == 'contains {'
        assert rule_match[11]['string_identifier'] == '$grep6'
        assert rule_match[11]['string_offset'] == 299
        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_data'] == 'contains ^$'
        assert rule_match[12]['string_identifier'] == '$grep7'
        assert rule_match[12]['string_offset'] == 327

        assert rule_match[13]['source'].startswith('matching_entity_3')
        assert rule_match[13]['string_data'] == ''
        assert rule_match[13]['string_identifier'] == ''
        assert rule_match[13]['string_offset'] == -1

        # 4 matching strings for 'another_matching_rule'
        rule_match = mdc.host_scan['another_matching_rule']
        assert len(rule_match) == 4
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        assert rule_match[2]['string_data'] == '#!/bin/sh'
        assert rule_match[2]['string_identifier'] == '$s0'
        assert rule_match[2]['string_offset'] == 60783814
        assert rule_match[3]['source'] == '1234567'
        assert rule_match[3]['string_data'] == '#!/bin/sh'
        assert rule_match[3]['string_identifier'] == '$s0'
        assert rule_match[3]['string_offset'] == 0

        rule_match = mdc.host_scan['Iyamtho']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == " yep"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        rule_match = mdc.host_scan['n_m3_t00']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == "damn   straight"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

    def test_contrived_scan_output_metadata(self, conf, yara, rules, cmd, findmnt, create_test_files):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_file_location with any rule, but its not relevant for the tests
        mdc = MalwareDetectionClient(None)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # Matches and metadata for MATCHING_ENTITY_FILE
        rule_match = mdc.host_scan['Rule']
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_offset'] == 21
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 1
        assert metadata['line'] == urlencode('This line contains a string match in the file "matching_entity"')

        # Testing displaying long lines
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_offset'] == 83
        metadata = rule_match[1]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 2
        assert metadata['line'] == urlencode('This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o...')

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_offset'] == 230
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode("""And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough""")

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_offset'] == 2
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_offset'] == 97
        metadata = rule_match[4]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_offset'] == 123
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 8
        assert metadata['line'] == urlencode("This line contains = char too")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_offset'] == 153
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_offset'] == 213
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_offset'] == 241
        metadata = rule_match[9]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_offset'] == 269
        metadata = rule_match[10]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_offset'] == 299
        metadata = rule_match[11]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_offset'] == 327
        metadata = rule_match[12]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert rule_match[13]['source'] == "matching_entity_3, but without any string matches - yes that's ok"
        metadata = rule_match[13]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.host_scan['another_matching_rule']
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]['source'] == '1234567'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert all([key not in ['process_name', 'file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_random_output(self, conf, yara, rules, cmd, findmnt):
        mdc = MalwareDetectionClient(None)
        mdc.parse_scan_output(RANDOM_OUTPUT)
        assert mdc.matches == 2
        rule_match = mdc.host_scan['Lorem']
        assert rule_match[0]['source'].startswith('ipsum dolor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1
        rule_match = mdc.host_scan['Dictum']
        assert rule_match[0]['source'].startswith('at tempor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1


MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, 'matching_entity')
MATCHING_ENTITY_FILE_CONTENTS = """
This line contains a string match in the file "matching_entity"
This line contains another string match in matching_entity and it is very long for testing the ellipses that are added onto very long lines

And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough
""".lstrip()

ANOTHER_MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, 'another matching_entity')
ANOTHER_MATCHING_ENTITY_FILE_CONTENTS = """


string match containing error scanning but it's ok because its not in a rule line



This line contains = char
This line contains = char too
This line contains .+ chars
This line contains .+ chars too
This line contains "" chars
This line contains '' chars
This line contains ()[] chars
This line contains {} chars
This line contains ^$ chars
This line contains ^$ chars too
The previous line and this one too are ignored as they are beyond the default 10 string match limit
"""[1:]  # Ignore first newline char otherwise it changes the md5sum

TEST_RULE_FILE_CONTENTS = """
rule TEST_RedHatInsightsMalwareDetection
// Verifies the Red Hat Insights Malware Detection Client app is present on the system
{
    strings:
        $re1 = /Malware ?Detection ?Client/
    condition:
        $re1
}
""".lstrip()

TEST_RULE_SCRIPT_CONTENTS = """
#!/bin/sh
# As a process this will match the TEST_RedHatInsightsMalwareDetection rule
echo "Malware Detection Client"
sleep 3
""".lstrip()

CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
""" % (MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE)

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""

# Base64 representation of a tgz file containing simple files to be extracted into /tmp to be used for scanning
# It is decoded and unzipped in the extract_tmp_files fixture
SCAN_FILES_BASE64 = """
H4sIAD+feGEAA+1a247TMBDtc79iVCEVhARxrk888A+8IajSxt1Ym8YlcXZVIf6dcbZG2WzTkm5t
ijpnH3KxHbt7PPaZGdertFxs+MeJRXiIJIn0lSWR170aTFjIgpixJAyCicdY5IcTiGwOyqCpVVoB
TDZ5o/Ij9U6V/6eo9/yX/HGxFgW30YcmOI7DEfwHvh9NwLMxmD6I/5Z/WWRXxT/ziX8XMPxvxZbb
mgBn8B8kyQRiC2N5AeK/5T+TpVrUdsTA+P0/ZFFE+78LHOR/k6pVLsq7BS+VULvX9nHK/iMv6PGf
+Fid1n8H+JKLGgpRcljhDEhFWUMKtaqQfWinAYgSVM5B7w0w682M2fRQ+1Jig+rFV3ptsV4GQgG2
f+DVDgqJldeyAsVrpRvqXnlRiG3Na3xIFaQVhzTLeAbYl+w00wOop9PP+EV15Ac9CpVDJtZrXuEY
QO22+GW5hh+NxE5hjqPm83ZcM3072w+xfupESQnLRgH+vKcXvJTNXT791xS+Csbkl5W85+UC/3H3
F+/jaf1PRqz/MYtw//dtDsrgxu3f8G9p628xfv8P8I/2fxfo86/XvYVYpJsL9jFe/4dJRP6fE/T4
t+ICtvyHw/wnQdTn34ti4t8FptNnMm2vmfQLXlUoxvS8aB+18hFqjnrpHpZ8lTY1b6WRVkMo7lKo
GhSIWnhNEQdk4SdY5Wk1XKL11aHSD+/b4vpY2VDb2Wy47Xw+XPb23ddvw6U/fw2XfX9zumw/Wg7b
ij8I2ezrpUa9SnzQYlPLXXFXygoFb6olMN+175Z8J9u6HDK+TptCAfOey+1CbIT6G2Vq7F9rLJvx
n1H6z2e4AqD+s+mUGty4/Zt1H83YWg5ovP7zQ4/yP07Q5d9WDugM/cc8yv84QZd/WzmgM/j3EtL/
TtDl31YO6Az+/YjyP07Q5f/PPX/g1QXVwPj9P/KZR/u/Cwzzb8L4r9fdp+z/hf/v4zWh9d8FyP8n
/9/YvyUP+4z8bxSxgOzfBSj/S/lfY/+2YoCj438sCWKd/7W1IHVx4/Zv+MfJfV3xPzr/5QRd/rvh
9ktOiDP8v4QlxL8LHOX/Qi7geP/PDyn/6wbk/5H/Z8z9qvI/ZP9O0OX/qvI/5P87QZf/a8r/xB7l
f1ygy7+t49Zn+P9ee/6Hzn9bR5d/W7GA8f5fGOv1n/w/+xjg/6LbQLv+Hzn/eyD+j7e0/7sAxf8p
/m/s/2ri/34Y+EHv/O8lA1Jd3Lj9EwgEAoFAIBBuC78BaSEregBQAAA=""".replace('\n', '')

import os
import sys
import yaml
import pytest
import string
import random
import fileinput
import time
from datetime import datetime
from mock.mock import patch
try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from insights.client.apps.malware_detection import (
    DEFAULT_MALWARE_CONFIG, MIN_YARA_VERSION,
    MalwareDetectionClient, logger,
    get_toplevel_dirs, get_parent_dirs, remove_child_items, remove_included_excluded_items,
    process_include_items, process_exclude_items, process_include_exclude_items
)
from insights.client.apps.manifests import manifests, content_types
from insights.util.subproc import call, CalledProcessError
from insights.client.constants import InsightsConstants as constants
from insights.client.config import InsightsConfig


def find_test_item(item_name):
    for path, dirs, files in os.walk(os.getcwd()):
        if item_name in dirs or item_name in files:
            return os.path.join(path, item_name)
    return ""


def tld(path):
    """
    Return the top level directory for 'path' argument
    """
    full_path = os.path.abspath(path)
    if os.path.samefile(full_path, '/'):
        return full_path
    parent_dirs = []
    get_parent_dirs(full_path, parent_dirs)
    return parent_dirs[0]


# Does the system have yara installed on it?
YARA_BINARY = None
try:
    YARA_BINARY = str(call('which yara')).strip()
except CalledProcessError:
    # Double check its not in /usr/local/bin/yara
    YARA_BINARY = '/usr/local/bin/yara' if os.path.isfile('/usr/local/bin/yara') else ''

# Can't run many of the tests if yara is missing
NO_YARA = not YARA_BINARY
NO_YARA_SKIP_TEST_REASON = "Couldn't find yara which is needed by the malware-detection tests"

# Miscellanous extra files used by the malware tests are in the malware_detection_misc directory
MISC_DIR = find_test_item('malware_detection_misc')
NO_MISC = not os.path.isdir(MISC_DIR)
NO_MISC_SKIP_TEST_REASON = "Couldn't find %s which contains extra files for the malware-detection tests" % MISC_DIR

# Tests using the caplog fixture fail with python 2.6
IS_PY26 = sys.version_info < (2, 7)
PY26_SKIP_TEST_REASON = "pytest caplog fixture doesn't work in python 2.6"

# Can't scan the pytest process in the Jenkins QE environment for some reason
IS_QE = '/home/runner' in os.getcwd()  # Is there a better way to detect the QE environment?
QE_PYTEST_SKIP_TEST_REASON = "Can't scan pytest process in QE Jenkins environment"

# Temporary directory for testing stuff in
RANDOM_STRING = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))
TEMP_TEST_DIR = "/tmp/malware-detection_test_dir_%s/" % RANDOM_STRING
TEMP_CONFIG_FILE = os.path.join(TEMP_TEST_DIR, 'malware-detection-config.yml')

# Location of this test file (might be a better way of determining this!)
MALWARE_TEST_FILE = find_test_item('test_malware_detection.py')
# Miscellaneous rules files and other text files used in the tests
MALWARE_CONFIG_FILE = os.path.join(MISC_DIR, 'malware-detection-config.yml')
COMPILED_RULES_FILE = os.path.join(MISC_DIR, 'compiled_rules.yar')
TEST_RULE_FILE = os.path.join(MISC_DIR, 'TEST_RedHatInsightsMalwareDetection.yar')
RULE_METADATA_TEST_FILE = os.path.join(MISC_DIR, 'rule_metadata_test.yar')
RULE_RULE_FILE = os.path.join(MISC_DIR, 'rule rule.yar')
MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'matching_entity')
ANOTHER_MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'another matching_entity')

# Get the number of CPU threads to run yara
CPUS = 1 if int(call('nproc').strip()) <= 2 else 2

# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = ['/boot', '/dev', '/etc', '/home', '/opt', '/proc', '/root', '/sys', '/tmp', '/usr', '/var']
INCLUDED_TLDS = ['/boot', '/etc', '/home', '/opt', '/root', '/tmp', '/usr', '/var']  # after removing exclude items
DEFAULT_SCAN_EXCLUDE = ['/cgroup', '/dev', '/media', '/mnt', '/net', '/proc', '/selinux', '/sys']


@pytest.fixture
def use_temp_config():
    # Make a copy of the config file to make changes to it
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    os.system('cp %s %s' % (MALWARE_CONFIG_FILE, TEMP_CONFIG_FILE))
    yield
    os.system('rm -rf %s' % TEMP_TEST_DIR)


@pytest.fixture
def extract_tmp_files():
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    os.system('tar -C %s -xf %s/tmp_scan_files.tgz' % (TEMP_TEST_DIR, MISC_DIR))
    yield
    os.system('rm -rf %s' % TEMP_TEST_DIR)


# Skip the python 2.6 tests for this class because most use caplog
@pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_MISC, reason=NO_MISC_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_YARA, reason=NO_YARA_SKIP_TEST_REASON)
@patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", MALWARE_CONFIG_FILE)
class TestMalwareDetectionClient:

    def test_default_malware_spec(self):
        # Read in the default malware spec and check its values
        manifest = yaml.safe_load(manifests['malware-detection'])
        content_type = content_types['malware-detection']
        assert content_type == "application/vnd.redhat.malware-detection.results+tgz"
        specs = manifest['plugins']['configs']
        for spec in ['mac_addresses', 'etc_machine_id', 'hostname', 'bios_uuid', 'machine_id', 'ip_addresses',
                     'subscription_manager_id']:
            assert {'enabled': True, 'name': 'insights.specs.default.DefaultSpecs.%s' % spec} in specs
            assert {'enabled': True, 'name': 'insights.specs.Specs.%s' % spec} in specs

    def test_default_malware_options(self):
        # Read in the default malware options and check its values
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
        assert malopts['yara_binary'] is None
        assert malopts['test_scan'] is True
        assert malopts['scan_filesystem'] is True
        assert malopts['scan_processes'] is False
        assert malopts['scan_only'] is None
        assert malopts['scan_since'] is None
        assert all([x in malopts['scan_exclude']
                    for x in ['/proc', '/sys', '/cgroup', '/selinux', '/net', '/mnt', '/media', '/dev']])
        assert malopts['exclude_network_filesystem_mountpoints'] is True

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    def test_running_default_options(self, get_rules_file, caplog):
        # However, with the default malware options, test_scan is true, so some of the options values
        # will be different from those of the default options.
        # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
        logger.setLevel('DEBUG')
        test_pid = str(os.getpid())

        mdc = MalwareDetectionClient()
        assert mdc.yara_binary == YARA_BINARY
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_process_scan is True
        if os.path.isfile(MALWARE_CONFIG_FILE):
            assert mdc.scan_fsobjects == [MALWARE_CONFIG_FILE]
            assert mdc.do_filesystem_scan is True
        else:
            assert mdc.do_filesystem_scan is False
        assert mdc.scan_pids == [test_pid]
        assert mdc.scan_since_dict == {'timestamp': None}
        assert mdc.scan_exclude_list == []
        assert mdc.network_filesystem_mountpoints == []
        assert mdc.scan_timeout == 3600
        assert mdc.nice_value == 19
        yara_cmd = ' '.join(mdc.yara_cmd)
        assert yara_cmd == "nice -n 19 %s -s -N -a 3600 -p %s -r -f %s" % (YARA_BINARY, CPUS, mdc.rules_file)
        if os.path.isfile(MALWARE_CONFIG_FILE):
            assert "Performing a test scan of %s and the current process (PID %s)"\
                   % (MALWARE_CONFIG_FILE, test_pid) in caplog.text
        else:
            assert "Performing a test scan of the current process (PID %s)" % test_pid in caplog.text
        assert "Using yara binary: %s" % YARA_BINARY in caplog.text

        # Remainder of test may not work in QE Jenkins environment because config file may not exist and
        # can't scan the pytest process
        if os.path.exists(MALWARE_CONFIG_FILE):
            mdc.scan_filesystem()
            assert "Scanning specified files in %s ..." % tld(MALWARE_CONFIG_FILE) in caplog.text
            assert "Matched rule TEST_RedHatInsightsMalwareDetection in file %s" % MALWARE_CONFIG_FILE in caplog.text

        mdc.scan_processes()
        if IS_QE:
            assert "Unable to scan process %s: " % test_pid in caplog.text
        else:
            assert "Scanning process %s ..." % test_pid in caplog.text
            assert "Matched rule TEST_RedHatInsightsMalwareDetection in process %s" % test_pid in caplog.text

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_running_modified_options(self, get_rules_file, use_temp_config):
        # Disable test_scan and the malware options should mostly be same as what's in the mdc object
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.yara_binary == YARA_BINARY
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []
        assert mdc.scan_since_dict == {'timestamp': None, 'datetime': None}
        assert all([d in mdc.scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])

    def test_scan_only_option(self, use_temp_config, caplog):
        # Test various combinations of scan_only and the scan_filesystem and scan_processes options
        # Firstly, test the default option values
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "rules_location: %s\n" % COMPILED_RULES_FILE if line.startswith('---') else line
            line = "test_scan: false" if line.startswith("test_scan:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []

        # Add scan_only for a process - expect to exit because we can't scan processes because do_process_scan is false
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only: 1" if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Skipping scan_only item: 1" in caplog.text
        assert "Unable to scan the items specified for the scan_only option" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Enable process scanning and now the scan_only value should be used
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_pids == ['1']

        # Add directories and processes and expect all to be scanned
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only:\n- 1\n- /tmp" if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.scan_pids == ['1']

        # Disable filesystem scanning and only expect the process to be scanned
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_filesystem: false" if line.startswith("scan_filesystem:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert "Skipping scan_only item: /tmp" in caplog.text
        assert mdc.scan_pids == ['1']

        # Disable both filesystem and process scanning and expect an error as there is nothing to scan
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_processes: false" if line.startswith("scan_processes:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Both filesystem and process scans are disabled.  Nothing to do." in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_invalid_option_values(self, use_temp_config, caplog):
        # Check the malware client app behaves in a predictable way if the user specifies invalid option values
        # Invalid value for nice - should be an integer
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "nice_value: nineteen" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Problem setting configuration option nice_value: invalid literal" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Missing colon for nice_value option
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value 19\n" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error encountered loading the malware-detection app config file" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Bad list items for scan_only, mixing single item and list items
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: 19\n" if line.startswith("nice_value") else line
            line = "scan_only: /bad\n- /bad" if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error encountered loading the malware-detection app config file" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Bad list items for scan_only, not a list item
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only:" if line.startswith("scan_only:") else line
            line = "/bad" if line.startswith("- /bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error encountered loading the malware-detection app config file" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Bad list items for scan_only, not enough spaces
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "-/bad" if line.startswith("/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error encountered loading the malware-detection app config file" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Bad list items for scan_only, using tabs instead of spaces
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "\t- /bad" if line.startswith("-/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error encountered loading the malware-detection app config file" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_using_env_vars(self, caplog):
        # Set certain option values via environment variables
        env_var_list = [('RULES_LOCATION', COMPILED_RULES_FILE), ('TEST_SCAN', 'false'),
                        ('SCAN_FILESYSTEM', 'YES'), ('SCAN_PROCESSES', 'hello'),  # will be interpreted as false
                        ('SCAN_ONLY', '/tmp'), ('SCAN_EXCLUDE', '/tmp'),
                        ('SCAN_SINCE', '2'), ('SCAN_TIMEOUT', '1800')]
        for key, value in env_var_list:
            os.environ[key] = value

        logger.setLevel('INFO')
        mdc = MalwareDetectionClient()
        assert mdc.yara_binary == YARA_BINARY
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.test_scan is False
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.scan_exclude_list == ['/tmp']
        assert mdc.scan_since_dict['timestamp'] < time.time() - (2 * 86400)
        assert mdc.scan_timeout == 1800
        # Not env vars, but just checking they have the expected values
        assert mdc.nice_value == 19
        assert mdc.cpu_thread_limit == CPUS

        # Start a filesystem scan and expect scan_only and scan_exclude to cancel each other out
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Test when SCAN_ONLY and SCAN_EXCLUDE values are comma separated
        for key, value in [('SCAN_ONLY', '/tmp,/,/var/tmp'),
                           ('SCAN_EXCLUDE', '/home,/,/fred,barney')]:
            os.environ[key] = value
        mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == ['/tmp', '/', '/var/tmp']
        assert mdc.scan_exclude_list == ['/home', '/']
        assert mdc.test_scan is False

        # Reset all the environment variables
        for key, value in env_var_list:
            os.environ[key] = ''

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_invalid_env_vars(self, get_rules_file, caplog):
        # Set options to invalid values
        logger.setLevel('INFO')
        os.environ['TEST_SCAN'] = 'false'
        os.environ['NICE_VALUE'] = 'nineteen'
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient()
        assert "Problem parsing environment variable NICE_VALUE: invalid literal" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        caplog.clear()
        os.environ['NICE_VALUE'] = '19'
        os.environ['SCAN_SINCE'] = 'blast'
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient()
        assert "Unknown value 'blast' for scan_since option" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        os.environ['TEST_SCAN'] = ''
        os.environ['NICE_VALUE'] = ''
        os.environ['SCAN_SINCE'] = ''

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    def test_successful_find_yara_binary(self, get_rules_file, use_temp_config, caplog):
        logger.setLevel('DEBUG')
        # Find yara using the system search path
        # If its already on the system, then malware will find that one, otherwise the test yara will be found
        mdc = MalwareDetectionClient()
        assert mdc.yara_binary == YARA_BINARY
        assert "Using yara binary: %s" % YARA_BINARY in caplog.text

        # Finding yara binary by using the yara_binary option
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "yara_binary: %s" % YARA_BINARY if line.startswith("yara_binary:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.yara_binary == YARA_BINARY
        assert "Using specified yara binary: %s" % YARA_BINARY in caplog.text

    def test_failing_find_yara_binary(self, use_temp_config, caplog):
        # Testing failing to find yara

        # Test with no yara found on system.  If yara is present on the system, then skip this test
        if not YARA_BINARY:
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
            assert "Couldn't find yara.  Please ensure the yara package is installed" in caplog.text
            assert exc_info.value.code == constants.sig_kill_bad

        # Test yara_binary option with non-existent file
        caplog.clear()
        yara_binary = '/bin/notyara'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "yara_binary: %s" % yara_binary if line.startswith("yara_binary:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Couldn't find the specified yara binary %s.  Please check it exists" % yara_binary in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Test yara_binary option with non-yara file
        yara_binary = '/bin/ls'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "yara_binary: %s" % yara_binary if line.startswith("yara_binary:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Error getting the version of the specified yara binary %s" % yara_binary in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    @patch("insights.client.apps.malware_detection.call")
    def test_find_yara_version(self, call, get_rules_file, caplog):
        # Test checking the version of yara

        # Invalid versions of yara
        for version in ['4.0.99', '4']:
            call.return_value = version
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
            assert "Found yara version %s, but malware-detection requires version >= %s" % (version, MIN_YARA_VERSION)\
                   in caplog.text
            assert exc_info.value.code == constants.sig_kill_bad
            caplog.clear()

        # Valid versions of yara
        for version in ['4.1', '10.0.0']:
            call.return_value = version
            with patch("insights.client.apps.malware_detection.MalwareDetectionClient._build_yara_command",
                       return_value="yara"):
                mdc = MalwareDetectionClient()
            assert mdc.yara_binary

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_scanning_compiled_rules_file(self, get_rules_file, use_temp_config, caplog):
        # Scan the compiled rules file ... with the compiled rules file
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_only: %s" % COMPILED_RULES_FILE if line.startswith("scan_only:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == [COMPILED_RULES_FILE]
        mdc.scan_filesystem()
        assert "Scan only the specified filesystem item: ['%s']" % COMPILED_RULES_FILE in caplog.text
        assert "Scanning specified files in %s ..." % tld(COMPILED_RULES_FILE) in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text
        # Matched 2 rules
        assert mdc.matches == 2
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        assert string_matches == 3

        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] <= 544

        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'sent"'
        assert rule_match[0]['string_identifier'] == '$string1'
        assert rule_match[0]['string_offset'] == 601
        assert rule_match[1]['source'] == COMPILED_RULES_FILE
        assert rule_match[1]['string_data'] == 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00'
        assert rule_match[1]['string_identifier'] == '$string2'
        assert rule_match[1]['string_offset'] == 616
        assert mdc.scan_processes() is False

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_scanning_malware_test_file(self, get_rules_file, use_temp_config):
        # Scan this test_malware_detection.py file
        # Expect to match both rules in COMPILED_RULES_FILE, but only 1 string match per rule, due to using
        #   yara -f/fast scan option which stops searching for a matching string after finding it once
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_only: %s" % MALWARE_TEST_FILE if line.startswith("scan_only:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == [MALWARE_TEST_FILE]
        assert mdc.string_match_limit == 10

        mdc.scan_filesystem()
        assert mdc.matches == 2  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1  # But only 1 string match per rule
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        # First match is near the start of the file
        assert rule_match[0]['string_offset'] < 500

        # Increase string_match_limit and scan again.
        # Expect to find just one string match per rule again because of the yara fast scan option
        # (Should we still bother using string_match_limit now that we use fast scan option?)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == [MALWARE_TEST_FILE]
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_scan_only_root(self, get_rules_file, use_temp_config, caplog):
        # Nothing special about root when parsing the scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        logger.setLevel('DEBUG')
        scan_only = '/'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_only: %s" % scan_only if line.startswith("scan_only:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == [scan_only]
        assert "Scan only the specified filesystem item: ['%s']" % scan_only in caplog.text

        # This is called by scan_filesystem to convert '/' into its top level subdirectories
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert "Found root directory in list of items to scan.  Ignoring the other items ..." in caplog.text
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

        # Multiple directories aren't consolidated until later
        caplog.clear()
        scan_only = ['/', '/tmp', '/home']
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only: %s" % scan_only if line.startswith("scan_only:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == scan_only
        assert "Scan only the specified filesystem items: %s" % scan_only in caplog.text
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert "Found root directory in list of items to scan.  Ignoring the other items ..." in caplog.text
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_scan_exclude_root(self, get_rules_file, use_temp_config, caplog):
        # Nothing special about root when parsing the scan_exclude option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        logger.setLevel('DEBUG')
        # Add '/' to the list of scan_exclude items.  Add it directly after the scan_exclude: line
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert '/' in mdc.scan_exclude_list

        # When scan_filesystem is run, '/' will be expanded into toplevel directories that cancel out everything
        with pytest.raises(SystemExit) as exc_info:
            process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                          exclude_items=mdc.scan_exclude_list)
        assert "Found root directory in the exclude list.  Expanding it to all toplevel directories ..." in caplog.text
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_scan_only_scan_exclude_nullify(self, get_rules_file, use_temp_config, caplog):
        # Testing scan_only and scan_exclude items such that the exclude items nullify all the scan_only items
        # In which case there will be nothing to scan
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /var/log\n- /usr/lib/systemd\n- /tmp" if line.startswith("scan_only:") else line
            line = line + "\n- /tmp/\n- /usr/lib/\n- /var/log" if line.startswith("scan_exclude:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == ['/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.scan_exclude_list for x in ['/tmp', '/usr/lib', '/var/log']])
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Both scan_only and scan_exclude contain root
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- /" if line.startswith("scan_only:") else line
            line = line + "\n- /" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == ['/', '/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.scan_exclude_list for x in ['/', '/tmp', '/usr/lib', '/var/log']])
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_rules_file_types(self, caplog):
        # Testing if the rules file is compiled or not
        logger.setLevel('DEBUG')
        os.environ['TEST_SCAN'] = 'false'
        with patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE):
            mdc = MalwareDetectionClient()
        assert '-C' not in mdc.yara_cmd
        assert 'Compiled rules: False' in caplog.text

        caplog.clear()
        with patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE):
            mdc = MalwareDetectionClient()
        assert '-C' in mdc.yara_cmd
        assert 'Compiled rules: True' in caplog.text
        os.environ['TEST_SCAN'] = ''

    def test_bad_rules_files(self, use_temp_config, caplog):
        # Tests with non-rules/problematic files
        with open(TEMP_CONFIG_FILE, 'a') as tcf:
            # Append rules_location: and test_rule: to the bottom of the config file
            tcf.write("rules_location: %s\ntest_scan: false\n" % YARA_BINARY)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Unable to use rules file %s" % YARA_BINARY in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Missing rules file
        caplog.clear()
        missing_file = os.path.join(MISC_DIR, 'missing')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "rules_location: %s" % missing_file if line.startswith("rules_location:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Couldn't find specified rules file: %s" % missing_file in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Specify directory instead of a file
        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "rules_location: %s" % MISC_DIR if line.startswith("rules_location:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient()
        assert "Couldn't find specified rules file: %s" % MISC_DIR in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_files_with_extra_slashes_1(self, use_temp_config, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them
        logger.setLevel('INFO')
        # Test scanning COMPILED_RULES_FILE with an extra slash only in the rules_location one
        # Even with the extra slashes in the rules_location there will be rules matched
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % COMPILED_RULES_FILE.replace('/', '//') if line.startswith('---') else line
            line = "scan_only: %s" % COMPILED_RULES_FILE if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [COMPILED_RULES_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        # Will match the rules file because it is the same file
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text

    def test_files_with_extra_slashes_2(self, use_temp_config, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them
        # Replace slashes in both rules_location and scan_only with double slashes
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            if line.startswith('---'):
                line = line + "rules_location: %s\n" % COMPILED_RULES_FILE.replace('/', '//')
            if line.startswith("scan_only:"):
                line = line + "- %s\n- %s" % (MISC_DIR.replace('/', '//'), MALWARE_TEST_FILE.replace('/', '//'))
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

    def test_files_with_extra_slashes_3(self, use_temp_config, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them
        # For completeness (silliness?), try with even more slashes in the file names
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            if line.startswith('---'):
                line = line + "rules_location: %s" % COMPILED_RULES_FILE.replace('/', '////')
            if line.startswith("scan_only:"):
                line = line + "- %s\n- %s" % (MISC_DIR.replace('/', '///'), MALWARE_TEST_FILE.replace('/', '///'))
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '////')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

    def test_files_with_extra_slashes_4(self, use_temp_config, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them

        # Chaos monkey! - add extra slashes to rules_file and scan_fsobjects AFTER they have been verified
        # This is a contrived test and shouldn't happen in normal code flow but done to make sure malware behaves well
        # Testing passing double slashes directly into mdc just before mdc.scan_filesystems, eg
        # mdc.scan_fsobjects = ['//home//bob']; mdc.scan_filesystem()
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s" % COMPILED_RULES_FILE if line.startswith("---") else line
            line = line + "- %s\n- %s" % (MISC_DIR, MALWARE_TEST_FILE) if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        # Modify rules_file and scan_fsobjects AFTER they have been verified
        mdc.rules_file = COMPILED_RULES_FILE.replace('/', '//')
        mdc.scan_fsobjects = [MISC_DIR.replace('/', '//'), MALWARE_TEST_FILE.replace('/', '//')]
        mdc.scan_filesystem()
        assert "Scanning specified files in %s" % tld(MISC_DIR) in caplog.text
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text

    def test_scan_exclude_with_extra_slashes_1(self, use_temp_config, caplog):
        # Testing we handle the situation where items in scan_exclude contain multiple slashes!
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s" % COMPILED_RULES_FILE if line.startswith("---") else line
            line = line + "- //\n" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_scan_exclude_with_extra_slashes_2(self, use_temp_config, caplog):
        # Testing we handle the situation where items in scan_exclude contain multiple slashes!
        # Chaos monkey! - add extra slashes to scan_exclude items AFTER they have been verified
        # This is a contrived test and shouldn't happen in normal code flow but done to make sure malware behaves well
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s" % COMPILED_RULES_FILE if line.startswith("---") else line
            line = "scan_only: %s" % MISC_DIR if line.startswith("scan_only:") else line
            line = line + "- %s\n" % MISC_DIR if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert mdc.scan_fsobjects == [MISC_DIR]
        assert MISC_DIR in mdc.scan_exclude_list
        # Modify rules_file and scan_fsobjects AFTER they have been verified
        mdc.scan_exclude_list = [MISC_DIR.replace('/', '//')]
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_scanning_pytest_process(self, use_temp_config, caplog):
        # Scan the python pytest process whilst its running the tests
        logger.setLevel('INFO')
        test_pid = str(os.getpid())
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_processes: true" if line.startswith("scan_processes:") else line
            line = line + "rules_location: %s" % COMPILED_RULES_FILE if line.startswith("---") else line
            line = "scan_only: %s" % int(test_pid) if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert "Scan only the specified process ID: ['%s']" % test_pid in caplog.text
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True

        mdc.scan_processes()
        if IS_QE:
            assert "Unable to scan process %s: " % test_pid in caplog.text
        else:
            assert "Scanning process %s ..." % test_pid in caplog.text
            assert "Matched rule MalwareDetectionClientRule in process %s" % test_pid in caplog.text
            assert "Matched rule MiscellaneousStringsRule in process %s" % test_pid in caplog.text
            # Matches both rules in the PID
            assert mdc.matches == 2
            rule_match = mdc.host_scan['MalwareDetectionClientRule']
            assert len(rule_match) == 1
            assert rule_match[0]['source'] == test_pid
            assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
            assert rule_match[0]['string_identifier'] == '$text1'
            assert rule_match[0]['string_offset'] > 0
            metadata = rule_match[0]['metadata']
            assert metadata['source_type'] == 'process'
            # The process running the tests should have any of these strings in its name
            assert any([s in metadata['process_name'] for s in ('python', 'pytest', 'tests')])
            # Check that file related metadata keys are not present
            assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_filenames_containing_spaces(self, use_temp_config, caplog):
        # Check that filenames with spaces in them are handled ok
        logger.setLevel('DEBUG')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s" % RULE_RULE_FILE if line.startswith("---") else line
            line = "scan_only: %s" % ANOTHER_MATCHING_ENTITY_FILE if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        assert "Scan only the specified filesystem item: ['%s']" % ANOTHER_MATCHING_ENTITY_FILE in caplog.text
        assert "Using specified rules file: %s" % RULE_RULE_FILE in caplog.text
        assert "Yara command: ['nice', '-n', '19', '%s', '-s', '-N', '-a', '3600', '-p', '%s', '-r', '-f', '%s']" %\
               (YARA_BINARY, CPUS, RULE_RULE_FILE) in caplog.text
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8


# Don't skip the python 2.6 tests in this class because none of them use the caplog fixture
# Having these tests pass with python 2.6 should be proof enough that overall malware works with 2.6
@pytest.mark.skipif(NO_MISC, reason=NO_MISC_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_YARA, reason=NO_YARA_SKIP_TEST_REASON)
@patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", MALWARE_CONFIG_FILE)
class TestLineNumberMetadata:

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=RULE_RULE_FILE)
    def test_rule_rule_scan_another_matching_entity(self, get_rules_file):
        mdc = MalwareDetectionClient()
        mdc.scan_fsobjects = [ANOTHER_MATCHING_ENTITY_FILE]
        mdc.scan_filesystem()

        # 8 matching strings for 'Rule' in 'another matching_entity' file
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8

        assert rule_match[0]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[0]['string_identifier'] == '$match3'
        assert rule_match[0]['string_offset'] == 2
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[1]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "contains ="
        assert rule_match[1]['string_identifier'] == '$grep1'
        assert rule_match[1]['string_offset'] == 97
        metadata = rule_match[1]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[2]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == "contains .+"
        assert rule_match[2]['string_identifier'] == '$grep2'
        assert rule_match[2]['string_offset'] == 153
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == 'contains "'
        assert rule_match[3]['string_identifier'] == '$grep3'
        assert rule_match[3]['string_offset'] == 213
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains '"
        assert rule_match[4]['string_identifier'] == '$grep4'
        assert rule_match[4]['string_offset'] == 241
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_data'] == 'contains ()[]'
        assert rule_match[5]['string_identifier'] == '$grep5'
        assert rule_match[5]['string_offset'] == 269
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == 'contains {'
        assert rule_match[6]['string_identifier'] == '$grep6'
        assert rule_match[6]['string_offset'] == 299
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[7]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[7]['string_data'] == 'contains ^$'
        assert rule_match[7]['string_identifier'] == '$grep7'
        assert rule_match[7]['string_offset'] == 327
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules",
           return_value=RULE_METADATA_TEST_FILE)
    def test_rule_metadata_test_scanning_itself(self, get_rules_file):
        # Taking some complicated rule strings to make sure grepping for line numbers is working correctly
        mdc = MalwareDetectionClient()
        mdc.scan_fsobjects = [RULE_METADATA_TEST_FILE]
        mdc.scan_filesystem()

        rule_match = mdc.host_scan['MetadataTestRule']
        assert len(rule_match) == 9

        assert rule_match[0]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[0]['string_data'] == 'echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"'
        assert rule_match[0]['string_identifier'] == '$s1'
        assert rule_match[0]['string_offset'] == 392
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'UTF-8 Unicode text'
        assert metadata['mime_type'] == 'text/plain; charset=utf-8'
        assert metadata['md5sum'] == '227429b142ad425733fe155386d4a405'
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode('Testing $s1 = "echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"" ascii fullword')

        assert rule_match[1]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[1]['string_data'] == '"${user_name}"@"${host_name}" -p "${port}'
        assert rule_match[1]['string_identifier'] == '$s2'
        assert rule_match[1]['string_offset'] == 478
        metadata = rule_match[1]['metadata']
        assert metadata['line_number'] == 10
        assert metadata['line'] == urlencode('Testing $s2 = ""${user_name}"@"${host_name}" -p "${port}" ascii fullword')

        assert rule_match[2]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[2]['string_data'] == """'$password' &" <<< GMANcode27'"""
        assert rule_match[2]['string_identifier'] == '$s3'
        assert rule_match[2]['string_offset'] == 555
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode("""Testing $s3 = "'$password' &" <<< GMANcode27'" ascii fullword""")

        assert rule_match[3]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[3]['string_data'] == "for ssh_creds in ${allThreads[@]}; do"
        assert rule_match[3]['string_identifier'] == '$s4'
        assert rule_match[3]['string_offset'] == 119
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode('Testing $s4 = "for ssh_creds in ${allThreads[@]}; do" ascii fullword')

        assert rule_match[4]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[4]['string_data'] == '"text=$MSG" "$MSG_URL$id&"'
        assert rule_match[4]['string_identifier'] == '$s5'
        assert rule_match[4]['string_offset'] == 621
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode('Testing $s5 = ""text=$MSG" "$MSG_URL$id&"" ascii fullword')

        # Cannot match line_numbers for this rule due to non-ascii chars
        assert rule_match[5]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[5]['string_data'] == "--exclude=\\*.\\xE2\\x98\\xA2 -l"
        assert rule_match[5]['string_identifier'] == '$s6'
        assert rule_match[5]['string_offset'] == 683
        metadata = rule_match[5]['metadata']
        assert all([key not in ['line_number', 'line'] for key in metadata.keys()])

        assert rule_match[6]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[6]['string_data'] == "--include=\\*.{txt,sh,exe}"
        assert rule_match[6]['string_identifier'] == '$s7'
        assert rule_match[6]['string_offset'] == 732
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode(r'Testing $s7 = "--include=\*.{txt,sh,exe}" ascii fullword')

        assert rule_match[7]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[7]['string_data'] == "allThreads=($1)"
        assert rule_match[7]['string_identifier'] == '$s8'
        assert rule_match[7]['string_offset'] == 192
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 5
        assert metadata['line'] == urlencode('Testing $s8 = "allThreads=($1)" ascii fullword')

        assert rule_match[8]['source'] == RULE_METADATA_TEST_FILE
        assert rule_match[8]['string_data'] == "$(host): encrypt files. Done."
        assert rule_match[8]['string_identifier'] == '$s9'
        assert rule_match[8]['string_offset'] == 243
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 6
        assert metadata['line'] == urlencode('Testing $s9 = "$(host): encrypt files. Done." ascii fullword')


CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
""" % (MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE)

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""


# Skip the python 2.6 tests for this class because most use caplog
@pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_MISC, reason=NO_MISC_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_YARA, reason=NO_YARA_SKIP_TEST_REASON)
@patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", MALWARE_CONFIG_FILE)
# Rule used is irrelevant for these tests because we aren't actually scanning, just parsing canned yara output
@patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
class TestParseScanOutput:

    def test_contrived_scan_output(self, get_rules_file, caplog):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
        # The rules_location is irrelevant to the test but it just makes the initialization of
        # MalwareDetectionClient easier if done this way (and its simpler than using @patch ... maybe)
        logger.setLevel('DEBUG')  # Make sure the logging level is set *before* performing the scan
        mdc = MalwareDetectionClient()
        mdc.add_metadata = False
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        assert mdc.matches == 8

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        assert len(rule_match) == 1
        assert 'e-r-r-o-r s-c-a-n-n-i-n-g' in rule_match[0]['source']
        assert rule_match[0]['string_data'] == "matches 'this' rule"
        assert rule_match[0]['string_identifier'] == '$match'
        assert rule_match[0]['string_offset'] == 291

        # 14 matching strings for 'Rule'
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 14
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == 'string match in the file "matching_entity"'
        assert rule_match[0]['string_identifier'] == '$match0'
        assert rule_match[0]['string_offset'] == 21
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "another string match in matching_entity"
        assert rule_match[1]['string_identifier'] == '$match1'
        assert rule_match[1]['string_offset'] == 83
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == 'string with different types of quotes \'here\' and "here"'
        assert rule_match[2]['string_identifier'] == '$match2'
        assert rule_match[2]['string_offset'] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[3]['string_identifier'] == '$match3'
        assert rule_match[3]['string_offset'] == 2
        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains ="
        assert rule_match[4]['string_identifier'] == '$grep1'
        assert rule_match[4]['string_offset'] == 97
        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == "contains .+"
        assert rule_match[6]['string_identifier'] == '$grep2'
        assert rule_match[6]['string_offset'] == 153
        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_data'] == 'contains "'
        assert rule_match[8]['string_identifier'] == '$grep3'
        assert rule_match[8]['string_offset'] == 213
        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_data'] == "contains '"
        assert rule_match[9]['string_identifier'] == '$grep4'
        assert rule_match[9]['string_offset'] == 241
        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_data'] == 'contains ()[]'
        assert rule_match[10]['string_identifier'] == '$grep5'
        assert rule_match[10]['string_offset'] == 269
        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_data'] == 'contains {'
        assert rule_match[11]['string_identifier'] == '$grep6'
        assert rule_match[11]['string_offset'] == 299
        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_data'] == 'contains ^$'
        assert rule_match[12]['string_identifier'] == '$grep7'
        assert rule_match[12]['string_offset'] == 327

        assert rule_match[13]['source'].startswith('matching_entity_3')
        assert rule_match[13]['string_data'] == ''
        assert rule_match[13]['string_identifier'] == ''
        assert rule_match[13]['string_offset'] == -1

        # 4 matching strings for 'another_matching_rule'
        rule_match = mdc.host_scan['another_matching_rule']
        assert len(rule_match) == 4
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        assert rule_match[2]['string_data'] == '#!/bin/sh'
        assert rule_match[2]['string_identifier'] == '$s0'
        assert rule_match[2]['string_offset'] == 60783814
        assert rule_match[3]['source'] == '1234567'
        assert rule_match[3]['string_data'] == '#!/bin/sh'
        assert rule_match[3]['string_identifier'] == '$s0'
        assert rule_match[3]['string_offset'] == 0

        rule_match = mdc.host_scan['Iyamtho']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == " yep"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        rule_match = mdc.host_scan['n_m3_t00']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == "damn   straight"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        assert "Error parsing string match '0x1badoffset:$s1: skip this line': " in caplog.text
        assert "Error parsing string match '0x2error scanning skip/this/line/too: need more colons': " in caplog.text

    def test_contrived_scan_output_metadata(self, get_rules_file, caplog):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_file_location with any rule, but its not relevant for the tests
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient()
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # Matches and metadata for MATCHING_ENTITY_FILE
        # assert "grep -Ebon  -e 'another string match in matching_entity'" in caplog.text
        rule_match = mdc.host_scan['Rule']
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_offset'] == 21
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 1
        assert metadata['line'] == urlencode('This line contains a string match in the file "matching_entity"')

        # Testing displaying long lines
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_offset'] == 83
        metadata = rule_match[1]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 2
        assert metadata['line'] == urlencode('This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o...')

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_offset'] == 230
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode("""And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough""")

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        # assert "[]' -e 'contains =' -e 'contains '\"'\"''" in caplog.text
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_offset'] == 2
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_offset'] == 97
        metadata = rule_match[4]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_offset'] == 123
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 8
        assert metadata['line'] == urlencode("This line contains = char too")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_offset'] == 153
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_offset'] == 213
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_offset'] == 241
        metadata = rule_match[9]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_offset'] == 269
        metadata = rule_match[10]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_offset'] == 299
        metadata = rule_match[11]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_offset'] == 327
        metadata = rule_match[12]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert rule_match[13]['source'] == "matching_entity_3, but without any string matches - yes that's ok"
        metadata = rule_match[13]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.host_scan['another_matching_rule']
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]['source'] == '1234567'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert all([key not in ['process_name', 'file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_error_scan_output(self, get_rules_file, caplog):
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient()
        mdc.parse_scan_output(ERROR_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file' in caplog.text

    def test_error4_scan_output(self, get_rules_file, caplog):
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient()
        mdc.parse_scan_output(ERROR4_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4' in caplog.text

    def test_random_output(self, get_rules_file):
        mdc = MalwareDetectionClient()
        mdc.parse_scan_output(RANDOM_OUTPUT)

        assert mdc.matches == 2
        rule_match = mdc.host_scan['Lorem']
        assert rule_match[0]['source'].startswith('ipsum dolor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1
        rule_match = mdc.host_scan['Dictum']
        assert rule_match[0]['source'].startswith('at tempor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1


@pytest.mark.skipif(NO_MISC, reason=NO_MISC_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_YARA, reason=NO_YARA_SKIP_TEST_REASON)
@patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", MALWARE_CONFIG_FILE)
class TestIncludeExcludeProcessing:

    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list)
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/usr/lib')
        assert sorted(parent_dir_list) == ['/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/var')
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = ['/path/to/some/item/child', '/path/to/another/item', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = ['/var/lib64', '/home/bob', '/var/lib/docker', '/home/bob', '/var/lib',
                 '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child', '/var/lib63/im ok', '/var/lib64/im not']
        assert remove_child_items(items) == ['/home/bob', '/home/bobby-droptables', '/var/lib',
                                             '/var/lib63/im ok', '/var/lib64']

        # /path is common to both so that will be all that is returned
        items = ['/path/to/another/item', '/path/to/some/item', '/path']
        assert remove_child_items(items) == ['/path']

        # The root directory will always win
        items = ['/path/to/another/item', '/path/to/some/item', '/']
        assert remove_child_items(items) == ['/']

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ['/path/to/another/item', '', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

    def test_remove_included_excluded_items(self):
        include_items = ['/home/bob', '/tmp', '/var/www/html']
        exclude_items = ['/home/bo', '/home/bob/exclude', '/home/bobby', '/temp', '/var/www']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/home/bob', '/tmp']

        # Some fairly random lists similar to before
        include_items = ['/var/lib64/docker', r'/home/bob/this\ is\ bobs/child', '/var/lib/docker', '/home/bob',
                         '/var/lib', '/usr']
        exclude_items = ['/var/lib/docker2', '/home/bob', '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child',
                         '/var/lib63/im ok', '/var/lib64/im not', '/boot']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/usr', '/var/lib', '/var/lib64/docker']

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
    def test_process_include_items(self, caplog):
        # Call process_include_items with variously populated lists
        logger.setLevel('DEBUG')

        # Add some valid entries to include_items list, esp subdirectories
        include_items = ['/etc/pam.d', '/tmp', '/var/log/']
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/pam.d', '/tmp', '/var/log']

        # Add some more subdirectories
        include_items.extend(['/etc/cron.d', '/tmp', '/var/lib/'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/cron.d', '/etc/pam.d', '/tmp', '/var/lib', '/var/log']

        # Add some top level directories to override the subdirectories
        include_items.extend(['/etc', '/var'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries that will get ignored
        caplog.clear()
        include_items.extend(['..', '/var/run', '/missing'])
        processed_items = process_include_items(include_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping link '/var/run' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory (/) which will override all the other entries
        caplog.clear()
        include_items.append('/')
        processed_items = process_include_items(include_items)
        assert "Found root directory in list of items to scan.  Ignoring the other items ..." in caplog.text
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
    def test_process_exclude_items(self, caplog):
        # Call process_exclude_items with variously populated lists
        logger.setLevel('DEBUG')

        # Remove the default entries from the exclude file
        processed_items = process_exclude_items()
        assert "No items specified to be excluded" in caplog.text
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ['/etc/ssh', '/tmp', '/var/run/']
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/ssh', '/tmp', '/var/run']

        # Add some more subdirectories
        exclude_items.extend(['/etc/cron.d', '/tmp', '/var/lock/'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/cron.d', '/etc/ssh', '/tmp', '/var/lock', '/var/run']

        # Add some top level directories to override the subdirectories
        exclude_items.extend(['/etc', '/var'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries to exclude items
        caplog.clear()
        exclude_items.extend(['..', '/missing'])
        processed_items = process_exclude_items(exclude_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory
        caplog.clear()
        exclude_items.append('/')
        processed_items = process_exclude_items(exclude_items)
        assert "Found root directory in the exclude list.  Expanding it to all toplevel directories ..." in caplog.text
        assert processed_items == get_toplevel_dirs()

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_process_include_exclude_items_simple(self, get_rules_file, caplog):
        # Test the process_include_exclude_items function with simple modified include and exclude items
        # Simple in that the include and exclude files are modified in such a way that
        # directory listings aren't required get the list of included files
        # Add a single toplevel directory to the include file - expect only a single directory to scan
        logger.setLevel('INFO')
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient()
        mdc.scan_fsobjects = ['/etc']
        mdc.scan_exclude_list = []
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']
        assert 'include' not in scan_dict['/etc']
        assert 'exclude' not in scan_dict['/etc']

        # Add some extra subdirectories to scan
        mdc.scan_fsobjects.extend(['/var/lib', '/var/log'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(list(scan_dict['/var']['include'])) == ['/var/lib', '/var/log']
        assert 'exclude' not in scan_dict['/var']

        # Add some extra directories to exclude that won't impact the already included directories
        mdc.scan_exclude_list.extend(['/tmp', '/var/run'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(scan_dict['/var']['include']) == ['/var/lib', '/var/log']
        assert scan_dict['/var']['exclude']['items'] == ['/var/run']

        # Exclude /var which will remove it from the list of directories to scan
        mdc.scan_exclude_list.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']

        # Exclude /etc which means there will be no directories to scan
        caplog.clear()
        mdc.scan_exclude_list.append('/etc')
        with pytest.raises(SystemExit) as exc_info:
            process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                          exclude_items=mdc.scan_exclude_list)
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad
        os.environ['TEST_SCAN'] = ''

    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_process_include_exclude_files_complex(self, get_rules_file):
        # Test the process function with modified include and exclude files that will require more complex
        # processing to generate the list of items to be scanned
        # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
        # We don't need to list the contents of the /var directory
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient()
        mdc.scan_fsobjects = ['/var/lib', '/var/log']
        mdc.scan_exclude_list = ['/var/lib/systemd', '/var/lib/misc/', '/var/log/wtmp']

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        # The exclude items shouldn't be in the include items
        # Nor should other items that aren't in the explicitly included items
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp',
                              '/var/cache', '/var/lib', '/var/log', '/var/tmp', '/tmp']])
        # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
        # but not the excluded items, eg /var/log/wtmp
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/lib/xkb', '/var/lib/dbus', '/var/log/btmp', '/var/log/lastlog']])

        # Change the include directory to /var
        # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
        # Because now we have to list the contents of the /var and /var/lib directories
        mdc.scan_fsobjects.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp', '/var/lib', '/var/log', '/tmp']])
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/cache', '/var/tmp', '/var/lib/xkb', '/var/lib/dbus',
                              '/var/log/btmp', '/var/log/lastlog']])
        os.environ['TEST_SCAN'] = ''

    @pytest.mark.skipif(not os.path.exists('/usr/local/libexec'), reason="No /usr/local/libexec")
    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE)
    def test_process_include_exclude_files_similar_names(self, get_rules_file):
        # Now test including/excluding items that have similar names, eg /usr/local/lib and /usr/local/libexec
        # /usr/local has sub directories /usr/local/lib and /usr/local/libexec (ie similar names)
        # If we exclude /usr/local/lib then /usr/local/libexec should still be included
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient()
        mdc.scan_fsobjects = ['/usr/local']
        mdc.scan_exclude_list.append('/usr/local/lib')

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert list(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib']
        # Ensure /usr/local/lib is NOT in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib']])
        # But ensure /usr/local/libexec IS in the list of items to scan
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share', '/usr/local/libexec']])

        # Add /usr/local/libexec as an item to exclude and ensure both /usr/local/lib and libexec are excluded now
        mdc.scan_exclude_list.append('/usr/local/libexec')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib', '/usr/local/libexec']
        # Ensure /usr/local/lib and /usr/local/libexec are both not in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib', '/usr/local/libexec']])
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share']])

        # Test including /usr/local/lib and excluding an item from it
        # Confirm that only items from /usr/local/lib are included and NOT from any other directory
        usr_local_lib = sorted(filter(lambda x: not os.path.islink(x),
                                      map(lambda x: '/usr/local/lib/' + x, os.listdir('/usr/local/lib'))))
        assert len(usr_local_lib) > 2
        excluded_item1 = usr_local_lib[0]
        excluded_item2 = usr_local_lib[1]
        mdc.scan_fsobjects = ['/usr/local/lib']
        mdc.scan_exclude_list = [excluded_item1, excluded_item2]
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == [excluded_item1, excluded_item2]
        # Ensure only /usr/local/lib items are included (except the first 2 in the directory)
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/local', '/usr/local/lib', '/usr/local/libexec',
                              excluded_item1, excluded_item2]])
        assert all([x in scan_dict['/usr']['include'] for x in usr_local_lib[2:]])
        os.environ['TEST_SCAN'] = ''

    def test_process_include_exclude_tmp_files(self, extract_tmp_files):
        # Test the including/excluding some of the files in the tmp archive
        # Specifically tests excluding link files (good or broken) and pipe files (as well as explicit exclude items)

        include_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me', 'scan_me_too']))
        exclude_items = list(map(lambda x: TEMP_TEST_DIR + x,
                                 ['scan_me_not', 'scan_me/dont_scan_me', 'scan_me_too/dont_scan_me_too']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted(exclude_items)

        include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                        ['scan_me/new_file', 'scan_me/old_file', 'scan_me/scan_me',
                                         'scan_me/scan_me_file', 'scan_me_too/new_file', 'scan_me_too/old_file',
                                         'scan_me_too/scan_me_too', 'scan_me_too/scan_me_too_file'])))
        dont_include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                             ['scan_me/link_file', 'scan_me/pipe_file', 'scan_me/broken_link',
                                              'scan_me/dont_scan_me', 'scan_me_too/link_file', 'scan_me_too/pipe_file',
                                              'scan_me_too/broken_link', 'scan_me_too/dont_scan_me_too'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])

        # Another test to assert a bug I found is fixed ... due to only having scan_items = set([])
        # Basically include_files should = ['scan_me/scan_me'] but the bug made include_files = []
        include_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me/scan_me']))
        exclude_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me_not']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)

        include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me/scan_me'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        dont_include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                             ['scan_me/scan_me_file', 'scan_me/dont_scan_me', 'scan_me/scan_me/here_i_am'])))
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
    @patch("insights.client.apps.malware_detection.MalwareDetectionClient._get_rules", return_value=RULE_RULE_FILE)
    def test_scan_tmp_files(self, get_rules_file, use_temp_config, extract_tmp_files, caplog):
        # Scan the files in the tmp file and set scan_only, scan_exclude to same values as above
        logger.setLevel('INFO')
        scan_me_file = os.path.join(TEMP_TEST_DIR, 'scan_me/scan_me_file')
        scan_me_too_file = os.path.join(TEMP_TEST_DIR, 'scan_me_too/scan_me_too_file')
        scan_only = tuple(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ['scan_me', 'scan_me_too']))
        scan_exclude = tuple(map(lambda x: os.path.join(TEMP_TEST_DIR, x),
                                 ['scan_me_not', 'scan_me/dont_scan_me', 'scan_me_too/dont_scan_me_too']))
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + '- %s\n- %s' % scan_only if line.startswith("scan_only:") else line
            line = line + "- %s\n- %s\n- %s" % scan_exclude if line.startswith("scan_exclude:") else line
            print(line)

        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient()
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted(scan_exclude)

        mdc.scan_filesystem()
        assert mdc.matches == 2  # There were only 2 files the matched the rule
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 11  # There were 11 strings matched in the 2 files
        # Asserting the names of the 2 files that were matched
        sources = set([rm['source'] for rm in rule_match])
        assert len(sources) == 2
        assert scan_me_file in sources
        assert scan_me_too_file in sources

        # With the same scan_only and scan_exclude values, add scan_since: last into the mix and set the last scan
        # time to now.  There should be no matches because no files have been modified since now
        caplog.clear()
        last_scan = time.time()
        last_scan_fmt = datetime.fromtimestamp(last_scan).strftime('%Y-%m-%d %H:%M:%S')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_since: last" if line.startswith("scan_since:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient()
        assert mdc.scan_since_dict['timestamp'] == last_scan
        assert mdc.scan_since_dict['datetime'] == last_scan_fmt
        assert "Scan for files created/modified since last successful scan on %s" % last_scan_fmt in caplog.text
        mdc.scan_filesystem()
        assert mdc.matches == 0  # There were no files modified since 'last_scan'

        # Try again, keeping the same last_scan time, but this time touch one of the matching files
        # Should get a match on the touched file because it has been 'modified' since the last scan
        caplog.clear()
        os.system('touch %s' % scan_me_file)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient()
        mdc.scan_filesystem()
        assert mdc.matches == 1  # There was 1 file modified since last_scan
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8  # There were 8 strings matched in the 2 files
        assert rule_match[0]['source'] == scan_me_file

        # Touch another of the matching files, keeping the same last_scan time.
        # Expect to get 2 matching files this time
        caplog.clear()
        os.system('touch %s' % scan_me_too_file)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with patch("insights.client.apps.malware_detection.get_scan_since_timestamp", return_value=last_scan):
                mdc = MalwareDetectionClient()
        mdc.scan_filesystem()
        assert mdc.matches == 2  # There were 2 files modified since last_scan the matched the rule
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 11  # There were 11 strings matched in the 2 files
        # Asserting the names of the 2 files that were matched
        sources = set([rm['source'] for rm in rule_match])
        assert len(sources) == 2
        assert scan_me_file in sources
        assert scan_me_too_file in sources


@pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_MISC, reason=NO_MISC_SKIP_TEST_REASON)
@pytest.mark.skipif(NO_YARA, reason=NO_YARA_SKIP_TEST_REASON)
@patch("insights.client.connection.InsightsConnection.get", None)
# TODO: properly mock the InsightsConnection.get to return a response instead of None
class TestGetRules:

    @patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", MALWARE_CONFIG_FILE)
    def test_get_regular_rules_location_urls(self, caplog):
        # Test the standard rules_location urls, depending on whether test rule or cert auth is set
        # With test scan true, expect to download test-rule.yar
        logger.setLevel('INFO')
        os.environ['TEST_SCAN'] = 'true'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        assert "https://console.redhat.com/api/malware-detection/v1/test-rule.yar" in caplog.text

        caplog.clear()
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar" in caplog.text

        # With test scan false, expect to download signatures.yar
        caplog.clear()
        os.environ['TEST_SCAN'] = 'false'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(authmethod='BASIC'))
        assert "https://console.redhat.com/api/malware-detection/v1/signatures.yar" in caplog.text

        caplog.clear()
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar" in caplog.text
        os.environ['TEST_SCAN'] = ''

    @patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE)
    def test_get_irregular_rules_location_urls(self, use_temp_config, caplog):
        # Non-standard rules URLs
        # Without https:// at the start and not signatures.yar
        logger.setLevel('INFO')
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "rules_location: console.redhat.com/rules.yar" if line.startswith("---") else line
            print(line)
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        assert "https://console.redhat.com/test-rule.yar" in caplog.text

        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            print(line)
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert "https://cert.console.redhat.com/rules.yar" in caplog.text

    @patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE)
    def test_get_rules_location_files(self, use_temp_config, caplog):
        # Test using files for rules_location, esp irregular file names
        # Re-writing the rule to be test-rule.yar doesn't apply to local files
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "rules_location: //console.redhat.com/rules.yar" if line.startswith("---") else line
            print(line)
        with pytest.raises(SystemExit):
            MalwareDetectionClient()
        assert "Couldn't find specified rules file: /console.redhat.com/rules.yar" in caplog.text

        caplog.clear()
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            print(line)
        with pytest.raises(SystemExit):
            MalwareDetectionClient()
        assert "Couldn't find specified rules file: /console.redhat.com/rules.yar" in caplog.text


if __name__ == '__main__':
    print(YARA_BINARY)
    print(MISC_DIR)
    print(MALWARE_CONFIG_FILE)
    print(MALWARE_TEST_FILE)

import os
import sys
import pytest
import yaml
import time
import string
import random
import fileinput
from mock.mock import patch, Mock, ANY
try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from insights.client.apps.manifests import manifests, content_types
from insights.client.constants import InsightsConstants as constants
from insights.util.subproc import call, CalledProcessError
from insights.client.config import InsightsConfig

from insights.client.apps.malware_detection import (
    DEFAULT_MALWARE_CONFIG, MalwareDetectionClient, InsightsConnection,
    get_toplevel_dirs, get_parent_dirs, remove_child_items, remove_included_excluded_items,
    process_include_items, process_exclude_items, process_include_exclude_items
)

# Temporary directory for testing stuff in
RANDOM_STRING = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))
TEMP_TEST_DIR = "/tmp/malware-detection_test_dir_%s" % RANDOM_STRING

YARA = '/bin/yara'  # Fake yara executable
RULES_FILE = os.path.join(TEMP_TEST_DIR, 'rules.yar')
CONFIG = yaml.safe_load(DEFAULT_MALWARE_CONFIG)  # Config 'returned' from _load_config
TEMP_CONFIG_FILE = os.path.join(TEMP_TEST_DIR, 'malware-detection-config.yml')

# Get the number of CPU threads to run yara
CPUS = 1 if int(call('nproc').strip()) <= 2 else 2

# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = ['/boot', '/dev', '/etc', '/home', '/opt', '/proc', '/root', '/sys', '/tmp', '/usr', '/var']
INCLUDED_TLDS = ['/boot', '/etc', '/home', '/opt', '/root', '/tmp', '/usr', '/var']  # after removing exclude items
DEFAULT_SCAN_EXCLUDE = ['/cgroup', '/dev', '/media', '/mnt', '/net', '/proc', '/selinux', '/sys']

# Tests using the caplog fixture fail with python 2.6
IS_PY26 = sys.version_info < (2, 7)
PY26_SKIP_TEST_REASON = "pytest caplog fixture doesn't work in python 2.6"

# Various patch targets
LOGGER_TARGET = "insights.client.apps.malware_detection.logger"
LOAD_CONFIG_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._load_config"
FIND_YARA_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._find_yara"
GET_RULES_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._get_rules"
BUILD_YARA_COMMAND_TARGET = "insights.client.apps.malware_detection.MalwareDetectionClient._build_yara_command"


@pytest.fixture
def create_test_files():
    # Write the test files to the temp directory
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    with open(TEMP_CONFIG_FILE, 'w') as tcf:
        tcf.write(DEFAULT_MALWARE_CONFIG)
    test_files = [(MATCHING_ENTITY_FILE, MATCHING_ENTITY_FILE_CONTENTS),
                  (ANOTHER_MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE_CONTENTS),
                  (TEST_RULE_FILE, TEST_RULE_FILE_CONTENTS)]
    for test_file, contents in test_files:
        if not os.path.exists(test_file):
            with open(test_file, 'w') as f:
                f.write(contents)
    yield
    for test_file, _ in test_files:
        os.remove(test_file)
    os.remove(TEMP_CONFIG_FILE)
    os.rmdir(TEMP_TEST_DIR)


class TestDefaultValues:
    def test_default_spec(self):
        # Read in the default malware spec and check its values
        manifest = yaml.safe_load(manifests['malware-detection'])
        content_type = content_types['malware-detection']
        assert content_type == "application/vnd.redhat.malware-detection.results+tgz"
        specs = manifest['plugins']['configs']
        for spec in ['mac_addresses', 'etc_machine_id', 'hostname', 'bios_uuid', 'machine_id', 'ip_addresses',
                     'subscription_manager_id']:
            assert {'enabled': True, 'name': 'insights.specs.default.DefaultSpecs.%s' % spec} in specs
            assert {'enabled': True, 'name': 'insights.specs.Specs.%s' % spec} in specs

    def test_default_options(self):
        # Read in the default malware_detection_config options and check their values
        assert CONFIG['yara_binary'] is None
        assert CONFIG['test_scan'] is True
        assert CONFIG['scan_filesystem'] is True
        assert CONFIG['scan_processes'] is False
        assert CONFIG['scan_only'] is None
        assert CONFIG['scan_since'] is None
        assert all([x in CONFIG['scan_exclude']
                    for x in ['/proc', '/sys', '/cgroup', '/selinux', '/net', '/mnt', '/media', '/dev']])
        assert CONFIG['exclude_network_filesystem_mountpoints'] is True

    @patch(BUILD_YARA_COMMAND_TARGET)
    @patch(GET_RULES_TARGET, return_value=RULES_FILE)
    @patch(FIND_YARA_TARGET, return_value=YARA)
    def test_running_default_options(self, yara, rules, cmd, create_test_files):
        # Try running malware-detection with the default options
        # With the default options, test_scan is true, so some of the option values will be changed for that and
        # will be different from those in the default config file.
        # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
        test_pid = str(os.getpid())
        # Use a real config file so scan_fsobjects will be populated properly
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == YARA
        assert mdc.rules_file == RULES_FILE
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True
        assert mdc.scan_fsobjects == [TEMP_CONFIG_FILE]
        assert mdc.scan_pids == [test_pid]
        assert mdc.scan_since_dict == {'timestamp': None}
        assert mdc.scan_exclude_list == []
        assert mdc.network_filesystem_mountpoints == []
        assert mdc.scan_timeout == 3600
        assert mdc.nice_value == 19


@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestFindYara:

    @patch.dict(os.environ)
    def test_find_yara_binary(self, conf, rules, cmd):
        # Testing finding yara
        os.environ['YARA_BINARY'] = '/bin/yara'
        with patch('os.path.isfile', return_value=True):
            with patch("insights.client.apps.malware_detection.call", return_value='4.1'):
                mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == '/bin/yara'
        cmd.assert_called()

    @patch.dict(os.environ)
    def test_missing_yara_binary(self, conf, rules, cmd):
        # Test yara_binary option with non-existent file
        os.environ['YARA_BINARY'] = '/bin/notyara'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        cmd.assert_not_called()

        # Test yara_binary option with non-yara file
        os.environ['YARA_BINARY'] = '/bin/ls'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        cmd.assert_not_called()

    @patch("insights.client.apps.malware_detection.call")  # mock call to 'yara --version'
    def test_invalid_yara_versions(self, yara_version, conf, rules, cmd):
        # Test checking the version of yara
        # Invalid versions of yara
        for version in ['4.0.99', '4']:
            yara_version.return_value = version
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        cmd.assert_not_called()  # We won't get to the build_yara_cmd method because we exit before its called

        # Valid versions of yara
        for version in ['4.1', '10.0.0']:
            yara_version.return_value = version
            mdc = MalwareDetectionClient(None)
            assert mdc.yara_binary
        cmd.assert_called()


# Use patch.object for something different :shrug:
@patch.object(InsightsConnection, 'get', return_value=Mock(status_code=200, content=b"Rule Content"))
@patch.object(InsightsConnection, 'get_proxies')
@patch.object(InsightsConnection, '_init_session', return_value=Mock())
@patch.object(MalwareDetectionClient, '_build_yara_command')
@patch.object(MalwareDetectionClient, '_find_yara', return_value=YARA)
@patch.object(MalwareDetectionClient, '_load_config', return_value=CONFIG)
class TestGetRules:
    """ Testing the _get_rules method """

    @patch.dict(os.environ, {'TEST_SCAN': 'true'})
    def test_get_regular_rules_location_urls(self, conf, yara, cmd, session, proxies, get):
        # Test the standard rules_location urls, depending on whether test rule or cert auth is set
        # Test with insights-config None, expect an error when trying to use the insights-config object
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        session.assert_not_called()

        # With default insights config and test scan true, expect to download test-rule.yar
        mdc = MalwareDetectionClient(InsightsConfig())
        assert mdc.rules_location == "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
        assert mdc.rules_file.startswith('/tmp')  # rules will be saved into a temp file
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/test-rule.yar")

        # With authmethod=CERT, expect 'cert.' to be prefixed to the url
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar")

        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='BASIC'))
        assert mdc.rules_location == "https://console.redhat.com/api/malware-detection/v1/signatures.yar"
        get.assert_called_with("https://console.redhat.com/api/malware-detection/v1/signatures.yar")

        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        get.assert_called_with("https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar")

    @patch.dict(os.environ, {'TEST_SCAN': 'true', 'RULES_LOCATION': 'console.redhat.com/rules.yar'})
    def test_get_irregular_rules_location_urls(self, conf, yara, cmd, session, proxies, get):
        # Non-standard rules URLS - without https:// at the start and not signatures.yar
        # test-scan true and BASIC auth by default expect test-rule.yar and no 'cert.' in URL
        mdc = MalwareDetectionClient(InsightsConfig())
        assert mdc.rules_location == "https://console.redhat.com/test-rule.yar"
        get.assert_called_with("https://console.redhat.com/test-rule.yar")

        # test-scan false and CERT auth - expect 'cert.' prefixed to the URL and not test-rule.yar
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(InsightsConfig(authmethod='CERT'))
        assert mdc.rules_location == "https://cert.console.redhat.com/rules.yar"
        get.assert_called_with("https://cert.console.redhat.com/rules.yar")

    @patch.dict(os.environ, {'TEST_SCAN': 'false', 'RULES_LOCATION': 'http://localhost/rules.yar'})
    @patch(LOGGER_TARGET)
    def test_download_failures(self, logger, conf, yara, cmd, session, proxies, get):
        from requests.exceptions import ConnectionError, Timeout
        # Test various problems downloading rules
        # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
        get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        logger.error.assert_called_with("%s %s: %s", 404, "Not found", "Nup")
        assert get.call_count == 1

        # Test other errors downloading rules from the backend - these are more likely to occur
        get.side_effect = [ConnectionError("Couldn't connect"), Timeout("Timeout")]
        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        logger.error.assert_called_with("Unable to download rules from %s: %s",
                                        os.environ['RULES_LOCATION'], "Couldn't connect")
        assert get.call_count == 2

        with pytest.raises(SystemExit):
            MalwareDetectionClient(InsightsConfig())
        logger.error.assert_called_with("Unable to download rules from %s: %s",
                                        os.environ['RULES_LOCATION'], "Timeout")
        assert get.call_count == 3

    @patch.dict(os.environ, {'TEST_SCAN': 'true', 'RULES_LOCATION': '//console.redhat.com/rules.yar'})
    @patch("os.path.isfile", return_value=True)
    def test_get_rules_location_files(self, isfile, conf, yara, cmd, session, proxies, get):
        # Test using files for rules_location, esp irregular file names
        # rules_location that starts with a '/' is assumed to be a file, even if its a double '//'
        # Re-writing the rule to be test-rule.yar doesn't apply to local files
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == "//console.redhat.com/rules.yar"
        assert mdc.rules_file == "/console.redhat.com/rules.yar"
        get.assert_not_called()

        # Just to confirm the filename stays the same for regardless of test_rule value
        os.environ['TEST_SCAN'] = 'false'
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == "//console.redhat.com/rules.yar"
        assert mdc.rules_file == "/console.redhat.com/rules.yar"
        get.assert_not_called()


@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestBuildYaraCmd:

    @patch('os.path.getsize')
    def test_build_yara_command_success(self, size, conf, yara, rules):
        expected_yara_cmd = "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1}".format(YARA, RULES_FILE)
        size.return_value = 1
        # Use side_effect with 3 'call' values because build_yara_command calls 'call' 3 times:
        # ... 1 to get the type of the rules file; 2 to see if the rules files contains valid rules; 3 to call proc
        # Test with text rules file - file type is 'ascii'
        with patch("insights.client.apps.malware_detection.call", side_effect=['ascii', 'ok', '2']) as c:
            mdc = MalwareDetectionClient(None)
            assert c.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ''

        # Test with 'compiled' rules file - file type is 'Yara 3.x'
        with patch("insights.client.apps.malware_detection.call", side_effect=['Yara 3.X', 'ok', '2']) as c:
            mdc = MalwareDetectionClient(None)
            assert c.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ' -C'

        # Another test with compiled rules file - file type is 'data'
        with patch("insights.client.apps.malware_detection.call", side_effect=['data', 'ok', '2']) as c:
            mdc = MalwareDetectionClient(None)
            assert c.call_count == 3
        assert ' '.join(mdc.yara_cmd) == expected_yara_cmd % ' -C'

    @patch('os.path.getsize')
    def test_build_yara_command_fail(self, size, conf, yara, rules):
        # Test with empty rules file, ie file size is 0
        size.return_value = 0
        with patch("insights.client.apps.malware_detection.call", side_effect=['wtf?', 'yikes', '2']) as c:
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            c.assert_called_once()  # Only 1 call to 'call' before we exit

        # Test with empty rules files, ie the file type is 'empty'
        size.return_value = 1
        with patch("insights.client.apps.malware_detection.call", side_effect=['empty', 'yikes', '2']) as c:
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            c.assert_called_once()  # Only 1 call to 'call' before we exit

        # Test with 'invalid' rules file - raise CalledProcessError when running command
        with patch("insights.client.apps.malware_detection.call") as c:
            c.side_effect = ['yara', CalledProcessError(1, 'cmd', 'invalid'), '2']
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
            assert c.call_count == 2  # 2 calls to 'call' before we exit


@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch.dict(os.environ, {'TEST_SCAN': 'false'})
class TestMalwareDetectionOptions:

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    def test_running_modified_options(self, conf, yara, rules, cmd):
        # Disable test_scan and the mdc attribute values should mostly match what's in the config file
        mdc = MalwareDetectionClient(None)
        assert mdc.rules_file == RULES_FILE
        assert mdc.yara_binary == YARA
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []
        assert mdc.scan_since_dict == {'timestamp': None, 'datetime': None}
        assert all([d in mdc.scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    def test_scan_only_option(self, conf, yara, rules, cmd):
        # Test various combinations of scan_only and the scan_filesystem and scan_processes options
        # Firstly, test the default option values
        mdc = MalwareDetectionClient(None)
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []

        # Add scan_only for a process - expect to exit because we can't scan processes because do_process_scan is false
        os.environ['SCAN_ONLY'] = '1'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)

        # Enable process scanning and now the scan_only value should be used
        os.environ['SCAN_PROCESSES'] = 'true'
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == ['1']

        # Add directories and processes and expect all to be scanned
        os.environ['SCAN_ONLY'] = '1,/tmp'
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.scan_pids == ['1']

        # Disable filesystem scanning and only expect the process to be scanned
        os.environ['SCAN_FILESYSTEM'] = 'FALSE'
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == ['1']

        # Disable both filesystem and process scanning and expect an error as there is nothing to scan
        os.environ['SCAN_PROCESSES'] = 'FALSE'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)

    @patch(LOGGER_TARGET)
    def test_invalid_config_values(self, logger, yara, rules, cmd, create_test_files):
        # Check the malware client app behaves in a predictable way if the user specifies invalid option values
        # in the config file.  Some of these will fail yaml parsing, others will fail type checking

        # Invalid value for nice - fails casting to an integer
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: nineteen" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Problem setting configuration option %s: %s", "nice_value", ANY)
        yara.assert_called_once()  # It failed after the _find_yara method

        # Missing colon for nice_value option - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "nice_value 19\n" if line.startswith("nice_value") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, mixing single item and list items - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: 19\n" if line.startswith("nice_value") else line
            line = "scan_only: /bad\n- /bad" if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not a list item -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only:" if line.startswith("scan_only:") else line
            line = "/bad" if line.startswith("- /bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not enough spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "-/bad" if line.startswith("/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, using tabs instead of spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "\t- /bad" if line.startswith("-/bad") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            with pytest.raises(SystemExit):
                MalwareDetectionClient(None)
        logger.error.assert_called_with("Error encountered loading the malware-detection app config file %s:\n%s", TEMP_CONFIG_FILE, ANY)
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

    # Patch the os.environ dict so all the changes are only temporary
    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch.dict(os.environ)
    def test_using_env_vars(self, conf, yara, rules, cmd):
        # Set certain option values via environment variables
        env_var_list = [('RULES_LOCATION', RULES_FILE), ('TEST_SCAN', 'false'),
                        ('SCAN_FILESYSTEM', 'YES'), ('SCAN_PROCESSES', 'hello'),  # will be interpreted as false
                        ('SCAN_ONLY', '/tmp'), ('SCAN_EXCLUDE', '/tmp'),
                        ('SCAN_SINCE', '2'), ('SCAN_TIMEOUT', '1800'), ('CPU_THREAD_LIMIT', '1')]
        for key, value in env_var_list:
            os.environ[key] = value

        mdc = MalwareDetectionClient(None)
        assert mdc.yara_binary == YARA
        assert mdc.rules_file == RULES_FILE
        assert mdc.test_scan is False
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == ['/tmp']
        assert mdc.scan_exclude_list == ['/tmp']
        assert mdc.scan_since_dict['timestamp'] < time.time() - (2 * 86400)
        assert mdc.scan_timeout == 1800
        # Not env vars, but just checking they have the expected values
        assert mdc.nice_value == 19
        assert mdc.cpu_thread_limit == 1

        # Start a filesystem scan and expect scan_only and scan_exclude to cancel each other out
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert exc_info.value.code == constants.sig_kill_bad

        # Test when SCAN_ONLY and SCAN_EXCLUDE values are comma separated
        for key, value in [('SCAN_ONLY', '/tmp,/,/var/tmp'),
                           ('SCAN_EXCLUDE', '/home,/,/fred,barney')]:
            os.environ[key] = value
        mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/tmp', '/', '/var/tmp']
        assert mdc.scan_exclude_list == ['/home', '/']
        assert mdc.test_scan is False

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch(LOGGER_TARGET)
    @patch.dict(os.environ, {'TEST_SCAN': 'false', 'NICE_VALUE': 'nineteen', 'SCAN_SINCE': 'blast'})
    def test_invalid_env_vars(self, logger, conf, yara, rules, cmd):
        # NICE_VALUE and SCAN_SINCE have invalid values
        # First time through the NICE_VALUE should generate an error
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        logger.error.assert_called_with("Problem parsing environment variable %s: %s", "NICE_VALUE", ANY)

        # Set NICE_VALUE to proper value to avoid it giving an error this time.
        # Only SCAN_SINCE should generate an error
        os.environ['NICE_VALUE'] = '19'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(None)
        logger.error.assert_called_with("Unknown value '%s' for scan_since option.  "
                                        "Valid values are integers >= 1 and 'last'", "blast")

    def test_scan_only_root(self, yara, rules, cmd, create_test_files):
        # Nothing special about root when parsing the scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        scan_only = '/'
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "scan_only: %s" % scan_only if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == [scan_only]
        # This is called by scan_filesystem to convert '/' into its top level subdirectories
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

        # Multiple directories aren't consolidated until later
        scan_only = ['/', '/tmp', '/home']
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "scan_only: %s" % scan_only if line.startswith("scan_only:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == scan_only
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert '/' not in list(scan_dict.keys())

    def test_scan_exclude_root(self, yara, rules, cmd, create_test_files):
        # Nothing special about root when parsing the scan_exclude option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # Add '/' to the list of scan_exclude items.  Add it directly after the scan_exclude: line
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert '/' in mdc.scan_exclude_list
        # When scan_filesystem is run, '/' will be expanded into toplevel directories that cancel out everything
        with pytest.raises(SystemExit) as exc_info:
            process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                          exclude_items=mdc.scan_exclude_list)
        assert exc_info.value.code == constants.sig_kill_bad

    def test_scan_only_scan_exclude_nullify(self, yara, rules, cmd, create_test_files):
        # Testing scan_only and scan_exclude items such that the exclude items nullify all the scan_only items
        # In which case there will be nothing to scan
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "\n- /var/log\n- /usr/lib/systemd\n- /tmp" if line.startswith("scan_only:") else line
            line = line + "\n- /tmp/\n- /usr/lib/\n- /var/log" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.scan_exclude_list for x in ['/tmp', '/usr/lib', '/var/log']])
        # The exclude list covers all the items to be scanned, thus there is nothing to scan
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert exc_info.value.code == constants.sig_kill_bad

        # Both scan_only and scan_exclude contain root
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- /" if line.startswith("scan_only:") else line
            line = line + "\n- /" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/', '/var/log', '/usr/lib/systemd', '/tmp']
        assert all([x in mdc.scan_exclude_list for x in ['/', '/tmp', '/usr/lib', '/var/log']])
        # Because both lists contain /, they will cancel each other out and there is nothing to scan
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert exc_info.value.code == constants.sig_kill_bad


@patch(BUILD_YARA_COMMAND_TARGET)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOGGER_TARGET)
class TestScanning:

    def test_scan_rules_file_with_extra_slashes(self, logger, yara, cmd, create_test_files):
        # Test scanning RULES_FILE with an extra slash only in the rules_location one
        # Even with the extra slashes in the rules_location there will be rules matched
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE.replace('/', '//') if line.startswith('---') else line
            line = "scan_only: %s" % TEST_RULE_FILE if line.startswith("scan_only:") else line
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.rules_location == TEST_RULE_FILE.replace('/', '//')
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.scan_fsobjects == [TEST_RULE_FILE]
        with patch("insights.client.apps.malware_detection.call") as c:
            # Mock the scan match data from yara
            c.return_value = "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client" % TEST_RULE_FILE
            mdc.scan_filesystem()
        rule_match = mdc.host_scan['TEST_RedHatInsightsMalwareDetection']
        assert rule_match[0]['source'] == TEST_RULE_FILE
        assert rule_match[0]['string_data'] == "Malware Detection Client"
        assert rule_match[0]['string_identifier'] == '$re1'
        assert rule_match[0]['string_offset'] == 74
        logger.info.assert_any_call("Matched rule %s in %s %s", "TEST_RedHatInsightsMalwareDetection", "file", TEST_RULE_FILE)

    def test_scan_root_with_extra_slashes(self, logger, yara, cmd, create_test_files):
        # Testing we handle the situation where items in scan_only & scan_exclude contain multiple slashes
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = line + "rules_location: %s\n" % TEST_RULE_FILE if line.startswith('---') else line
            line = line + "- //\n" if line.startswith("scan_only:") else line
            line = line + "- //\n" if line.startswith("scan_exclude:") else line
            print(line)
        with patch("insights.client.apps.malware_detection.MALWARE_CONFIG_FILE", TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(None)
        assert mdc.scan_fsobjects == ['/']
        assert '/' in mdc.scan_exclude_list
        # Chaos monkey - modify scan_fsobjects and scan_exclude_list AFTER they have been verified
        # Assert that they still work and cancel each other out
        mdc.scan_fsobjects = ['//']
        mdc.scan_exclude_list = ['//']
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        logger.error.assert_called_with("No items to scan because the specified exclude items cancel them out")
        assert exc_info.value.code == constants.sig_kill_bad


class TestIncludeExcludeMethods:

    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list)
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/usr/lib')
        assert sorted(parent_dir_list) == ['/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/var')
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = ['/path/to/some/item/child', '/path/to/another/item', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = ['/var/lib64', '/home/bob', '/var/lib/docker', '/home/bob', '/var/lib',
                 '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child', '/var/lib63/im ok', '/var/lib64/im not']
        assert remove_child_items(items) == ['/home/bob', '/home/bobby-droptables', '/var/lib',
                                             '/var/lib63/im ok', '/var/lib64']

        # /path is common to both so that will be all that is returned
        items = ['/path/to/another/item', '/path/to/some/item', '/path']
        assert remove_child_items(items) == ['/path']

        # The root directory will always win
        items = ['/path/to/another/item', '/path/to/some/item', '/']
        assert remove_child_items(items) == ['/']

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ['/path/to/another/item', '', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

    def test_remove_included_excluded_items(self):
        include_items = ['/home/bob', '/tmp', '/var/www/html']
        exclude_items = ['/home/bo', '/home/bob/exclude', '/home/bobby', '/temp', '/var/www']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/home/bob', '/tmp']

        # Some fairly random lists similar to before
        include_items = ['/var/lib64/docker', r'/home/bob/this\ is\ bobs/child', '/var/lib/docker', '/home/bob',
                         '/var/lib', '/usr']
        exclude_items = ['/var/lib/docker2', '/home/bob', '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child',
                         '/var/lib63/im ok', '/var/lib64/im not', '/boot']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/usr', '/var/lib', '/var/lib64/docker']

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    def test_process_include_items(self):
        # Call process_include_items with variously populated lists
        # Add some valid entries to include_items list, esp subdirectories
        include_items = ['/etc/pam.d', '/tmp', '/var/log/']
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/pam.d', '/tmp', '/var/log']

        # Add some more subdirectories
        include_items.extend(['/etc/cron.d', '/tmp', '/var/lib/'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/cron.d', '/etc/pam.d', '/tmp', '/var/lib', '/var/log']

        # Add some top level directories to override the subdirectories
        include_items.extend(['/etc', '/var'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries that will get ignored
        include_items.extend(['..', '/var/run', '/missing'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory (/) which will override all the other entries
        include_items.append('/')
        processed_items = process_include_items(include_items)
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    def test_process_exclude_items(self):
        # Call process_exclude_items with variously populated lists
        # No entries to exclude
        processed_items = process_exclude_items()
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ['/etc/ssh', '/tmp', '/var/run/']
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/ssh', '/tmp', '/var/run']

        # Add some more subdirectories
        exclude_items.extend(['/etc/cron.d', '/tmp', '/var/lock/'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/cron.d', '/etc/ssh', '/tmp', '/var/lock', '/var/run']

        # Add some top level directories to override the subdirectories
        exclude_items.extend(['/etc', '/var'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries to exclude items, which will be ignored
        exclude_items.extend(['..', '/missing'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory, which will expand to all top level directories
        exclude_items.append('/')
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == get_toplevel_dirs()


@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {'TEST_SCAN': 'false'})
class TestIncludeExcludeProcessing:

    def test_process_include_exclude_items_simple(self, conf, yara, rules, cmd):
        # Test the process_include_exclude_items function with simple modified include and exclude items
        # Simple in that the include and exclude files are modified in such a way that
        # directory listings aren't required get the list of included files
        # Add a single toplevel directory to the include file - expect only a single directory to scan
        mdc = MalwareDetectionClient(None)
        mdc.scan_fsobjects = ['/etc']
        mdc.scan_exclude_list = []
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']
        assert 'include' not in scan_dict['/etc']
        assert 'exclude' not in scan_dict['/etc']

        # Add some extra subdirectories to scan
        mdc.scan_fsobjects.extend(['/var/lib', '/var/log'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(list(scan_dict['/var']['include'])) == ['/var/lib', '/var/log']
        assert 'exclude' not in scan_dict['/var']

        # Add some extra directories to exclude that won't impact the already included directories
        mdc.scan_exclude_list.extend(['/tmp', '/var/run'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(scan_dict['/var']['include']) == ['/var/lib', '/var/log']
        assert scan_dict['/var']['exclude']['items'] == ['/var/run']

        # Exclude /var which will remove it from the list of directories to scan
        mdc.scan_exclude_list.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']

        # Exclude /etc which means there will be no directories to scan
        mdc.scan_exclude_list.append('/etc')
        with pytest.raises(SystemExit) as exc_info:
            process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                          exclude_items=mdc.scan_exclude_list)
        assert exc_info.value.code == constants.sig_kill_bad

    def test_process_include_exclude_items_complex(self, conf, yara, rules, cmd):
        # Test the process function with modified include and exclude files that will require more complex
        # processing to generate the list of items to be scanned
        # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
        # We don't need to list the contents of the /var directory
        mdc = MalwareDetectionClient(None)
        mdc.scan_fsobjects = ['/var/lib', '/var/log']
        mdc.scan_exclude_list = ['/var/lib/systemd', '/var/lib/misc/', '/var/log/wtmp']

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        # The exclude items shouldn't be in the include items
        # Nor should other items that aren't in the explicitly included items
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp',
                              '/var/cache', '/var/lib', '/var/log', '/var/tmp', '/tmp']])
        # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
        # but not the excluded items, eg /var/log/wtmp
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/lib/xkb', '/var/lib/dbus', '/var/log/btmp', '/var/log/lastlog']])

        # Change the include directory to /var
        # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
        # Because now we have to list the contents of the /var and /var/lib directories
        mdc.scan_fsobjects.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp', '/var/lib', '/var/log', '/tmp']])
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/cache', '/var/tmp', '/var/lib/xkb', '/var/lib/dbus',
                              '/var/log/btmp', '/var/log/lastlog']])

    @pytest.mark.skipif(not os.path.exists('/usr/local/libexec'), reason="No /usr/local/libexec")
    def test_process_include_exclude_items_similar_names(self, conf, yara, rules, cmd):
        # Now test including/excluding items that have similar names, eg /usr/local/lib and /usr/local/libexec
        # /usr/local has sub directories /usr/local/lib and /usr/local/libexec (ie similar names)
        # If we exclude /usr/local/lib then /usr/local/libexec should still be included
        mdc = MalwareDetectionClient(None)
        mdc.scan_fsobjects = ['/usr/local']
        mdc.scan_exclude_list.append('/usr/local/lib')

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert list(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib']
        # Ensure /usr/local/lib is NOT in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib']])
        # But ensure /usr/local/libexec IS in the list of items to scan
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share', '/usr/local/libexec']])

        # Add /usr/local/libexec as an item to exclude and ensure both /usr/local/lib and libexec are excluded now
        mdc.scan_exclude_list.append('/usr/local/libexec')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib', '/usr/local/libexec']
        # Ensure /usr/local/lib and /usr/local/libexec are both not in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib', '/usr/local/libexec']])
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share']])

        # Test including /usr/local/lib and excluding an item from it
        # Confirm that only items from /usr/local/lib are included and NOT from any other directory
        usr_local_lib = sorted(filter(lambda x: not os.path.islink(x),
                                      map(lambda x: '/usr/local/lib/' + x, os.listdir('/usr/local/lib'))))
        assert len(usr_local_lib) > 2
        excluded_item1 = usr_local_lib[0]
        excluded_item2 = usr_local_lib[1]
        mdc.scan_fsobjects = ['/usr/local/lib']
        mdc.scan_exclude_list = [excluded_item1, excluded_item2]
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == [excluded_item1, excluded_item2]
        # Ensure only /usr/local/lib items are included (except the first 2 in the directory)
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/local', '/usr/local/lib', '/usr/local/libexec',
                              excluded_item1, excluded_item2]])
        assert all([x in scan_dict['/usr']['include'] for x in usr_local_lib[2:]])


@patch(BUILD_YARA_COMMAND_TARGET)
@patch(GET_RULES_TARGET, return_value=RULES_FILE)
@patch(FIND_YARA_TARGET, return_value=YARA)
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {'TEST_SCAN': 'false'})
class TestParseScanOutput:

    def test_contrived_scan_output(self, conf, yara, rules, cmd):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
        mdc = MalwareDetectionClient(None)
        mdc.add_metadata = False
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        assert mdc.matches == 8

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        assert len(rule_match) == 1
        assert 'e-r-r-o-r s-c-a-n-n-i-n-g' in rule_match[0]['source']
        assert rule_match[0]['string_data'] == "matches 'this' rule"
        assert rule_match[0]['string_identifier'] == '$match'
        assert rule_match[0]['string_offset'] == 291

        # 14 matching strings for 'Rule'
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 14
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == 'string match in the file "matching_entity"'
        assert rule_match[0]['string_identifier'] == '$match0'
        assert rule_match[0]['string_offset'] == 21
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "another string match in matching_entity"
        assert rule_match[1]['string_identifier'] == '$match1'
        assert rule_match[1]['string_offset'] == 83
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == 'string with different types of quotes \'here\' and "here"'
        assert rule_match[2]['string_identifier'] == '$match2'
        assert rule_match[2]['string_offset'] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[3]['string_identifier'] == '$match3'
        assert rule_match[3]['string_offset'] == 2
        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains ="
        assert rule_match[4]['string_identifier'] == '$grep1'
        assert rule_match[4]['string_offset'] == 97
        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == "contains .+"
        assert rule_match[6]['string_identifier'] == '$grep2'
        assert rule_match[6]['string_offset'] == 153
        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_data'] == 'contains "'
        assert rule_match[8]['string_identifier'] == '$grep3'
        assert rule_match[8]['string_offset'] == 213
        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_data'] == "contains '"
        assert rule_match[9]['string_identifier'] == '$grep4'
        assert rule_match[9]['string_offset'] == 241
        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_data'] == 'contains ()[]'
        assert rule_match[10]['string_identifier'] == '$grep5'
        assert rule_match[10]['string_offset'] == 269
        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_data'] == 'contains {'
        assert rule_match[11]['string_identifier'] == '$grep6'
        assert rule_match[11]['string_offset'] == 299
        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_data'] == 'contains ^$'
        assert rule_match[12]['string_identifier'] == '$grep7'
        assert rule_match[12]['string_offset'] == 327

        assert rule_match[13]['source'].startswith('matching_entity_3')
        assert rule_match[13]['string_data'] == ''
        assert rule_match[13]['string_identifier'] == ''
        assert rule_match[13]['string_offset'] == -1

        # 4 matching strings for 'another_matching_rule'
        rule_match = mdc.host_scan['another_matching_rule']
        assert len(rule_match) == 4
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        assert rule_match[2]['string_data'] == '#!/bin/sh'
        assert rule_match[2]['string_identifier'] == '$s0'
        assert rule_match[2]['string_offset'] == 60783814
        assert rule_match[3]['source'] == '1234567'
        assert rule_match[3]['string_data'] == '#!/bin/sh'
        assert rule_match[3]['string_identifier'] == '$s0'
        assert rule_match[3]['string_offset'] == 0

        rule_match = mdc.host_scan['Iyamtho']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == " yep"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        rule_match = mdc.host_scan['n_m3_t00']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == "damn   straight"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

    def test_contrived_scan_output_metadata(self, conf, yara, rules, cmd, create_test_files):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_file_location with any rule, but its not relevant for the tests
        mdc = MalwareDetectionClient(None)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # Matches and metadata for MATCHING_ENTITY_FILE
        rule_match = mdc.host_scan['Rule']
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_offset'] == 21
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 1
        assert metadata['line'] == urlencode('This line contains a string match in the file "matching_entity"')

        # Testing displaying long lines
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_offset'] == 83
        metadata = rule_match[1]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 2
        assert metadata['line'] == urlencode('This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o...')

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_offset'] == 230
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode("""And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough""")

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_offset'] == 2
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_offset'] == 97
        metadata = rule_match[4]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_offset'] == 123
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 8
        assert metadata['line'] == urlencode("This line contains = char too")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_offset'] == 153
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_offset'] == 213
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_offset'] == 241
        metadata = rule_match[9]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_offset'] == 269
        metadata = rule_match[10]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_offset'] == 299
        metadata = rule_match[11]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_offset'] == 327
        metadata = rule_match[12]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert rule_match[13]['source'] == "matching_entity_3, but without any string matches - yes that's ok"
        metadata = rule_match[13]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.host_scan['another_matching_rule']
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]['source'] == '1234567'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert all([key not in ['process_name', 'file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_random_output(self, conf, yara, rules, cmd):
        mdc = MalwareDetectionClient(None)
        mdc.parse_scan_output(RANDOM_OUTPUT)
        assert mdc.matches == 2
        rule_match = mdc.host_scan['Lorem']
        assert rule_match[0]['source'].startswith('ipsum dolor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1
        rule_match = mdc.host_scan['Dictum']
        assert rule_match[0]['source'].startswith('at tempor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1


MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, 'matching_entity')
MATCHING_ENTITY_FILE_CONTENTS = """
This line contains a string match in the file "matching_entity"
This line contains another string match in matching_entity and it is very long for testing the ellipses that are added onto very long lines

And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough
""".lstrip()

ANOTHER_MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, 'another matching_entity')
ANOTHER_MATCHING_ENTITY_FILE_CONTENTS = """


string match containing error scanning but it's ok because its not in a rule line



This line contains = char
This line contains = char too
This line contains .+ chars
This line contains .+ chars too
This line contains "" chars
This line contains '' chars
This line contains ()[] chars
This line contains {} chars
This line contains ^$ chars
This line contains ^$ chars too
The previous line and this one too are ignored as they are beyond the default 10 string match limit
"""[1:]  # Ignore first newline char otherwise it changes the md5sum

TEST_RULE_FILE = os.path.join(TEMP_TEST_DIR, 'test-rule.yar')
TEST_RULE_FILE_CONTENTS = """
rule TEST_RedHatInsightsMalwareDetection
// Verifies the Red Hat Insights Malware Detection Client app is present on the system
{
    strings:
        $re1 = /Malware ?Detection ?Client/
    condition:
        $re1
}
""".lstrip()

CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
""" % (MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE)

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""

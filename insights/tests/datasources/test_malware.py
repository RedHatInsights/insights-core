import os
import yaml
import pytest
from mock.mock import patch
try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from .malware_misc import utils
from insights.specs.malware import (
    MalwareDetectionClient, logger, DEFAULT_MALWARE_CONFIG, MIN_YARA_VERSION
)
from insights.specs.app_default_manifests import default_manifests
from insights.util.subproc import call, CalledProcessError

# Does the system already have yara installed on it?
# Run this before modifying the system search path
EXISTING_YARA = None
try:
    EXISTING_YARA = str(call('which yara')).strip()
except CalledProcessError:
    pass

# Miscellanous extra files used by the malware tests are in the malware_misc directory
MISC_DIR = utils.find_misc_dir('malware_misc')

# Location of yara binary used for testing and its libraries
# Add MISC_DIR to the path so the system automatically finds the yara binary in there
YARA_BINARY = os.path.join(MISC_DIR, 'yara')
os.environ['LD_LIBRARY_PATH'] = MISC_DIR
WITHOUT_MISC_ENV_PATH = os.environ['PATH']
WITH_MISC_ENV_PATH = MISC_DIR + ':' + WITHOUT_MISC_ENV_PATH
os.environ['PATH'] = WITH_MISC_ENV_PATH

# Location of this test file (might be a better way of determining this!)
MALWARE_TEST_FILE = os.path.normpath(os.path.join(MISC_DIR, '..', 'test_malware.py'))

# Miscellaneous rules files and other text files used in the tests
COMPILED_RULES_FILE = os.path.join(MISC_DIR, 'rules_compiled.yar')
TEST_RULE_FILE = os.path.join(MISC_DIR, 'TEST_RedHatInsightsMalwareDetection.yar')
METADATA_TEST_RULE_FILE = os.path.join(MISC_DIR, 'rule_metadata_test.yar')
RULE_RULE_FILE = os.path.join(MISC_DIR, 'rule rule.yar')
MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'matching_entity')
ANOTHER_MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'another matching_entity')


def get_malware_options(rules_location=None, scan_only=None, test_scan=False, yara_binary=None):
    malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
    malopts['yara_binary'] = yara_binary
    malopts['rules_location'] = rules_location
    malopts['scan_only'] = scan_only
    malopts['test_scan'] = test_scan
    return malopts


class TestMalwareDetectionClient:

    def test_default_malware_spec(self):
        # Read in the default malware spec and check its values
        malware_manifest = yaml.safe_load(default_manifests['malware'])
        assert malware_manifest['content_type'] == "application/vnd.redhat.malware.results+tgz"
        specs = malware_manifest['plugins']['configs']
        for spec in ['mac_addresses', 'etc_machine_id', 'hostname', 'bios_uuid', 'machine_id', 'ip_addresses',
                     'subscription_manager_id']:
            assert {'enabled': True, 'name': 'insights.specs.default.DefaultSpecs.%s' % spec} in specs
            assert {'enabled': True, 'name': 'insights.specs.Specs.%s' % spec} in specs

    def test_default_malware_options(self):
        # Read in the default malware options and check its values
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
        assert malopts['rules_location'] == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        assert malopts['yara_binary'] is None
        assert malopts['test_scan'] is True
        assert malopts['scan_filesystem'] is True
        assert malopts['scan_processes'] is False
        assert malopts['scan_only'] is None
        assert malopts['scan_since'] is None
        assert malopts['scan_exclude'] == ['/proc', '/sys', '/cgroup', '/selinux', '/net', '/mnt', '/media', '/dev']
        assert malopts['exclude_network_filesystems'] is True

    def test_running_default_options(self, caplog):
        # However, with the default malware options, test_scan is true, so some of the options values
        # will be different from those of the default options.
        # For example, do_filesystem_scan is False and do_process_scan is True
        logger.setLevel('DEBUG')
        test_pid = str(os.getpid())
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)

        with patch("insights.specs.malware.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE):
            mdc = MalwareDetectionClient(None, malopts)
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        assert mdc.yara_binary == yara
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == [test_pid]
        assert mdc.scan_since_dict == {'timestamp': None}
        assert mdc.scan_exclude_list == []
        assert mdc.network_filesystem_mountpoints == []
        yara_cmd = ' '.join(mdc.yara_cmd)
        assert yara_cmd == "nice -n 19 %s -s -N -a 3600 -p 2 -r -f %s" % (yara, mdc.rules_file)
        assert "Performing a test scan of the current process (PID '%s')" % test_pid in caplog.text
        assert "Using yara binary: %s" % yara in caplog.text

        # Do a scan but can't guarantee the test rule will find a match in this testing process
        mdc.scan_processes()
        assert "Scanning process '%s' ..." % test_pid in caplog.text
        assert "Matched rule TEST_RedHatInsightsMalwareDetection in process %s" % test_pid not in caplog.text

    def test_running_modified_options(self, caplog):
        # Disable test_scan and the malware options should mostly be same as what's in the mdc object
        logger.setLevel('INFO')
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
        malopts['test_scan'] = False

        with patch("insights.specs.malware.MalwareDetectionClient._get_rules", return_value=COMPILED_RULES_FILE):
            mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_file == COMPILED_RULES_FILE
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        assert mdc.yara_binary == yara
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []
        assert mdc.scan_since_dict == {'timestamp': None, 'datetime': None}
        assert all([d in mdc.scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])

    @patch("insights.specs.malware.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    def test_successful_find_yara_binary(self, rules, caplog):
        logger.setLevel('DEBUG')
        # Find yara using the system search path
        malopts = get_malware_options()
        mdc = MalwareDetectionClient(None, malopts)
        assert "Using yara binary: %s" % mdc.yara_binary in caplog.text

        # Finding yara binary by using the yara_binary option
        caplog.clear()
        malopts = get_malware_options(yara_binary=YARA_BINARY)
        MalwareDetectionClient(None, malopts)
        assert "Using specified yara binary: %s" % YARA_BINARY in caplog.text

    def test_failing_find_yara_binary(self, caplog):
        # Testing failing to find yara
        malopts = get_malware_options()

        # Test with no yara found on system.  Removing the environment search path to malware_misc
        # Unless yara is otherwise installed on the system.  If so, then skip this test
        if not EXISTING_YARA:
            # Couldn't otherwise find yara on the system, so thunderbirds are go
            os.environ['PATH'] = WITHOUT_MISC_ENV_PATH
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(None, malopts)
            assert "Couldn't find yara.  Please ensure the yara package is installed" in caplog.text
            assert exc_info.value.code == 101
            os.environ['PATH'] = WITH_MISC_ENV_PATH

        # Test yara_binary option with non-existent file
        caplog.clear()
        yara_binary = '/bin/notyara'
        malopts['yara_binary'] = yara_binary
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Couldn't find the specified yara binary %s.  Please check it exists" % yara_binary in caplog.text
        assert exc_info.value.code == 101

        # Test yara_binary option with non-yara file
        yara_binary = '/bin/ls'
        malopts['yara_binary'] = yara_binary
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Error getting the version of the specified yara binary %s" % yara_binary in caplog.text
        assert exc_info.value.code == 101

    @patch("insights.specs.malware.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    @patch("insights.specs.malware.call")
    def test_find_yara_version(self, call, rules, caplog):
        # Test checking the version of yara
        malopts = get_malware_options()

        # Invalid versions of yara
        for version in ['4.0.2', '4']:
            call.return_value = version
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(None, malopts)
            assert "Found yara version %s, but Insights Malware requires version >= %s" % (version, MIN_YARA_VERSION)\
                   in caplog.text
            assert exc_info.value.code == 101
            caplog.clear()

        # Valid versions of yara
        for version in ['4.1', '10.0.0']:
            call.return_value = version
            with patch("insights.specs.malware.MalwareDetectionClient._build_yara_command", return_value="yara"):
                mdc = MalwareDetectionClient(None, malopts)
            assert mdc.yara_binary

    def test_scanning_compiled_rules_file(self, caplog):
        # Scan the compiled rules file ... with the compiled rules file
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()
        assert "Scan only the specified filesystem item: ['%s']" % COMPILED_RULES_FILE in caplog.text
        assert "Using specified rules file: %s" % COMPILED_RULES_FILE in caplog.text
        assert "Scanning files in '%s' ..." % utils.tld(COMPILED_RULES_FILE) in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text
        # Matched 2 rules
        assert mdc.matches == 2
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        assert string_matches == 3

        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] <= 544

        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'sent"'
        assert rule_match[0]['string_identifier'] == '$string1'
        assert rule_match[0]['string_offset'] == 601
        assert rule_match[1]['source'] == COMPILED_RULES_FILE
        assert rule_match[1]['string_data'] == 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00'
        assert rule_match[1]['string_identifier'] == '$string2'
        assert rule_match[1]['string_offset'] == 616
        assert mdc.scan_processes() is False

    def test_scanning_malware_test_file(self, caplog):
        # Scan this test_malware.py file
        # Expect to match both rules in COMPILED_RULES_FILE, but only 1 string match per rule, due to using
        #   yara -f/fast scan option which stops searching for a matching string after finding it once
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=MALWARE_TEST_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.string_match_limit == 10

        mdc.scan_filesystem()
        assert mdc.matches == 2  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1  # But only 1 string match per rule
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        # First match is near the start of the file
        assert rule_match[0]['string_offset'] < 500

        # Increase string_match_limit and scan again.
        # Expect to find just one string match per rule again because of the yara fast scan option
        # (Should we still bother using string_match_limit now that we use fast scan option?)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1

    def test_scan_only_root(self, caplog):
        # Nothing special about root when parsing the scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # TODO: add extra tests when performing scan_filesystem to see root being broken into subdirectories
        logger.setLevel('INFO')
        scan_only = '/'
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=scan_only)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == [scan_only]
        assert "Scan only the specified filesystem item: ['%s']" % scan_only in caplog.text

        # Multiple directories aren't consolidated until later
        caplog.clear()
        scan_only = ['/', '/tmp', '/home']
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=scan_only)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == scan_only
        assert "Scan only the specified filesystem items: %s" % scan_only in caplog.text

    def test_rules_file_types(self, caplog):
        # Testing if the rules file is compiled or not
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert '-C' not in mdc.yara_cmd
        assert 'Compiled rules: False' in caplog.text

        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert '-C' in mdc.yara_cmd
        assert 'Compiled rules: True' in caplog.text

    def test_bad_rules_files(self, caplog):
        # Tests with non-rules/problematic files
        malopts = get_malware_options(rules_location=YARA_BINARY)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Unable to use rules file %s" % YARA_BINARY in caplog.text
        assert exc_info.value.code == 101

        caplog.clear()
        malopts = get_malware_options(rules_location=MISC_DIR)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Couldn't find specified rules file: %s" % MISC_DIR in caplog.text
        assert exc_info.value.code == 101

        caplog.clear()
        empty_file = os.path.join(MISC_DIR, '__init__.py')
        malopts = get_malware_options(rules_location=empty_file)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Rules file %s is empty" % empty_file in caplog.text
        assert exc_info.value.code == 101

    def test_files_with_extra_slashes(self, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '//'),
                                      scan_only=MISC_DIR.replace('/', '//'))
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR]
        mdc.scan_filesystem()
        assert "Matched rule MalwareDetectionClientRule in file %s" % TEST_RULE_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

        # Test scanning the tests directory again, but with an extra slash only in the RULES_COMPILED path
        # Even with the extra slash in RULES_COMPILED, there should will rules matched in RULES_COMPILED
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '//'),
                                      scan_only=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [COMPILED_RULES_FILE]
        mdc.scan_filesystem()
        # WILL match the rules file this time because we ARE specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text

        # For completeness (silliness?), try with even more slashes in the file names
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '////'),
                                      scan_only=MISC_DIR.replace('/', '///'))
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '////')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR]
        mdc.scan_filesystem()
        assert "Matched rule MalwareDetectionClientRule in file %s" % TEST_RULE_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

        # Chaos monkey! - add extra slashes to rules_file and scan_fsobjects AFTER they have been verified
        # This is a contrived test and shouldn't happen in normal code flow but done to make sure malware behaves well
        # Testing passing double slashes directly into mdc just before mdc.scan_filesystems, eg
        # mdc.scan_fsobjects = ['//home//bob']; mdc.scan_filesystem()
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=MISC_DIR)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR]
        # Modify rules_file and scan_fsobjects AFTER they have been verified
        mdc.rules_file = COMPILED_RULES_FILE.replace('/', '//')
        mdc.scan_fsobjects = [MISC_DIR.replace('/', '//')]
        mdc.scan_filesystem()
        # The file paths will have an extra / at the start of them (because os.path.normpath doesn't remove it)
        assert "Scanning files in '//" in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file /%s" % TEST_RULE_FILE in caplog.text

    def test_scanning_pytest_process(self, caplog):
        # Scan the python pytest process whilst its running the tests
        logger.setLevel('INFO')
        test_pid = str(os.getpid())
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=int(test_pid))
        mdc = MalwareDetectionClient(None, malopts)
        assert "Scan only the specified process ID: ['%s']" % test_pid in caplog.text
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True

        mdc.scan_processes()
        assert "Scanning process '%s' ..." % test_pid in caplog.text
        assert "Matched rule MalwareDetectionClientRule in process %s" % test_pid in caplog.text
        assert "Matched rule MiscellaneousStringsRule in process %s" % test_pid in caplog.text
        # Matches both rules in the PID
        assert mdc.matches == 2
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == test_pid
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] > 0
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'process'
        # The process running the tests should have any of these strings in its name
        assert any([s in metadata['process_name'] for s in ('python', 'pytest', 'tests')])
        # Check that file related metadata keys are not present
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_filenames_containing_spaces(self, caplog):
        # Check that filenames with spaces in them are handled ok
        logger.setLevel('DEBUG')
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        malopts = get_malware_options(rules_location=RULE_RULE_FILE, scan_only=ANOTHER_MATCHING_ENTITY_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()
        assert "Scan only the specified filesystem item: ['%s']" % ANOTHER_MATCHING_ENTITY_FILE in caplog.text
        assert "Using specified rules file: %s" % RULE_RULE_FILE in caplog.text
        assert "Yara command: ['nice', '-n', '19', '%s', '-s', '-N', '-a', '3600', '-p', '2', '-r', '-f', '%s']" %\
               (yara, RULE_RULE_FILE) in caplog.text
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8


class TestLineNumberMetadata:

    def test_rule_rule_scan_another_matching_entity(self):
        malopts = get_malware_options(rules_location=RULE_RULE_FILE, scan_only=ANOTHER_MATCHING_ENTITY_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()

        # 8 matching strings for 'Rule' in 'another matching_entity' file
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8

        assert rule_match[0]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[0]['string_identifier'] == '$match3'
        assert rule_match[0]['string_offset'] == 2
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[1]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "contains ="
        assert rule_match[1]['string_identifier'] == '$grep1'
        assert rule_match[1]['string_offset'] == 97
        metadata = rule_match[1]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[2]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == "contains .+"
        assert rule_match[2]['string_identifier'] == '$grep2'
        assert rule_match[2]['string_offset'] == 153
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == 'contains "'
        assert rule_match[3]['string_identifier'] == '$grep3'
        assert rule_match[3]['string_offset'] == 213
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains '"
        assert rule_match[4]['string_identifier'] == '$grep4'
        assert rule_match[4]['string_offset'] == 241
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_data'] == 'contains ()[]'
        assert rule_match[5]['string_identifier'] == '$grep5'
        assert rule_match[5]['string_offset'] == 269
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == 'contains {'
        assert rule_match[6]['string_identifier'] == '$grep6'
        assert rule_match[6]['string_offset'] == 299
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[7]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[7]['string_data'] == 'contains ^$'
        assert rule_match[7]['string_identifier'] == '$grep7'
        assert rule_match[7]['string_offset'] == 327
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

    def test_rule_metadata_test_scanning_itself(self):
        # Taking some complicated rule strings to make sure grepping for line numbers is working correctly
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE, scan_only=METADATA_TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()

        rule_match = mdc.host_scan['MetadataTestRule']
        assert len(rule_match) == 9

        assert rule_match[0]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[0]['string_data'] == 'echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"'
        assert rule_match[0]['string_identifier'] == '$s1'
        assert rule_match[0]['string_offset'] == 392
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'UTF-8 Unicode text'
        assert metadata['mime_type'] == 'text/plain; charset=utf-8'
        assert metadata['md5sum'] == '227429b142ad425733fe155386d4a405'
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode('Testing $s1 = "echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"" ascii fullword')

        assert rule_match[1]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[1]['string_data'] == '"${user_name}"@"${host_name}" -p "${port}'
        assert rule_match[1]['string_identifier'] == '$s2'
        assert rule_match[1]['string_offset'] == 478
        metadata = rule_match[1]['metadata']
        assert metadata['line_number'] == 10
        assert metadata['line'] == urlencode('Testing $s2 = ""${user_name}"@"${host_name}" -p "${port}" ascii fullword')

        assert rule_match[2]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[2]['string_data'] == """'$password' &" <<< GMANcode27'"""
        assert rule_match[2]['string_identifier'] == '$s3'
        assert rule_match[2]['string_offset'] == 555
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode("""Testing $s3 = "'$password' &" <<< GMANcode27'" ascii fullword""")

        assert rule_match[3]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[3]['string_data'] == "for ssh_creds in ${allThreads[@]}; do"
        assert rule_match[3]['string_identifier'] == '$s4'
        assert rule_match[3]['string_offset'] == 119
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode('Testing $s4 = "for ssh_creds in ${allThreads[@]}; do" ascii fullword')

        assert rule_match[4]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[4]['string_data'] == '"text=$MSG" "$MSG_URL$id&"'
        assert rule_match[4]['string_identifier'] == '$s5'
        assert rule_match[4]['string_offset'] == 621
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode('Testing $s5 = ""text=$MSG" "$MSG_URL$id&"" ascii fullword')

        # Cannot match line_numbers for this rule due to non-ascii chars
        assert rule_match[5]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[5]['string_data'] == "--exclude=\\*.\\xE2\\x98\\xA2 -l"
        assert rule_match[5]['string_identifier'] == '$s6'
        assert rule_match[5]['string_offset'] == 683
        metadata = rule_match[5]['metadata']
        assert all([key not in ['line_number', 'line'] for key in metadata.keys()])

        assert rule_match[6]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[6]['string_data'] == "--include=\\*.{txt,sh,exe}"
        assert rule_match[6]['string_identifier'] == '$s7'
        assert rule_match[6]['string_offset'] == 732
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode(r'Testing $s7 = "--include=\*.{txt,sh,exe}" ascii fullword')

        assert rule_match[7]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[7]['string_data'] == "allThreads=($1)"
        assert rule_match[7]['string_identifier'] == '$s8'
        assert rule_match[7]['string_offset'] == 192
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 5
        assert metadata['line'] == urlencode('Testing $s8 = "allThreads=($1)" ascii fullword')

        assert rule_match[8]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[8]['string_data'] == "$(host): encrypt files. Done."
        assert rule_match[8]['string_identifier'] == '$s9'
        assert rule_match[8]['string_offset'] == 243
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 6
        assert metadata['line'] == urlencode('Testing $s9 = "$(host): encrypt files. Done." ascii fullword')


CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
""" % (MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE)

MATCHES_DIRECTORY_SCAN_OUTPUT = """
error scanning matches/kcore: error: 4
XFTI_brootkit matches/brootkit_match
0x0:$hdr: #!/
0x1a:$path: BR_ROOTKIT_PATH
0x11:$br_brootkit: brootkit
0x2a:$br_brootkit: brootkit
XFTI_FinSpy matches/finspy_match
0x18:$fin_unpacked1: fin_conn_
0x24:$fin_unpacked2: fin_relay_
0x31:$fin_unpacked3: fin_util_
0x3d:$fin_unpacked4: fin_read_
0x49:$fin_unpacked5: fin_conf
0xf:$fin_unpacked6: FinSpy
0x54:$fin_unpacked6: finspy
XFTI_FritzFrog matches/fritzfrog_match
0x0:$ELF_hdr: 7F 45 4C 46
0xee:$golang: /usr/lib/golang/src/
0x7a:$cmd_getbin: main.getbin
0x8a:$cmd_getstats: main.getstats
0xa2:$cmd_getpeerstats: main.getpeerstats
0xbe:$cmd_getblobstats: main.getblobstats
0xda:$cmd_getvotestats: main.getvotestats
XFTI_Mirai matches/mirai_match
0x1:$magic: 45 4C 46
0x1a:$string_2: GET /cgi-bin/nobody/
0x30:$string_3: POST /UD/?5 HTTP/1.1
0x46:$string_4: str=Lw==&username=admin
0x5f:$string_5: 20Account.User1.Password%3E
"""

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""


class TestParseScanOutput:

    def test_contrived_scan_output(self, caplog):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines

        # The rules_location is irrelevant to the test but it just makes the initialization of
        # MalwareDetectionClient easier if done this way (and its simpler than using @patch ... maybe)
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        malopts['add_metadata'] = False
        logger.setLevel('DEBUG')  # Make sure the logging level is set *before* performing the scan
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        assert mdc.matches == 8

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        assert len(rule_match) == 1
        assert 'e-r-r-o-r s-c-a-n-n-i-n-g' in rule_match[0]['source']
        assert rule_match[0]['string_data'] == "matches 'this' rule"
        assert rule_match[0]['string_identifier'] == '$match'
        assert rule_match[0]['string_offset'] == 291

        # 14 matching strings for 'Rule'
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 14
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == 'string match in the file "matching_entity"'
        assert rule_match[0]['string_identifier'] == '$match0'
        assert rule_match[0]['string_offset'] == 21
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "another string match in matching_entity"
        assert rule_match[1]['string_identifier'] == '$match1'
        assert rule_match[1]['string_offset'] == 83
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == 'string with different types of quotes \'here\' and "here"'
        assert rule_match[2]['string_identifier'] == '$match2'
        assert rule_match[2]['string_offset'] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[3]['string_identifier'] == '$match3'
        assert rule_match[3]['string_offset'] == 2
        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains ="
        assert rule_match[4]['string_identifier'] == '$grep1'
        assert rule_match[4]['string_offset'] == 97
        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == "contains .+"
        assert rule_match[6]['string_identifier'] == '$grep2'
        assert rule_match[6]['string_offset'] == 153
        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_data'] == 'contains "'
        assert rule_match[8]['string_identifier'] == '$grep3'
        assert rule_match[8]['string_offset'] == 213
        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_data'] == "contains '"
        assert rule_match[9]['string_identifier'] == '$grep4'
        assert rule_match[9]['string_offset'] == 241
        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_data'] == 'contains ()[]'
        assert rule_match[10]['string_identifier'] == '$grep5'
        assert rule_match[10]['string_offset'] == 269
        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_data'] == 'contains {'
        assert rule_match[11]['string_identifier'] == '$grep6'
        assert rule_match[11]['string_offset'] == 299
        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_data'] == 'contains ^$'
        assert rule_match[12]['string_identifier'] == '$grep7'
        assert rule_match[12]['string_offset'] == 327

        assert rule_match[13]['source'].startswith('matching_entity_3')
        assert rule_match[13]['string_data'] == ''
        assert rule_match[13]['string_identifier'] == ''
        assert rule_match[13]['string_offset'] == -1

        # 4 matching strings for 'another_matching_rule'
        rule_match = mdc.host_scan['another_matching_rule']
        assert len(rule_match) == 4
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        assert rule_match[2]['string_data'] == '#!/bin/sh'
        assert rule_match[2]['string_identifier'] == '$s0'
        assert rule_match[2]['string_offset'] == 60783814
        assert rule_match[3]['source'] == '1234567'
        assert rule_match[3]['string_data'] == '#!/bin/sh'
        assert rule_match[3]['string_identifier'] == '$s0'
        assert rule_match[3]['string_offset'] == 0

        rule_match = mdc.host_scan['Iyamtho']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == " yep"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        rule_match = mdc.host_scan['n_m3_t00']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == "damn   straight"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        assert "Error parsing string match '0x1badoffset:$s1: skip this line': " in caplog.text
        assert "Error parsing string match '0x2error scanning skip/this/line/too: need more colons': " in caplog.text

    def test_contrived_scan_output_metadata(self, caplog):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_location with any rule, but its not relevant for the tests
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # Matches and metadata for MATCHING_ENTITY_FILE
        # if sys.version_info == (2, 7):
        # This assert is failing for some reason on python3.6
        # assert "grep -Ebon  -e 'another string match in matching_entity'" in caplog.text

        rule_match = mdc.host_scan['Rule']
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_offset'] == 21
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 1
        assert metadata['line'] == urlencode('This line contains a string match in the file "matching_entity"')

        # Testing displaying long lines
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_offset'] == 83
        metadata = rule_match[1]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 2
        assert metadata['line'] == urlencode('This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o...')

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_offset'] == 230
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode("""And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough""")

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        # if sys.version_info == (2, 7):
        # This assert is failing for some reason on python3.6
        # assert "[]' -e 'contains =' -e 'contains '\"'\"''" in caplog.text

        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_offset'] == 2
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_offset'] == 97
        metadata = rule_match[4]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_offset'] == 123
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 8
        assert metadata['line'] == urlencode("This line contains = char too")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_offset'] == 153
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_offset'] == 213
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_offset'] == 241
        metadata = rule_match[9]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_offset'] == 269
        metadata = rule_match[10]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_offset'] == 299
        metadata = rule_match[11]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_offset'] == 327
        metadata = rule_match[12]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert rule_match[13]['source'] == "matching_entity_3, but without any string matches - yes that's ok"
        metadata = rule_match[13]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.host_scan['another_matching_rule']
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]['source'] == '1234567'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert all([key not in ['process_name', 'file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_matches_scan_output(self, caplog):
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)

        assert mdc.matches == 4
        # Error won't display when log level is INFO
        assert 'error scanning matches/kcore: error: 4' not in caplog.text
        assert 'Matched rule XFTI_brootkit in file matches/brootkit_match' in caplog.text
        assert 'Matched rule XFTI_FinSpy in file matches/finspy_match' in caplog.text
        assert 'Matched rule XFTI_FritzFrog in file matches/fritzfrog_match' in caplog.text
        assert 'Matched rule XFTI_Mirai in file matches/mirai_match' in caplog.text
        assert len(mdc.host_scan['XFTI_brootkit']) == 4
        assert len(mdc.host_scan['XFTI_FinSpy']) == 7
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 7
        assert len(mdc.host_scan['XFTI_Mirai']) == 5

        # Reduce the string_match_limit and some of the counts will change
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 5
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert len(mdc.host_scan['XFTI_brootkit']) == 4
        assert len(mdc.host_scan['XFTI_FinSpy']) == 5
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 5
        assert len(mdc.host_scan['XFTI_Mirai']) == 5

        # Even with string_match_limit = 0, there will be 1 entry to record the source
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 0
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert len(mdc.host_scan['XFTI_brootkit']) == 1
        assert len(mdc.host_scan['XFTI_FinSpy']) == 1
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 1
        assert len(mdc.host_scan['XFTI_Mirai']) == 1

        # With debug enabled the 'error scanning ... error: 4' will be logged
        caplog.clear()
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert 'error scanning matches/kcore: error: 4' in caplog.text

    def test_error_scan_output(self, caplog):
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(ERROR_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file' in caplog.text

    def test_error4_scan_output(self, caplog):
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(ERROR4_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4' in caplog.text

    def test_random_output(self):
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(RANDOM_OUTPUT)

        assert mdc.matches == 2
        rule_match = mdc.host_scan['Lorem']
        assert rule_match[0]['source'].startswith('ipsum dolor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1
        rule_match = mdc.host_scan['Dictum']
        assert rule_match[0]['source'].startswith('at tempor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1


if __name__ == '__main__':
    print(MISC_DIR)
    print(RULE_RULE_FILE)

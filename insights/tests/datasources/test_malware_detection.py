import os
import sys
import yaml
import pytest
import string
import random
from mock.mock import patch
try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from .malware_detection_misc import utils
from insights.specs.malware_detection import (
    DEFAULT_MALWARE_CONFIG, MIN_YARA_VERSION, MALWARE_CONFIG_FILE,
    MalwareDetectionClient, logger,
    get_toplevel_dirs, get_parent_dirs, remove_child_items, remove_included_excluded_items,
    process_include_items, process_exclude_items, process_include_exclude_items
)
from insights.client.apps.manifests import manifests
from insights.util.subproc import call, CalledProcessError
from insights.client.constants import InsightsConstants as constants

# Does the system already have yara installed on it?
# Run this before modifying the system search path
EXISTING_YARA = None
try:
    EXISTING_YARA = str(call('which yara')).strip()
except CalledProcessError:
    pass

# Tests using the caplog fixture fail with python 2.6
IS_PY26 = sys.version_info < (2, 7)
PY26_SKIP_REASON = "pytest caplog fixture doesn't work in python 2.6"

# Can't scan the pytest process in the Jenkins QE environment for some reason
IS_QE = '/home/runner' in os.getcwd()  # Is there a better way to detect the QE environment?
QE_SKIP_REASON = "Can't scan pytest process in QE Jenkins environment"

# Miscellanous extra files used by the malware tests are in the malware_detection_misc directory
MISC_DIR = utils.find_misc_dir('malware_detection_misc')

# Location of yara binary used for testing and its libraries
# Add MISC_DIR to the path so the system automatically finds the yara binary in there
YARA_BINARY = os.path.join(MISC_DIR, 'yara')
os.environ['LD_LIBRARY_PATH'] = MISC_DIR
WITHOUT_MISC_ENV_PATH = os.environ['PATH']
WITH_MISC_ENV_PATH = MISC_DIR + ':' + WITHOUT_MISC_ENV_PATH
os.environ['PATH'] = WITH_MISC_ENV_PATH

# Location of this test file (might be a better way of determining this!)
MALWARE_TEST_FILE = os.path.normpath(os.path.join(MISC_DIR, '..', 'test_malware_detection.py'))

# Miscellaneous rules files and other text files used in the tests
COMPILED_RULES_FILE = os.path.join(MISC_DIR, 'rules_compiled.yar')
TEST_RULE_FILE = os.path.join(MISC_DIR, 'TEST_RedHatInsightsMalwareDetection.yar')
METADATA_TEST_RULE_FILE = os.path.join(MISC_DIR, 'rule_metadata_test.yar')
RULE_RULE_FILE = os.path.join(MISC_DIR, 'rule rule.yar')
MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'matching_entity')
ANOTHER_MATCHING_ENTITY_FILE = os.path.join(MISC_DIR, 'another matching_entity')

# Get the number of CPU threads to run yara
CPUS = 1 if int(call('nproc').strip()) <= 2 else 2

# Temporary directory for testing stuff in
RANDOM_STRING = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))
TEMP_TEST_DIR = "/tmp/malware-detection_test_dir_%s/" % RANDOM_STRING


@pytest.fixture
def extract_tmp_files():
    os.mkdir(TEMP_TEST_DIR)
    os.system('tar -C %s -xf %s/tmp_scan_files.tgz' % (TEMP_TEST_DIR, MISC_DIR))
    yield
    os.system('rm -rf %s' % TEMP_TEST_DIR)


def get_malware_options(rules_location=None, scan_only=None, test_scan=False, yara_binary=None):
    malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
    malopts['yara_binary'] = yara_binary
    malopts['rules_location'] = rules_location
    malopts['scan_only'] = scan_only
    malopts['test_scan'] = test_scan
    return malopts


# Skip the python 2.6 tests for this class because most use caplog
@pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_REASON)
class TestMalwareDetectionClient:

    def test_default_malware_spec(self):
        # Read in the default malware spec and check its values
        malware_manifest = yaml.safe_load(manifests['malware-detection'])
        assert malware_manifest['content_type'] == "application/vnd.redhat.malware-detection.results+tgz"
        specs = malware_manifest['plugins']['configs']
        for spec in ['mac_addresses', 'etc_machine_id', 'hostname', 'bios_uuid', 'machine_id', 'ip_addresses',
                     'subscription_manager_id']:
            assert {'enabled': True, 'name': 'insights.specs.default.DefaultSpecs.%s' % spec} in specs
            assert {'enabled': True, 'name': 'insights.specs.Specs.%s' % spec} in specs

    def test_default_malware_options(self):
        # Read in the default malware options and check its values
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
        assert malopts['rules_location'] == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        assert malopts['yara_binary'] is None
        assert malopts['test_scan'] is True
        assert malopts['scan_filesystem'] is True
        assert malopts['scan_processes'] is False
        assert malopts['scan_only'] is None
        assert malopts['scan_since'] is None
        assert malopts['scan_exclude'] == ['/proc', '/sys', '/cgroup', '/selinux', '/net', '/mnt', '/media', '/dev']
        assert malopts['exclude_network_filesystem_mountpoints'] is True

    def test_running_default_options(self, caplog):
        # However, with the default malware options, test_scan is true, so some of the options values
        # will be different from those of the default options.
        # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
        logger.setLevel('DEBUG')
        test_pid = str(os.getpid())
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)

        with patch("insights.specs.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE):
            mdc = MalwareDetectionClient(None, malopts)
        assert mdc.yara_binary == yara
        assert mdc.rules_file == TEST_RULE_FILE
        assert mdc.do_process_scan is True
        if os.path.isfile(MALWARE_CONFIG_FILE):
            assert mdc.scan_fsobjects == [MALWARE_CONFIG_FILE]
            assert mdc.do_filesystem_scan is True
        else:
            assert mdc.do_filesystem_scan is False
        assert mdc.scan_pids == [test_pid]
        assert mdc.scan_since_dict == {'timestamp': None}
        assert mdc.scan_exclude_list == []
        assert mdc.network_filesystem_mountpoints == []
        yara_cmd = ' '.join(mdc.yara_cmd)
        assert yara_cmd == "nice -n 19 %s -s -N -a 3600 -p %s -r -f %s" % (yara, CPUS, mdc.rules_file)
        if os.path.isfile(MALWARE_CONFIG_FILE):
            assert "Performing a test scan of %s and the current process (PID %s)"\
                   % (MALWARE_CONFIG_FILE, test_pid) in caplog.text
        else:
            assert "Performing a test scan of the current process (PID %s)" % test_pid in caplog.text
        assert "Using yara binary: %s" % yara in caplog.text

        # Remainder of test may not work in QE Jenkins environment because config file may not exist and
        # can't scan the pytest process
        if os.path.exists(MALWARE_CONFIG_FILE):
            mdc.scan_filesystem()
            assert "Scanning specified files in %s ..." % utils.tld(MALWARE_CONFIG_FILE) in caplog.text
            assert "Matched rule TEST_RedHatInsightsMalwareDetection in file %s" % MALWARE_CONFIG_FILE in caplog.text

        mdc.scan_processes()
        if IS_QE:
            assert "Unable to scan process %s: " % test_pid in caplog.text
        else:
            assert "Scanning process %s ..." % test_pid in caplog.text
            assert "Matched rule TEST_RedHatInsightsMalwareDetection in process %s" % test_pid in caplog.text

    def test_running_modified_options(self):
        # Disable test_scan and the malware options should mostly be same as what's in the mdc object
        logger.setLevel('INFO')
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        malopts = yaml.safe_load(DEFAULT_MALWARE_CONFIG)
        malopts['test_scan'] = False

        with patch("insights.specs.malware_detection.MalwareDetectionClient._get_rules",
                   return_value=COMPILED_RULES_FILE):
            mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.yara_binary == yara
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == []
        assert mdc.scan_pids == []
        assert mdc.scan_since_dict == {'timestamp': None, 'datetime': None}
        assert all([d in mdc.scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])

    def test_invalid_option_values(self):
        # TODO: Check the malware client app behaves in a predictable way if the user specifies invalid option values
        pass

    @patch("insights.specs.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    def test_successful_find_yara_binary(self, rules, caplog):
        logger.setLevel('DEBUG')
        # Find yara using the system search path
        # If its already on the system, then malware will find that one, otherwise the test yara will be found
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        malopts = get_malware_options()
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.yara_binary == yara
        assert "Using yara binary: %s" % yara in caplog.text

        # Finding yara binary by using the yara_binary option
        caplog.clear()
        malopts = get_malware_options(yara_binary=YARA_BINARY)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.yara_binary == YARA_BINARY
        assert "Using specified yara binary: %s" % YARA_BINARY in caplog.text

    def test_failing_find_yara_binary(self, caplog):
        # Testing failing to find yara
        malopts = get_malware_options()

        # Test with no yara found on system.  If another yara is present on the system, then skip this test
        if not EXISTING_YARA:
            # We didn't find another yara installed, so remove the malware_detection_misc from search path
            # which will mean the test yara won't be found
            os.environ['PATH'] = WITHOUT_MISC_ENV_PATH
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(None, malopts)
            assert "Couldn't find yara.  Please ensure the yara package is installed" in caplog.text
            assert exc_info.value.code == constants.sig_kill_bad
            # Put malware_detection_misc back into the search so the other tests work!
            os.environ['PATH'] = WITH_MISC_ENV_PATH

        # Test yara_binary option with non-existent file
        caplog.clear()
        yara_binary = '/bin/notyara'
        malopts['yara_binary'] = yara_binary
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Couldn't find the specified yara binary %s.  Please check it exists" % yara_binary in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Test yara_binary option with non-yara file
        yara_binary = '/bin/ls'
        malopts['yara_binary'] = yara_binary
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Error getting the version of the specified yara binary %s" % yara_binary in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    @patch("insights.specs.malware_detection.MalwareDetectionClient._get_rules", return_value=TEST_RULE_FILE)
    @patch("insights.specs.malware_detection.call")
    def test_find_yara_version(self, call, rules, caplog):
        # Test checking the version of yara
        malopts = get_malware_options()

        # Invalid versions of yara
        for version in ['4.0.99', '4']:
            call.return_value = version
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(None, malopts)
            assert "Found yara version %s, but malware-detection requires version >= %s" % (version, MIN_YARA_VERSION)\
                   in caplog.text
            assert exc_info.value.code == constants.sig_kill_bad
            caplog.clear()

        # Valid versions of yara
        for version in ['4.1', '10.0.0']:
            call.return_value = version
            with patch("insights.specs.malware_detection.MalwareDetectionClient._build_yara_command", return_value="yara"):
                mdc = MalwareDetectionClient(None, malopts)
            assert mdc.yara_binary

    def test_scanning_compiled_rules_file(self, caplog):
        # Scan the compiled rules file ... with the compiled rules file
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()
        assert "Scan only the specified filesystem item: ['%s']" % COMPILED_RULES_FILE in caplog.text
        assert "Using specified rules file: %s" % COMPILED_RULES_FILE in caplog.text
        assert "Scanning specified files in %s ..." % utils.tld(COMPILED_RULES_FILE) in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text
        # Matched 2 rules
        assert mdc.matches == 2
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        assert string_matches == 3

        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] <= 544

        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        assert rule_match[0]['string_data'] == 'sent"'
        assert rule_match[0]['string_identifier'] == '$string1'
        assert rule_match[0]['string_offset'] == 601
        assert rule_match[1]['source'] == COMPILED_RULES_FILE
        assert rule_match[1]['string_data'] == 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00'
        assert rule_match[1]['string_identifier'] == '$string2'
        assert rule_match[1]['string_offset'] == 616
        assert mdc.scan_processes() is False

    def test_scanning_malware_test_file(self):
        # Scan this test_malware_detection.py file
        # Expect to match both rules in COMPILED_RULES_FILE, but only 1 string match per rule, due to using
        #   yara -f/fast scan option which stops searching for a matching string after finding it once
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=MALWARE_TEST_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.string_match_limit == 10

        mdc.scan_filesystem()
        assert mdc.matches == 2  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1  # But only 1 string match per rule
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        # First match is near the start of the file
        assert rule_match[0]['string_offset'] < 500

        # Increase string_match_limit and scan again.
        # Expect to find just one string match per rule again because of the yara fast scan option
        # (Should we still bother using string_match_limit now that we use fast scan option?)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 1

    def test_scan_only_root(self, caplog):
        # Nothing special about root when parsing the scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # TODO: add extra tests when performing scan_filesystem to see root being broken into subdirectories
        logger.setLevel('INFO')
        scan_only = '/'
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=scan_only)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == [scan_only]
        assert "Scan only the specified filesystem item: ['%s']" % scan_only in caplog.text

        # Multiple directories aren't consolidated until later
        caplog.clear()
        scan_only = ['/', '/tmp', '/home']
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=scan_only)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == scan_only
        assert "Scan only the specified filesystem items: %s" % scan_only in caplog.text

    def test_scan_exclude_root(self, caplog):
        # Nothing special about root when parsing the scan_exclude option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # TODO: add extra tests when performing scan_filesystem to see root being broken into subdirectories
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE)
        malopts['scan_exclude'].append('/')
        mdc = MalwareDetectionClient(None, malopts)
        assert '/' in mdc.scan_exclude_list

    def test_scan_only_scan_exclude_nullify(self, caplog):
        # Testing scan_only and scan_exclude items such that the exclude items nullify all the scan_only items
        # In which case there will be nothing to scan
        logger.setLevel('INFO')

        # Various directories that cancel each other out
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE,
                                      scan_only=['/var/log', '/usr/lib/systemd', '/tmp'])
        malopts['scan_exclude'].extend(['/tmp/', '/usr/lib/', '/var/log'])
        mdc = MalwareDetectionClient(None, malopts)
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Nothing specified for scan_only and root for scan_exclude
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE)
        malopts['scan_exclude'] = '/'
        mdc = MalwareDetectionClient(None, malopts)
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Both scan_only and scan_exclude contain root
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only='/')
        malopts['scan_exclude'].append('/')
        mdc = MalwareDetectionClient(None, malopts)
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_rules_file_types(self, caplog):
        # Testing if the rules file is compiled or not
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert '-C' not in mdc.yara_cmd
        assert 'Compiled rules: False' in caplog.text

        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert '-C' in mdc.yara_cmd
        assert 'Compiled rules: True' in caplog.text

    def test_bad_rules_files(self, caplog):
        # Tests with non-rules/problematic files
        malopts = get_malware_options(rules_location=YARA_BINARY)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Unable to use rules file %s" % YARA_BINARY in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        caplog.clear()
        malopts = get_malware_options(rules_location=MISC_DIR)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Couldn't find specified rules file: %s" % MISC_DIR in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        caplog.clear()
        empty_file = os.path.join(MISC_DIR, '__init__.py')
        malopts = get_malware_options(rules_location=empty_file)
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(None, malopts)
        assert "Rules file %s is empty" % empty_file in caplog.text
        assert exc_info.value.code == 101

    def test_files_with_extra_slashes(self, caplog):
        # Test behaviour when rules_location file and scan_only files have extra slashes in them
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '//'),
                                      scan_only=[MISC_DIR.replace('/', '//'),
                                                 MALWARE_TEST_FILE.replace('/', '//')])
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

        # Test scanning the tests directory again, but with an extra slash only in the RULES_COMPILED path
        # Even with the extra slash in RULES_COMPILED, there should will rules matched in RULES_COMPILED
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '//'),
                                      scan_only=COMPILED_RULES_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '//')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [COMPILED_RULES_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == COMPILED_RULES_FILE
        # WILL match the rules file this time because we ARE specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE in caplog.text

        # For completeness (silliness?), try with even more slashes in the file names
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE.replace('/', '////'),
                                      scan_only=[MISC_DIR.replace('/', '///'),
                                                 MALWARE_TEST_FILE.replace('/', '///')])
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_location == COMPILED_RULES_FILE.replace('/', '////')
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text
        # Won't match anything in the rules file because we are not specifically scanning that
        assert "Matched rule MalwareDetectionClientRule in file %s" % COMPILED_RULES_FILE not in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % COMPILED_RULES_FILE not in caplog.text

        # Chaos monkey! - add extra slashes to rules_file and scan_fsobjects AFTER they have been verified
        # This is a contrived test and shouldn't happen in normal code flow but done to make sure malware behaves well
        # Testing passing double slashes directly into mdc just before mdc.scan_filesystems, eg
        # mdc.scan_fsobjects = ['//home//bob']; mdc.scan_filesystem()
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=[MISC_DIR, MALWARE_TEST_FILE])
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.rules_file == COMPILED_RULES_FILE
        assert mdc.scan_fsobjects == [MISC_DIR, MALWARE_TEST_FILE]
        # Modify rules_file and scan_fsobjects AFTER they have been verified
        mdc.rules_file = COMPILED_RULES_FILE.replace('/', '//')
        mdc.scan_fsobjects = [MISC_DIR.replace('/', '//'), MALWARE_TEST_FILE.replace('/', '//')]
        mdc.scan_filesystem()
        # The file paths will have an extra / at the start of them (because os.path.normpath doesn't remove it)
        assert "Scanning specified files in %s" % utils.tld(MISC_DIR) in caplog.text
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == MALWARE_TEST_FILE
        assert "Matched rule MalwareDetectionClientRule in file %s" % MALWARE_TEST_FILE in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % MALWARE_TEST_FILE in caplog.text

    def test_scan_exclude_with_extra_slashes(self, caplog):
        # Testing we handle the situation where items in scan_exclude contain multiple slashes!
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE)
        malopts['scan_exclude'] = '//'
        mdc = MalwareDetectionClient(None, malopts)
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

        # Chaos monkey! - add extra slashes to scan_exclude items AFTER they have been verified
        # This is a contrived test and shouldn't happen in normal code flow but done to make sure malware behaves well
        caplog.clear()
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=MISC_DIR)
        malopts['scan_exclude'] = MISC_DIR
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == [MISC_DIR]
        assert mdc.scan_exclude_list == [MISC_DIR]
        # Modify rules_file and scan_fsobjects AFTER they have been verified
        mdc.scan_exclude_list = [MISC_DIR.replace('/', '//')]
        with pytest.raises(SystemExit) as exc_info:
            mdc.scan_filesystem()
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_scanning_pytest_process(self, caplog):
        # Scan the python pytest process whilst its running the tests
        logger.setLevel('INFO')
        test_pid = str(os.getpid())
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=int(test_pid))
        mdc = MalwareDetectionClient(None, malopts)
        assert "Scan only the specified process ID: ['%s']" % test_pid in caplog.text
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True

        mdc.scan_processes()
        if IS_QE:
            assert "Unable to scan process %s: " % test_pid in caplog.text
        else:
            assert "Scanning process %s ..." % test_pid in caplog.text
            assert "Matched rule MalwareDetectionClientRule in process %s" % test_pid in caplog.text
            assert "Matched rule MiscellaneousStringsRule in process %s" % test_pid in caplog.text
            # Matches both rules in the PID
            assert mdc.matches == 2
            rule_match = mdc.host_scan['MalwareDetectionClientRule']
            assert len(rule_match) == 1
            assert rule_match[0]['source'] == test_pid
            assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
            assert rule_match[0]['string_identifier'] == '$text1'
            assert rule_match[0]['string_offset'] > 0
            metadata = rule_match[0]['metadata']
            assert metadata['source_type'] == 'process'
            # The process running the tests should have any of these strings in its name
            assert any([s in metadata['process_name'] for s in ('python', 'pytest', 'tests')])
            # Check that file related metadata keys are not present
            assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_filenames_containing_spaces(self, caplog):
        # Check that filenames with spaces in them are handled ok
        logger.setLevel('DEBUG')
        yara = YARA_BINARY if not EXISTING_YARA else EXISTING_YARA
        malopts = get_malware_options(rules_location=RULE_RULE_FILE, scan_only=ANOTHER_MATCHING_ENTITY_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()
        assert "Scan only the specified filesystem item: ['%s']" % ANOTHER_MATCHING_ENTITY_FILE in caplog.text
        assert "Using specified rules file: %s" % RULE_RULE_FILE in caplog.text
        assert "Yara command: ['nice', '-n', '19', '%s', '-s', '-N', '-a', '3600', '-p', '%s', '-r', '-f', '%s']" %\
               (yara, CPUS, RULE_RULE_FILE) in caplog.text
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8


# Don't skip the python 2.6 tests in this class because none of them use the caplog fixture
# Having these tests pass with python 2.6 should be proof enough that overall malware works with 2.6
class TestLineNumberMetadata:

    def test_rule_rule_scan_another_matching_entity(self):
        malopts = get_malware_options(rules_location=RULE_RULE_FILE, scan_only=ANOTHER_MATCHING_ENTITY_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()

        # 8 matching strings for 'Rule' in 'another matching_entity' file
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 8

        assert rule_match[0]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[0]['string_identifier'] == '$match3'
        assert rule_match[0]['string_offset'] == 2
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[1]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "contains ="
        assert rule_match[1]['string_identifier'] == '$grep1'
        assert rule_match[1]['string_offset'] == 97
        metadata = rule_match[1]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[2]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == "contains .+"
        assert rule_match[2]['string_identifier'] == '$grep2'
        assert rule_match[2]['string_offset'] == 153
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == 'contains "'
        assert rule_match[3]['string_identifier'] == '$grep3'
        assert rule_match[3]['string_offset'] == 213
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains '"
        assert rule_match[4]['string_identifier'] == '$grep4'
        assert rule_match[4]['string_offset'] == 241
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_data'] == 'contains ()[]'
        assert rule_match[5]['string_identifier'] == '$grep5'
        assert rule_match[5]['string_offset'] == 269
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == 'contains {'
        assert rule_match[6]['string_identifier'] == '$grep6'
        assert rule_match[6]['string_offset'] == 299
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[7]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[7]['string_data'] == 'contains ^$'
        assert rule_match[7]['string_identifier'] == '$grep7'
        assert rule_match[7]['string_offset'] == 327
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

    def test_rule_metadata_test_scanning_itself(self):
        # Taking some complicated rule strings to make sure grepping for line numbers is working correctly
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE, scan_only=METADATA_TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.scan_filesystem()

        rule_match = mdc.host_scan['MetadataTestRule']
        assert len(rule_match) == 9

        assert rule_match[0]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[0]['string_data'] == 'echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"'
        assert rule_match[0]['string_identifier'] == '$s1'
        assert rule_match[0]['string_offset'] == 392
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'UTF-8 Unicode text'
        assert metadata['mime_type'] == 'text/plain; charset=utf-8'
        assert metadata['md5sum'] == '227429b142ad425733fe155386d4a405'
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode('Testing $s1 = "echo -e "[-] Ping \\033[31m${host_name}\\033[0m bad"" ascii fullword')

        assert rule_match[1]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[1]['string_data'] == '"${user_name}"@"${host_name}" -p "${port}'
        assert rule_match[1]['string_identifier'] == '$s2'
        assert rule_match[1]['string_offset'] == 478
        metadata = rule_match[1]['metadata']
        assert metadata['line_number'] == 10
        assert metadata['line'] == urlencode('Testing $s2 = ""${user_name}"@"${host_name}" -p "${port}" ascii fullword')

        assert rule_match[2]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[2]['string_data'] == """'$password' &" <<< GMANcode27'"""
        assert rule_match[2]['string_identifier'] == '$s3'
        assert rule_match[2]['string_offset'] == 555
        metadata = rule_match[2]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode("""Testing $s3 = "'$password' &" <<< GMANcode27'" ascii fullword""")

        assert rule_match[3]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[3]['string_data'] == "for ssh_creds in ${allThreads[@]}; do"
        assert rule_match[3]['string_identifier'] == '$s4'
        assert rule_match[3]['string_offset'] == 119
        metadata = rule_match[3]['metadata']
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode('Testing $s4 = "for ssh_creds in ${allThreads[@]}; do" ascii fullword')

        assert rule_match[4]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[4]['string_data'] == '"text=$MSG" "$MSG_URL$id&"'
        assert rule_match[4]['string_identifier'] == '$s5'
        assert rule_match[4]['string_offset'] == 621
        metadata = rule_match[4]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode('Testing $s5 = ""text=$MSG" "$MSG_URL$id&"" ascii fullword')

        # Cannot match line_numbers for this rule due to non-ascii chars
        assert rule_match[5]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[5]['string_data'] == "--exclude=\\*.\\xE2\\x98\\xA2 -l"
        assert rule_match[5]['string_identifier'] == '$s6'
        assert rule_match[5]['string_offset'] == 683
        metadata = rule_match[5]['metadata']
        assert all([key not in ['line_number', 'line'] for key in metadata.keys()])

        assert rule_match[6]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[6]['string_data'] == "--include=\\*.{txt,sh,exe}"
        assert rule_match[6]['string_identifier'] == '$s7'
        assert rule_match[6]['string_offset'] == 732
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode(r'Testing $s7 = "--include=\*.{txt,sh,exe}" ascii fullword')

        assert rule_match[7]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[7]['string_data'] == "allThreads=($1)"
        assert rule_match[7]['string_identifier'] == '$s8'
        assert rule_match[7]['string_offset'] == 192
        metadata = rule_match[7]['metadata']
        assert metadata['line_number'] == 5
        assert metadata['line'] == urlencode('Testing $s8 = "allThreads=($1)" ascii fullword')

        assert rule_match[8]['source'] == METADATA_TEST_RULE_FILE
        assert rule_match[8]['string_data'] == "$(host): encrypt files. Done."
        assert rule_match[8]['string_identifier'] == '$s9'
        assert rule_match[8]['string_offset'] == 243
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 6
        assert metadata['line'] == urlencode('Testing $s9 = "$(host): encrypt files. Done." ascii fullword')


CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
""" % (MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE)

MATCHES_DIRECTORY_SCAN_OUTPUT = """
error scanning matches/kcore: error: 4
XFTI_brootkit matches/brootkit_match
0x0:$hdr: #!/
0x1a:$path: BR_ROOTKIT_PATH
0x11:$br_brootkit: brootkit
0x2a:$br_brootkit: brootkit
XFTI_FinSpy matches/finspy_match
0x18:$fin_unpacked1: fin_conn_
0x24:$fin_unpacked2: fin_relay_
0x31:$fin_unpacked3: fin_util_
0x3d:$fin_unpacked4: fin_read_
0x49:$fin_unpacked5: fin_conf
0xf:$fin_unpacked6: FinSpy
0x54:$fin_unpacked6: finspy
XFTI_FritzFrog matches/fritzfrog_match
0x0:$ELF_hdr: 7F 45 4C 46
0xee:$golang: /usr/lib/golang/src/
0x7a:$cmd_getbin: main.getbin
0x8a:$cmd_getstats: main.getstats
0xa2:$cmd_getpeerstats: main.getpeerstats
0xbe:$cmd_getblobstats: main.getblobstats
0xda:$cmd_getvotestats: main.getvotestats
XFTI_Mirai matches/mirai_match
0x1:$magic: 45 4C 46
0x1a:$string_2: GET /cgi-bin/nobody/
0x30:$string_3: POST /UD/?5 HTTP/1.1
0x46:$string_4: str=Lw==&username=admin
0x5f:$string_5: 20Account.User1.Password%3E
"""

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""


# Skip the python 2.6 tests for this class because most use caplog
@pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_REASON)
class TestParseScanOutput:

    def test_contrived_scan_output(self, caplog):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
        # The rules_location is irrelevant to the test but it just makes the initialization of
        # MalwareDetectionClient easier if done this way (and its simpler than using @patch ... maybe)
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        malopts['add_metadata'] = False
        logger.setLevel('DEBUG')  # Make sure the logging level is set *before* performing the scan
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        assert mdc.matches == 8

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        assert len(rule_match) == 1
        assert 'e-r-r-o-r s-c-a-n-n-i-n-g' in rule_match[0]['source']
        assert rule_match[0]['string_data'] == "matches 'this' rule"
        assert rule_match[0]['string_identifier'] == '$match'
        assert rule_match[0]['string_offset'] == 291

        # 14 matching strings for 'Rule'
        rule_match = mdc.host_scan['Rule']
        assert len(rule_match) == 14
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_data'] == 'string match in the file "matching_entity"'
        assert rule_match[0]['string_identifier'] == '$match0'
        assert rule_match[0]['string_offset'] == 21
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_data'] == "another string match in matching_entity"
        assert rule_match[1]['string_identifier'] == '$match1'
        assert rule_match[1]['string_offset'] == 83
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_data'] == 'string with different types of quotes \'here\' and "here"'
        assert rule_match[2]['string_identifier'] == '$match2'
        assert rule_match[2]['string_offset'] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_data'] == "string match containing error scanning but it's ok because its not in a rule line"
        assert rule_match[3]['string_identifier'] == '$match3'
        assert rule_match[3]['string_offset'] == 2
        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_data'] == "contains ="
        assert rule_match[4]['string_identifier'] == '$grep1'
        assert rule_match[4]['string_offset'] == 97
        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_data'] == "contains .+"
        assert rule_match[6]['string_identifier'] == '$grep2'
        assert rule_match[6]['string_offset'] == 153
        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_data'] == 'contains "'
        assert rule_match[8]['string_identifier'] == '$grep3'
        assert rule_match[8]['string_offset'] == 213
        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_data'] == "contains '"
        assert rule_match[9]['string_identifier'] == '$grep4'
        assert rule_match[9]['string_offset'] == 241
        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_data'] == 'contains ()[]'
        assert rule_match[10]['string_identifier'] == '$grep5'
        assert rule_match[10]['string_offset'] == 269
        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_data'] == 'contains {'
        assert rule_match[11]['string_identifier'] == '$grep6'
        assert rule_match[11]['string_offset'] == 299
        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_data'] == 'contains ^$'
        assert rule_match[12]['string_identifier'] == '$grep7'
        assert rule_match[12]['string_offset'] == 327

        assert rule_match[13]['source'].startswith('matching_entity_3')
        assert rule_match[13]['string_data'] == ''
        assert rule_match[13]['string_identifier'] == ''
        assert rule_match[13]['string_offset'] == -1

        # 4 matching strings for 'another_matching_rule'
        rule_match = mdc.host_scan['another_matching_rule']
        assert len(rule_match) == 4
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        assert rule_match[2]['string_data'] == '#!/bin/sh'
        assert rule_match[2]['string_identifier'] == '$s0'
        assert rule_match[2]['string_offset'] == 60783814
        assert rule_match[3]['source'] == '1234567'
        assert rule_match[3]['string_data'] == '#!/bin/sh'
        assert rule_match[3]['string_identifier'] == '$s0'
        assert rule_match[3]['string_offset'] == 0

        rule_match = mdc.host_scan['Iyamtho']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == " yep"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        rule_match = mdc.host_scan['n_m3_t00']
        assert len(rule_match) == 1
        assert rule_match[0]['source'] == "damn   straight"
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1

        assert "Error parsing string match '0x1badoffset:$s1: skip this line': " in caplog.text
        assert "Error parsing string match '0x2error scanning skip/this/line/too: need more colons': " in caplog.text

    def test_contrived_scan_output_metadata(self, caplog):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_location with any rule, but its not relevant for the tests
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

        # Matches and metadata for MATCHING_ENTITY_FILE
        # assert "grep -Ebon  -e 'another string match in matching_entity'" in caplog.text
        rule_match = mdc.host_scan['Rule']
        assert rule_match[0]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[0]['string_offset'] == 21
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 1
        assert metadata['line'] == urlencode('This line contains a string match in the file "matching_entity"')

        # Testing displaying long lines
        assert rule_match[1]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[1]['string_offset'] == 83
        metadata = rule_match[1]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 2
        assert metadata['line'] == urlencode('This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o...')

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]['source'] == MATCHING_ENTITY_FILE
        assert rule_match[2]['string_offset'] == 230
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '9dd5c5e00d28520dc9da3c509c0db2a0'
        assert metadata['line_number'] == 4
        assert metadata['line'] == urlencode("""And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough""")

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        # assert "[]' -e 'contains =' -e 'contains '\"'\"''" in caplog.text
        assert rule_match[3]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]['string_offset'] == 2
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'ASCII text'
        assert metadata['mime_type'] == 'text/plain; charset=us-ascii'
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 3
        assert metadata['line'] == urlencode("string match containing error scanning but it's ok because its not in a rule line")

        assert rule_match[4]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]['string_offset'] == 97
        metadata = rule_match[4]['metadata']
        assert metadata['md5sum'] == '64764d295e92ffeec36d3fcd646a3af4'
        assert metadata['line_number'] == 7
        assert metadata['line'] == urlencode("This line contains = char")

        assert rule_match[5]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]['string_offset'] == 123
        metadata = rule_match[5]['metadata']
        assert metadata['line_number'] == 8
        assert metadata['line'] == urlencode("This line contains = char too")

        assert rule_match[6]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]['string_offset'] == 153
        metadata = rule_match[6]['metadata']
        assert metadata['line_number'] == 9
        assert metadata['line'] == urlencode("This line contains .+ chars")

        assert rule_match[8]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]['string_offset'] == 213
        metadata = rule_match[8]['metadata']
        assert metadata['line_number'] == 11
        assert metadata['line'] == urlencode('This line contains "" chars')

        assert rule_match[9]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]['string_offset'] == 241
        metadata = rule_match[9]['metadata']
        assert metadata['line_number'] == 12
        assert metadata['line'] == urlencode("This line contains '' chars")

        assert rule_match[10]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]['string_offset'] == 269
        metadata = rule_match[10]['metadata']
        assert metadata['line_number'] == 13
        assert metadata['line'] == urlencode("This line contains ()[] chars")

        assert rule_match[11]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]['string_offset'] == 299
        metadata = rule_match[11]['metadata']
        assert metadata['line_number'] == 14
        assert metadata['line'] == urlencode("This line contains {} chars")

        assert rule_match[12]['source'] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]['string_offset'] == 327
        metadata = rule_match[12]['metadata']
        assert metadata['line_number'] == 15
        assert metadata['line'] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert rule_match[13]['source'] == "matching_entity_3, but without any string matches - yes that's ok"
        metadata = rule_match[13]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.host_scan['another_matching_rule']
        assert rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar')
        metadata = rule_match[2]['metadata']
        assert metadata['source_type'] == 'file'
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]['source'] == '1234567'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert all([key not in ['process_name', 'file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_matches_scan_output(self, caplog):
        logger.setLevel('INFO')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)

        assert mdc.matches == 4
        # Error won't display when log level is INFO
        assert 'error scanning matches/kcore: error: 4' not in caplog.text
        assert 'Matched rule XFTI_brootkit in file matches/brootkit_match' in caplog.text
        assert 'Matched rule XFTI_FinSpy in file matches/finspy_match' in caplog.text
        assert 'Matched rule XFTI_FritzFrog in file matches/fritzfrog_match' in caplog.text
        assert 'Matched rule XFTI_Mirai in file matches/mirai_match' in caplog.text
        assert len(mdc.host_scan['XFTI_brootkit']) == 4
        assert len(mdc.host_scan['XFTI_FinSpy']) == 7
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 7
        assert len(mdc.host_scan['XFTI_Mirai']) == 5

        # Reduce the string_match_limit and some of the counts will change
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 5
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert len(mdc.host_scan['XFTI_brootkit']) == 4
        assert len(mdc.host_scan['XFTI_FinSpy']) == 5
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 5
        assert len(mdc.host_scan['XFTI_Mirai']) == 5

        # Even with string_match_limit = 0, there will be 1 entry to record the source
        mdc = MalwareDetectionClient(None, malopts)
        mdc.string_match_limit = 0
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert len(mdc.host_scan['XFTI_brootkit']) == 1
        assert len(mdc.host_scan['XFTI_FinSpy']) == 1
        assert len(mdc.host_scan['XFTI_FritzFrog']) == 1
        assert len(mdc.host_scan['XFTI_Mirai']) == 1

        # With debug enabled the 'error scanning ... error: 4' will be logged
        caplog.clear()
        logger.setLevel('DEBUG')
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        assert 'error scanning matches/kcore: error: 4' in caplog.text

    def test_error_scan_output(self, caplog):
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(ERROR_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file' in caplog.text

    def test_error4_scan_output(self, caplog):
        logger.setLevel('DEBUG')
        malopts = get_malware_options(rules_location=RULE_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(ERROR4_SCAN_OUTPUT)

        assert mdc.matches == 0
        assert mdc.host_scan == {}
        assert 'error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4' in caplog.text

    def test_random_output(self):
        malopts = get_malware_options(rules_location=METADATA_TEST_RULE_FILE)
        mdc = MalwareDetectionClient(None, malopts)
        mdc.parse_scan_output(RANDOM_OUTPUT)

        assert mdc.matches == 2
        rule_match = mdc.host_scan['Lorem']
        assert rule_match[0]['source'].startswith('ipsum dolor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1
        rule_match = mdc.host_scan['Dictum']
        assert rule_match[0]['source'].startswith('at tempor')
        assert rule_match[0]['string_data'] == ''
        assert rule_match[0]['string_identifier'] == ''
        assert rule_match[0]['string_offset'] == -1


# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = ['/boot', '/dev', '/etc', '/home', '/opt', '/proc', '/root', '/sys', '/tmp', '/usr', '/var']
INCLUDED_TLDS = ['/boot', '/etc', '/home', '/opt', '/root', '/tmp', '/usr', '/var']  # after removing exclude items
DEFAULT_SCAN_EXCLUDE = ['/cgroup', '/dev', '/media', '/mnt', '/net', '/proc', '/selinux', '/sys']


class TestIncludeExcludeProcessing:

    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list)
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/usr/lib')
        assert sorted(parent_dir_list) == ['/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

        parent_dir_list = []
        get_parent_dirs('/usr/lib/systemd/user/basic.target', parent_dir_list, '/var')
        assert sorted(parent_dir_list) == ['/usr', '/usr/lib', '/usr/lib/systemd', '/usr/lib/systemd/user',
                                           '/usr/lib/systemd/user/basic.target']

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = ['/path/to/some/item/child', '/path/to/another/item', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = ['/var/lib64', '/home/bob', '/var/lib/docker', '/home/bob', '/var/lib',
                 '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child', '/var/lib63/im ok', '/var/lib64/im not']
        assert remove_child_items(items) == ['/home/bob', '/home/bobby-droptables', '/var/lib',
                                             '/var/lib63/im ok', '/var/lib64']

        # /path is common to both so that will be all that is returned
        items = ['/path/to/another/item', '/path/to/some/item', '/path']
        assert remove_child_items(items) == ['/path']

        # The root directory will always win
        items = ['/path/to/another/item', '/path/to/some/item', '/']
        assert remove_child_items(items) == ['/']

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ['/path/to/another/item', '', '/path/to/some/item']
        assert remove_child_items(items) == ['/path/to/another/item', '/path/to/some/item']

    def test_remove_included_excluded_items(self):
        include_items = ['/home/bob', '/tmp', '/var/www/html']
        exclude_items = ['/home/bo', '/home/bob/exclude', '/home/bobby', '/temp', '/var/www']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/home/bob', '/tmp']

        # Some fairly random lists similar to before
        include_items = ['/var/lib64/docker', r'/home/bob/this\ is\ bobs/child', '/var/lib/docker', '/home/bob',
                         '/var/lib', '/usr']
        exclude_items = ['/var/lib/docker2', '/home/bob', '/home/bobby-droptables', r'/home/bob/this\ is\ bobs/child',
                         '/var/lib63/im ok', '/var/lib64/im not', '/boot']
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ['/usr', '/var/lib', '/var/lib64/docker']

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_REASON)
    def test_process_include_items(self, caplog):
        # Call process_include_items with variously populated lists
        logger.setLevel('DEBUG')

        # Add some valid entries to include_items list, esp subdirectories
        include_items = ['/etc/pam.d', '/tmp', '/var/log/']
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/pam.d', '/tmp', '/var/log']

        # Add some more subdirectories
        include_items.extend(['/etc/cron.d', '/tmp', '/var/lib/'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc/cron.d', '/etc/pam.d', '/tmp', '/var/lib', '/var/log']

        # Add some top level directories to override the subdirectories
        include_items.extend(['/etc', '/var'])
        processed_items = process_include_items(include_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries that will get ignored
        caplog.clear()
        include_items.extend(['..', '/var/run', '/missing'])
        processed_items = process_include_items(include_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping link '/var/run' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory (/) which will override all the other entries
        caplog.clear()
        include_items.append('/')
        processed_items = process_include_items(include_items)
        assert "Found root directory in list of items to scan.  Ignoring the other items ..." in caplog.text
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_REASON)
    def test_process_exclude_items(self, caplog):
        # Call process_exclude_items with variously populated lists
        logger.setLevel('DEBUG')

        # Remove the default entries from the exclude file
        processed_items = process_exclude_items()
        assert "No items specified to be excluded" in caplog.text
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ['/etc/ssh', '/tmp', '/var/run/']
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/ssh', '/tmp', '/var/run']

        # Add some more subdirectories
        exclude_items.extend(['/etc/cron.d', '/tmp', '/var/lock/'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc/cron.d', '/etc/ssh', '/tmp', '/var/lock', '/var/run']

        # Add some top level directories to override the subdirectories
        exclude_items.extend(['/etc', '/var'])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add some invalid entries to exclude items
        caplog.clear()
        exclude_items.extend(['..', '/missing'])
        processed_items = process_exclude_items(exclude_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ['/etc', '/tmp', '/var']

        # Add the root directory
        caplog.clear()
        exclude_items.append('/')
        processed_items = process_exclude_items(exclude_items)
        assert "Found root directory in the exclude list.  Expanding it to all toplevel directories ..." in caplog.text
        assert processed_items == get_toplevel_dirs()

    @pytest.mark.skipif(IS_PY26, reason=PY26_SKIP_REASON)
    def test_process_include_exclude_items_simple(self, caplog):
        # Test the process_include_exclude_items function with simple modified include and exclude items
        # Simple in that the include and exclude files are modified in such a way that
        # directory listings aren't required get the list of included files
        logger.setLevel('INFO')

        # Add a single toplevel directory to the include file - expect only a single directory to scan
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only='/etc')
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == ['/etc']
        assert all([d in mdc.scan_exclude_list for d in ['/proc', '/sys', '/mnt', '/media', '/dev']])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']
        assert 'include' not in scan_dict['/etc']
        assert 'exclude' not in scan_dict['/etc']

        # Add some extra subdirectories to scan
        mdc.scan_fsobjects.extend(['/var/lib', '/var/log'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(list(scan_dict['/var']['include'])) == ['/var/lib', '/var/log']
        assert 'exclude' not in scan_dict['/var']

        # Add some extra directories to exclude that won't impact the already included directories
        mdc.scan_exclude_list.extend(['/tmp', '/var/run'])
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert sorted(scan_dict.keys()) == ['/etc', '/var']
        assert sorted(scan_dict['/var']['include']) == ['/var/lib', '/var/log']
        assert scan_dict['/var']['exclude']['items'] == ['/var/run']

        # Exclude /var which will remove it from the list of directories to scan
        mdc.scan_exclude_list.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/etc']

        # Exclude /etc which means there will be no directories to scan
        caplog.clear()
        mdc.scan_exclude_list.append('/etc')
        with pytest.raises(SystemExit) as exc_info:
            process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                          exclude_items=mdc.scan_exclude_list)
        assert "No items to scan because the specified exclude items cancel them out" in caplog.text
        assert exc_info.value.code == constants.sig_kill_bad

    def test_process_include_exclude_files_complex(self):
        # Test the process function with modified include and exclude files that will require more complex
        # processing to generate the list of items to be scanned

        # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
        # We don't need to list the contents of the /var directory
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only=['/var/lib', '/var/log'])
        malopts['scan_exclude'].extend(['/var/lib/systemd', '/var/lib/misc/', '/var/log/wtmp'])
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == ['/var/lib', '/var/log']

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        # The exclude items shouldn't be in the include items
        # Nor should other items that aren't in the explicitly included items
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp',
                              '/var/cache', '/var/lib', '/var/log', '/var/tmp', '/tmp']])
        # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
        # but not the excluded items, eg /var/log/wtmp
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/lib/xkb', '/var/lib/dbus', '/var/log/btmp', '/var/log/lastlog']])

        # Change the include directory to /var
        # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
        # Because now we have to list the contents of the /var and /var/lib directories
        mdc.scan_fsobjects.append('/var')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/var']
        assert sorted(scan_dict['/var']['exclude']['items']) == ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp']
        assert all([x not in scan_dict['/var']['include']
                    for x in ['/var/lib/misc', '/var/lib/systemd', '/var/log/wtmp', '/var/lib', '/var/log', '/tmp']])
        assert all([x in scan_dict['/var']['include']
                    for x in ['/var/cache', '/var/tmp', '/var/lib/xkb', '/var/lib/dbus',
                              '/var/log/btmp', '/var/log/lastlog']])

    @pytest.mark.skipif(IS_QE, reason="Some directories aren't in QE environment")
    def test_process_include_exclude_files_similar_names(self):
        # Now test including/excluding items that have similar names, eg /usr/local/lib and /usr/local/libexec
        # /usr/local has sub directories /usr/local/lib and /usr/local/libexec (ie similar names)
        # If we exclude /usr/local/lib then /usr/local/libexec should still be included
        malopts = get_malware_options(rules_location=COMPILED_RULES_FILE, scan_only='/usr/local')
        malopts['scan_exclude'].append('/usr/local/lib')
        mdc = MalwareDetectionClient(None, malopts)
        assert mdc.scan_fsobjects == ['/usr/local']
        assert '/usr/local/lib' in mdc.scan_exclude_list

        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert list(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib']
        # Ensure /usr/local/lib is NOT in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib']])
        # But ensure /usr/local/libexec IS in the list of items to scan
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share', '/usr/local/libexec']])

        # Add /usr/local/libexec as an item to exclude and ensure both /usr/local/lib and libexec are excluded now
        mdc.scan_exclude_list.append('/usr/local/libexec')
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == ['/usr/local/lib', '/usr/local/libexec']
        # Ensure /usr/local/lib and /usr/local/libexec are both not in the list of items to scan
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/lib', '/usr/local', '/usr/local/lib', '/usr/local/libexec']])
        assert all([x in scan_dict['/usr']['include']
                    for x in ['/usr/local/bin', '/usr/local/share']])

        # Test including /usr/local/lib and excluding an item from it
        # Confirm that only items from /usr/local/lib are included and NOT from any other directory
        usr_local_lib = sorted(filter(lambda x: not os.path.islink(x),
                                      map(lambda x: '/usr/local/lib/' + x, os.listdir('/usr/local/lib'))))
        assert len(usr_local_lib) > 2
        excluded_item1 = usr_local_lib[0]
        excluded_item2 = usr_local_lib[1]
        mdc.scan_fsobjects = ['/usr/local/lib']
        mdc.scan_exclude_list = [excluded_item1, excluded_item2]
        scan_dict = process_include_exclude_items(include_items=mdc.scan_fsobjects,
                                                  exclude_items=mdc.scan_exclude_list)
        assert list(scan_dict.keys()) == ['/usr']
        assert sorted(scan_dict['/usr']['exclude']['items']) == [excluded_item1, excluded_item2]
        # Ensure only /usr/local/lib items are included (except the first 2 in the directory)
        assert all([x not in scan_dict['/usr']['include']
                    for x in ['/usr', '/usr/local', '/usr/local/lib', '/usr/local/libexec',
                              excluded_item1, excluded_item2]])
        assert all([x in scan_dict['/usr']['include'] for x in usr_local_lib[2:]])

    def test_process_include_exclude_tmp_files(self, extract_tmp_files):
        # Test the including/excluding some of the files in the tmp archive
        # Specifically tests excluding link files (good or broken) and pipe files (as well as explicit exclude items)

        include_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me', 'scan_me_too']))
        exclude_items = list(map(lambda x: TEMP_TEST_DIR + x,
                                 ['scan_me_not', 'scan_me/dont_scan_me', 'scan_me_too/dont_scan_me_too']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)
        assert list(scan_dict.keys()) == ['/tmp']
        assert sorted(list(scan_dict['/tmp']['exclude']['items'])) == sorted(exclude_items)

        include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                        ['scan_me/new_file', 'scan_me/old_file', 'scan_me/scan_me',
                                         'scan_me/scan_me_file', 'scan_me_too/new_file', 'scan_me_too/old_file',
                                         'scan_me_too/scan_me_too', 'scan_me_too/scan_me_too_file'])))
        dont_include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                             ['scan_me/link_file', 'scan_me/pipe_file', 'scan_me/broken_link',
                                              'scan_me/dont_scan_me', 'scan_me_too/link_file', 'scan_me_too/pipe_file',
                                              'scan_me_too/broken_link', 'scan_me_too/dont_scan_me_too'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])

        # Another test to assert a bug I found is fixed ... due to only having scan_items = set([])
        # Basically include_files should = ['scan_me/scan_me'] but the bug made include_files = []
        include_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me/scan_me']))
        exclude_items = list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me_not']))
        scan_dict = process_include_exclude_items(include_items=include_items, exclude_items=exclude_items)

        include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x, ['scan_me/scan_me'])))
        assert sorted(scan_dict['/tmp']['include']) == include_files
        dont_include_files = sorted(list(map(lambda x: TEMP_TEST_DIR + x,
                                             ['scan_me/scan_me_file', 'scan_me/dont_scan_me', 'scan_me/scan_me/here_i_am'])))
        assert all([x not in scan_dict['/tmp']['include'] for x in dont_include_files])


if __name__ == '__main__':
    print(MISC_DIR)
    print(RULE_RULE_FILE)

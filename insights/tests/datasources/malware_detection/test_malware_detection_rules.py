# -*- coding: UTF-8 -*-
import pytest
import os

from mock.mock import patch, Mock, ANY

from insights.client.config import InsightsConfig

from insights.specs.datasources.malware_detection.scan import ScanManager
from insights.specs.datasources.malware_detection.rules import InsightsConnection
from insights.specs.datasources.malware_detection import MalwareDetectionClient
from insights.tests.datasources.malware_detection.conftest import (
    CONFIG,
    CONFIG_CALL_TARGET,
    TEST_ALL,
    CLIENT_LOGGER_TARGET,
    TEST_DOWNLOAD_FAILURE_RETRIES,
    FINDMNT_TARGET,
    DOWNLOAD_RULES_TARGET,
    TEST_GET_DISABLED_RULES_FAILURE,
    FAKE_YARA,
    FAKE_YARA_VERSION,
    RULES_LOGGER_TARGET,
    NAMEDTMPFILE_TARGET,
    LOAD_CONFIG_TARGET,
    FIND_YARA_TARGET,
)

config = InsightsConfig(
    legacy_upload=True, base_url="localhost/app", systemid="", proxy=None
)


# Use patch.object, just because I wanted to try using patch.object instead of using patch all the time :shrug:
@patch(
    NAMEDTMPFILE_TARGET
)  # Mock NamedTemporaryFile so it doesn't try to create the temporary file
@patch(
    "os.remove"
)  # Mock os.remove so it doesn't actually try to remove any existing files
@patch.object(ScanManager, "_parse_exclude_network_filesystem_mountpoints_option")
@patch.object(
    InsightsConnection,
    "get",
    return_value=Mock(status_code=200, content=b"Rule Content"),
)
@patch.object(InsightsConnection, "get_proxies")
@patch.object(InsightsConnection, "_init_session", return_value=Mock())
# NOTE: Downloading the malware rules file happens within the malware client code so it's possible to test it here
# However uploading the results archive is done outside the malware client code so it's not possible to test here
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestGetRules:
    """Testing the _get_rules method"""

    @patch.dict(os.environ, {"TEST_SCAN": "true"})
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    def test_download_rules_cert_auth(
        self,
        yara,
        config_mock,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
        create_test_files_fake_yara,
    ):
        # Test the standard rules_location urls, but will result in cert auth being used to download the rules
        # Test with insights-config None, expect an error when trying to use the insights-config object
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(None)
            mdc.parse_scan_options()
            mdc.load_rules()
        session.assert_not_called()

        # With default insights config and test scan true ...
        # Expect to use cert auth because no username or password specified and expect to download test-rule.yar
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
        )
        assert mdc.rule_manager.rules_files[0].startswith(
            "/tmp"
        )  # rules will be saved into a temp file
        get.assert_called_with(
            "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar",
            log_response_text=True,
            verify=True,
            stream=True,
        )

        # With authmethod=CERT, expect 'cert.' to be prefixed to the url
        mdc = MalwareDetectionClient(InsightsConfig(authmethod="CERT"))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
        )
        get.assert_called_with(
            "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar",
            log_response_text=True,
            verify=True,
            stream=True,
        )

        # With authmethod=BASIC and test scan false ...
        # Expect to still use cert auth because no username or password specified
        os.environ["TEST_SCAN"] = "false"
        mdc = MalwareDetectionClient(InsightsConfig(authmethod="BASIC"))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version=4.1.0"
        )
        get.assert_called_with(
            "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version=4.1.0",
            log_response_text=False,
            verify=True,
            stream=True,
        )

        mdc = MalwareDetectionClient(InsightsConfig(authmethod="CERT"))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version=4.1.0"
        )
        get.assert_called_with(
            "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version=4.1.0",
            log_response_text=False,
            verify=True,
            stream=True,
        )

    @patch.dict(os.environ, {"TEST_SCAN": "true"})
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    @patch(RULES_LOGGER_TARGET)
    def test_download_rules_basic_auth(
        self,
        rules_log_mock,
        yara,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        # Test the standard rules_location urls, with basic auth attempting to be used to download the rules
        # Basic auth is used by default, but needs to have a valid username and password for it to work
        # Without a username and password, then cert auth will be used
        expected_rules_url = (
            "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
        )

        # Test with just a username specified - expect basic auth to be used but fails
        get.return_value = Mock(
            status_code=401, reason="Unauthorized", text="No can do"
        )
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(username="user"))
            mdc.parse_scan_options()
            mdc.load_rules()
        get.assert_called_with(
            expected_rules_url, log_response_text=True, verify=True, stream=True
        )
        rules_log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "401 Unauthorized: No can do",
        )

        # Test with just a password specified - expect basic auth to be used but fails
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(password="pass"))
            mdc.parse_scan_options()
            mdc.load_rules()
        get.assert_called_with(
            expected_rules_url, log_response_text=True, verify=True, stream=True
        )
        rules_log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "401 Unauthorized: No can do",
        )

        # Test with 'incorrect' username and/or password - expect basic auth failure
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(
                InsightsConfig(username="user", password="badpass")
            )
            mdc.parse_scan_options()
            mdc.load_rules()
        get.assert_called_with(
            expected_rules_url, log_response_text=True, verify=True, stream=True
        )
        rules_log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "401 Unauthorized: No can do",
        )

        # Test with 'correct' username and password - expect basic auth success
        get.return_value = Mock(status_code=200, content=b"Rule Content")
        mdc = MalwareDetectionClient(
            InsightsConfig(username="user", password="goodpass")
        )
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=True, verify=True, stream=True
        )

    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    @patch(
        "os.path.exists", return_value=True
    )  # mock call to os.path.exists in _find_yara
    @patch(CONFIG_CALL_TARGET, return_value="4.2.1")  # mock call to 'yara --version'
    def test_download_rules_versioned_files(
        self,
        version_mock,
        exists_mock,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        # Test downloading different signatures files depending on the yara version found on the system
        expected_rules_url = (
            "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        )
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.config.yara_version == "4.2.1"
        assert (
            mdc.config.remote_rules_location
            == expected_rules_url + "?yara_version=4.2.1"
        )
        get.assert_called_with(
            expected_rules_url + "?yara_version=4.2.1",
            log_response_text=False,
            verify=True,
            stream=True,
        )

        version_mock.return_value = "4.1.0"
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == expected_rules_url + "?yara_version=4.1.0"
        )
        get.assert_called_with(
            expected_rules_url + "?yara_version=4.1.0",
            log_response_text=False,
            verify=True,
            stream=True,
        )

        version_mock.return_value = "10.100"
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == expected_rules_url + "?yara_version=10.100"
        )
        get.assert_called_with(
            expected_rules_url + "?yara_version=10.100",
            log_response_text=False,
            verify=True,
            stream=True,
        )

        # Bypass the _find_yara method so self.yara_version isn't set
        with patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, None)):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        assert not mdc.config.yara_version
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=True, stream=True
        )

    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    @patch(
        "os.path.exists", return_value=True
    )  # mock call to os.path.exists in _find_yara
    @patch(CONFIG_CALL_TARGET, return_value="4.2.0")  # mock call to 'yara --version'
    def test_download_rules_from_stage(
        self,
        version_mock,
        exists_mock,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        # Test downloading signatures files from the stage environment
        # cert_verify is set to 'False' (string) for stage - check its changed to False (boolean)

        base_url = "cert.console.stage.example.com:443/r/insights"
        expected_rules_url = "https://cert.console.stage.example.com/api/malware-detection/v1/signatures.yar?yara_version=4.2.0"
        mdc = MalwareDetectionClient(
            InsightsConfig(base_url=base_url, cert_verify="False")
        )
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.config.yara_version == "4.2.0"
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=False, stream=True
        )

        for base_url in (
            "cert.console.stage.example.com/r/insights",
            "cert.console.stage.example.com",
        ):
            mdc = MalwareDetectionClient(
                InsightsConfig(base_url=base_url, cert_verify="false")
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.config.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=False,
                stream=True,
            )

        base_url = "https://cert.console.stage.example.com:443/r/insights"
        expected_rules_url = "https://cert.console.stage.example.com:443/api/malware-detection/v1/signatures.yar?yara_version=4.2.0"
        mdc = MalwareDetectionClient(
            InsightsConfig(base_url=base_url, cert_verify="True")
        )
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=True, stream=True
        )

        os.environ["TEST_SCAN"] = "true"
        base_url = "cloud.stage.example.com"
        expected_rules_url = (
            "https://cloud.stage.example.com/api/malware-detection/v1/test-rule.yar"
        )
        mdc = MalwareDetectionClient(InsightsConfig(base_url=base_url, cert_verify=""))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=True, verify=True, stream=True
        )

    @patch.dict(
        os.environ,
        {
            "TEST_SCAN": "true",
            "REMOTE_RULES_LOCATION": "console.redhat.com/rules.yar",
        },
    )
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    def test_get_rules_missing_protocol(
        self, yara, conf, session, proxies, get, findmnt, remove, tmpfile
    ):
        # Non-standard rules URLS - without https:// at the start and not signatures.yar
        # test-scan true and BASIC auth by default expect test-rule.yar and no 'cert.' in URL
        mdc = MalwareDetectionClient(InsightsConfig(username="user", password="pass"))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://console.redhat.com/test-rule.yar"
        )
        get.assert_called_with(
            "https://console.redhat.com/test-rule.yar",
            log_response_text=True,
            verify=True,
            stream=True,
        )

        # test-scan false and CERT auth - expect 'cert.' prefixed to the URL and not test-rule.yar
        os.environ["TEST_SCAN"] = "false"
        mdc = MalwareDetectionClient(InsightsConfig(authmethod="CERT"))
        mdc.parse_scan_options()
        mdc.load_rules()
        assert (
            mdc.config.remote_rules_location
            == "https://cert.console.redhat.com/rules.yar"
        )
        get.assert_called_with(
            "https://cert.console.redhat.com/rules.yar",
            log_response_text=False,
            verify=True,
            stream=True,
        )

    @patch.dict(
        os.environ,
        {
            "TEST_SCAN": "false",
            "REMOTE_RULES_LOCATION": "http://localhost/rules.yar",
        },
    )
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    @patch(RULES_LOGGER_TARGET)
    def test_download_failures(
        self,
        log_mock,
        yara,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        from requests.exceptions import ConnectionError, Timeout

        # Test various problems downloading rules
        expected_rules_url = os.environ["REMOTE_RULES_LOCATION"]

        # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
        get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig())
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "404 Not found: Nup",
        )
        assert get.call_count == 1

        # Test other errors downloading rules from the backend - these are more likely to occur
        # Firstly handling an error like connection refused (Couldn't connect)
        get.side_effect = [ConnectionError("Couldn't connect"), Timeout("Timeout")]
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(
                InsightsConfig(username="user", password="pass")
            )
            mdc.parse_scan_options()
            mdc.load_rules()

        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "Couldn't connect",
        )
        assert get.call_count == 2

        # Then handling a Timeout error
        # Note, because we aren't downloading from console.redhat.com, there won't be 'cert.*' appended to the URL
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig())
            mdc.parse_scan_options()
            mdc.load_rules()

        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s", expected_rules_url, "Timeout"
        )
        assert get.call_count == 3

    @pytest.mark.skipif(
        not (TEST_DOWNLOAD_FAILURE_RETRIES or TEST_ALL),
        reason="test_download_failure_retries is slow due to the inherent delay in the retry logic. "
        "Use TEST_DOWNLOAD_FAILURE_RETRIES=True to enable test",
    )
    @patch.dict(
        os.environ,
        {
            "TEST_SCAN": "false",
            "REMOTE_RULES_LOCATION": "http://localhost/rules.yar",
        },
    )
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    @patch("os.path.isfile", return_value=True)
    @patch(RULES_LOGGER_TARGET)
    @patch(CLIENT_LOGGER_TARGET)
    def test_download_failure_retries(
        self,
        client_log_mock,
        log_mock,
        isfile,
        yara,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        from requests.exceptions import ConnectionError, SSLError

        # Testing the download failure retry logic
        expected_rules_url = os.environ["REMOTE_RULES_LOCATION"]

        # Status code != 200 will trigger a retry, but only if retries > 1
        get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(retries=1))
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "404 Not found: Nup",
        )
        # Last call to logger.debug will be about downloading rules, not about retrying, which shows retrying wasn't invoked
        client_log_mock.debug.assert_called_with("Using cert_verify value %s ...", True)
        client_log_mock.debug.assert_any_call(
            "Downloading rules from: %s", expected_rules_url
        )

        # Set retries > 1 and now retrying happens
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(retries=2))
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "404 Not found: Nup",
        )
        # This time, the last call to logger.debug will be about retrying the download
        log_mock.debug.assert_called_with("Trying again in %d seconds ...", 1)

        # Other network errors that raise an exception will trigger a retry
        get.side_effect = ConnectionError("Couldn't connect")
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(retries=3))
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s",
            expected_rules_url,
            "Couldn't connect",
        )
        # Because we've set retries to 3, the last attempted retry will wait 2 seconds
        log_mock.debug.assert_called_with("Trying again in %d seconds ...", 2)

        # Certificate verify failed SSL Errors will cause a different CA certificate bundle to be tried
        ca_cert = "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"  # default ca cert bundle file to try
        ssl_error = "SSL Error: certificate verify failed"
        get.side_effect = SSLError(ssl_error)
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(retries=2))
            mdc.parse_scan_options()
            mdc.load_rules()
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=ca_cert, stream=True
        )
        log_mock.debug.assert_called_with("Trying cert_verify value %s ...", ca_cert)
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s", expected_rules_url, ssl_error
        )

        # CA certificate bundles can be specified in the config file or via env vars too
        ca_cert = "/some/cert/file.crt"
        os.environ["CA_CERT"] = (
            ca_cert  # customers can specify their own ca bundle file via config/env vars
        )
        ssl_error = "SslError CERTIFICATE_VERIFY_FAILED"
        get.side_effect = SSLError(ssl_error)
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(InsightsConfig(retries=2))
            mdc.parse_scan_options()
            mdc.load_rules()
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=ca_cert, stream=True
        )
        log_mock.debug.assert_called_with("Trying cert_verify value %s ...", ca_cert)
        log_mock.error.assert_called_with(
            "Unable to download rules from %s: %s", expected_rules_url, ssl_error
        )

    @patch.dict(
        os.environ,
        {
            "TEST_SCAN": "true",
            "REMOTE_RULES_LOCATION": "//console.redhat.com/rules.yar",
        },
    )
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    @patch("os.path.isfile", return_value=True)
    @patch(CLIENT_LOGGER_TARGET)
    def test_get_remote_rules_location_as_file(
        self,
        log_mock,
        isfile,
        yara,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        # Test using files for remote_rules_location, esp irregular file names
        # rules_location that starts with a '/' is assumed to be a file, even if its a double '//'
        # Re-writing the rule to be test-rule.yar doesn't apply to local files
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "REMOTE_RULES_LOCATION should be an url not local file"
        )
        assert mdc.config.remote_rules_location == "//console.redhat.com/rules.yar"
        assert "//console.redhat.com/rules.yar" not in mdc.rule_manager.rules_files
        get.assert_not_called()

        # Just to confirm the filename stays the same for regardless of test_rule value
        os.environ["TEST_SCAN"] = "false"
        with pytest.raises(SystemExit):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        log_mock.error.assert_called_with(
            "REMOTE_RULES_LOCATION should be an url not local file"
        )
        assert mdc.config.remote_rules_location == "//console.redhat.com/rules.yar"
        assert "//console.redhat.com/rules.yar" not in mdc.rule_manager.rules_files
        get.assert_not_called()

    @patch.dict(os.environ, {"TEST_SCAN": "true"})
    @patch(CLIENT_LOGGER_TARGET)
    def test_download_rules_via_satellite(
        self, log_mock, conf, session, proxies, get, findmnt, remove, tmpfile
    ):
        # Test recognizing and handling of Satellite URLs.
        # Satellite URLs have '/redhat_access/' in their path (so Satellite knows to redirect the query to C.R.C)
        # For malware-detection requests through a Satellite we append the malware-detection path and add https://
        satellite_url = "satellite.example.com:443/redhat_access/r/insights/platform"
        satellite_cert = "/etc/rhsm/ca/katello-server-ca.pem"
        expected_rules_url_prefix = "https://satellite.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/"
        insights_config = InsightsConfig(
            base_url=satellite_url, verbose=True, cert_verify=satellite_cert
        )

        # Firstly try with test-rule
        expected_rules_url = expected_rules_url_prefix + "test-rule.yar"
        with patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION)):
            mdc = MalwareDetectionClient(insights_config)
            mdc.parse_scan_options()
            mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url,
            log_response_text=True,
            verify=satellite_cert,
            stream=True,
        )
        log_mock.debug.assert_called_with(
            "Using cert_verify value %s ...", satellite_cert
        )
        log_mock.debug.assert_any_call("Downloading rules from: %s", expected_rules_url)

        # Then with the actual rules file
        os.environ["TEST_SCAN"] = "false"
        expected_rules_url = expected_rules_url_prefix + "signatures.yar"
        with patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, None)):
            mdc = MalwareDetectionClient(insights_config)
            mdc.parse_scan_options()
            mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url,
            log_response_text=False,
            verify=satellite_cert,
            stream=True,
        )
        log_mock.debug.assert_called_with(
            "Using cert_verify value %s ...", satellite_cert
        )
        log_mock.debug.assert_any_call("Downloading rules from: %s", expected_rules_url)

        expected_rules_url += "?yara_version=4.1"
        with patch("os.path.exists", return_value=True):
            with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                mdc = MalwareDetectionClient(insights_config)
                mdc.parse_scan_options()
                mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url,
            log_response_text=False,
            verify=satellite_cert,
            stream=True,
        )
        log_mock.debug.assert_called_with(
            "Using cert_verify value %s ...", satellite_cert
        )
        log_mock.debug.assert_any_call("Downloading rules from: %s", expected_rules_url)

        # Test a Satellite URL with 'cloud.stage.' in its name - expect to still download from Satellite
        # Also test using cert_verify=None in the InsightsConfig and check it changes to cert_verify=True
        satellite_url = (
            "satellite.cloud.stage.example.com:443/redhat_access/r/insights/platform"
        )
        expected_rules_url = "https://satellite.cloud.stage.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/"
        expected_rules_url += "signatures.yar?yara_version=4.1"
        with patch("os.path.exists", return_value=True):
            with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                mdc = MalwareDetectionClient(
                    InsightsConfig(
                        base_url=satellite_url, verbose=True, cert_verify=None
                    )
                )
                mdc.parse_scan_options()
                mdc.load_rules()
        assert mdc.config.remote_rules_location == expected_rules_url
        get.assert_called_with(
            expected_rules_url, log_response_text=False, verify=True, stream=True
        )
        log_mock.debug.assert_called_with("Using cert_verify value %s ...", True)
        log_mock.debug.assert_any_call("Downloading rules from: %s", expected_rules_url)

    @patch.dict(os.environ, {"TEST_SCAN": "true"})
    @patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
    def test_change_url_path(
        self,
        yara,
        conf,
        session,
        proxies,
        get,
        findmnt,
        remove,
        tmpfile,
    ):
        # test the _change_url_path function
        mdc = MalwareDetectionClient(InsightsConfig(username="user", password="pass"))
        url = mdc.rule_manager._change_url_path("test/test", "test")
        assert url == "test/test"


@patch(
    NAMEDTMPFILE_TARGET
)  # Mock NamedTemporaryFile so it doesn't try to create the temporary file
@patch(
    "os.remove"
)  # Mock os.remove so it doesn't actually try to remove any existing files
@patch(FINDMNT_TARGET)  # Don't run the command
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, None))
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestDisabledRules:
    """Testing the _get_disabled_rules method"""

    @patch.dict(os.environ)
    def test_skip_getting_disabled_rules(self, conf, yara, findmnt, remove, tmpfile):
        # Skip getting disabled rules if doing a test scan
        os.environ["TEST_SCAN"] = "true"
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_disabled_rules()
        assert mdc.rule_manager.disabled_rules == []

        # Skip getting disabled rules if the rules are coming from a file (which is really only for testing anyway)
        os.environ["TEST_SCAN"] = "false"
        os.environ["USE_REMOTE_RULES"] = "false"
        with patch("os.path.isfile", return_value=True):
            mdc = MalwareDetectionClient(None)
            mdc.parse_scan_options()
            mdc.load_disabled_rules()
        assert mdc.rule_manager.disabled_rules == []

    @patch.object(InsightsConnection, "post")
    @patch.object(
        InsightsConnection,
        "get",
        return_value=Mock(status_code=200, content=b"Rule Content"),
    )
    @patch.object(InsightsConnection, "get_proxies")
    @patch.object(InsightsConnection, "_init_session", return_value=Mock())
    @patch(DOWNLOAD_RULES_TARGET)
    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    def test_get_disabled_rules(
        self,
        download_rules,
        session,
        proxies,
        get,
        post,
        conf,
        yara,
        findmnt,
        remove,
        tmpfile,
    ):
        # Test with no disabled rules
        remote_rules_location = (
            "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
        )
        expected_graphql_url = (
            "https://cert.console.redhat.com/api/malware-detection/v1/graphql"
        )
        post.return_value = Mock(
            status_code=200, json=Mock(return_value={"data": {"rulesList": []}})
        )
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.load_disabled_rules()
        assert mdc.config.remote_rules_location == remote_rules_location
        assert post.called_with(
            expected_graphql_url, ANY, ANY, verify=True, stream=True
        )
        assert mdc.rule_manager.disabled_rules == []

        # Test with one disabled rule
        post.return_value = Mock(
            status_code=200,
            json=Mock(return_value={"data": {"rulesList": [{"name": "Rule1"}]}}),
        )
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_disabled_rules()
        assert mdc.rule_manager.disabled_rules == ["rule1"]

        # Test with multiple disabled rules and a different rules_location
        remote_rules_location = "http://localhost/rules.yar"
        os.environ["REMOTE_RULES_LOCATION"] = remote_rules_location
        expected_graphql_url = "http://localhost/graphql"
        post.return_value = Mock(
            status_code=200,
            json=Mock(
                return_value={
                    "data": {
                        "rulesList": [
                            {"name": "Rule2"},
                            {"name": "Rule1"},
                            {"name": "XYZ"},
                            {"name": "abc"},
                        ]
                    }
                }
            ),
        )
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.load_disabled_rules()
        assert mdc.config.remote_rules_location == remote_rules_location
        assert post.called_with(
            expected_graphql_url, ANY, ANY, verify=True, stream=True
        )
        assert mdc.rule_manager.disabled_rules == ["abc", "rule1", "rule2", "xyz"]

    @pytest.mark.skipif(
        not (TEST_GET_DISABLED_RULES_FAILURE or TEST_ALL),
        reason="test_get_disabled_rules_failure_retries is slow due to the inherent delay in the retry logic. "
        "Use TEST_GET_DISABLED_RULES_FAILURE=True to enable test",
    )
    @patch.object(InsightsConnection, "post")
    @patch.object(
        InsightsConnection,
        "get",
        return_value=Mock(status_code=200, content=b"Rule Content"),
    )
    @patch.object(InsightsConnection, "get_proxies")
    @patch.object(InsightsConnection, "_init_session", return_value=Mock())
    @patch.dict(
        os.environ,
        {"TEST_SCAN": "false", "REMOTE_RULES_LOCATION": "localhost/rules.yar"},
    )
    @patch(DOWNLOAD_RULES_TARGET)
    @patch(RULES_LOGGER_TARGET)
    @patch(CLIENT_LOGGER_TARGET)
    def test_get_disabled_rules_failure(
        self,
        client_log,
        log,
        download_rules,
        session,
        proxies,
        get,
        post,
        conf,
        yara,
        findmnt,
        remove,
        tmpfile,
    ):
        from requests.exceptions import ConnectionError, Timeout

        expected_graphql_url = "https://localhost/graphql"

        # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
        post.return_value = Mock(status_code=404, reason="Not found", text="Nup")
        mdc = MalwareDetectionClient(InsightsConfig(retries=2))
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.load_disabled_rules()
        log.debug.assert_any_call(
            "Failed to get disabled rules from %s (attempt 1): %s"
            % (expected_graphql_url, "404 Not found")
        )
        log.debug.assert_any_call("Unable to get disabled rules list. Skipping ...")
        client_log.debug.assert_called_with("Disabled rules: %s", [])
        assert post.called_with(
            expected_graphql_url, ANY, ANY, verify=True, stream=True
        )
        assert post.call_count == 2
        assert mdc.rule_manager.disabled_rules == []

        # Test other errors downloading rules from the backend - these are more likely to occur
        post.reset_mock()
        post.side_effect = [ConnectionError("Couldn't connect"), Timeout("Timeout")]
        mdc = MalwareDetectionClient(InsightsConfig(retries=3))
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.load_disabled_rules()
        log.debug.assert_any_call(
            "Failed to get disabled rules from %s (attempt 1): %s"
            % (expected_graphql_url, "Couldn't connect")
        )
        log.debug.assert_any_call(
            "Failed to get disabled rules from %s (attempt 2): %s"
            % (expected_graphql_url, "Timeout")
        )
        log.debug.assert_any_call("Unable to get disabled rules list. Skipping ...")
        client_log.debug.assert_called_with("Disabled rules: %s", [])
        assert post.called_with(
            expected_graphql_url, ANY, ANY, verify=True, stream=True
        )
        assert post.call_count == 3
        assert mdc.rule_manager.disabled_rules == []

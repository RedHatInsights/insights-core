# -*- coding: UTF-8 -*-
import os
import re
import pytest

from mock.mock import patch, ANY

try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from insights.client.config import InsightsConfig
from insights.specs.datasources.malware_detection import MalwareDetectionClient
from insights.tests.datasources.malware_detection.conftest import (
    CONTRIVED_SCAN_OUTPUT,
    MATCHING_ENTITY_FILE,
    ANOTHER_MATCHING_ENTITY_FILE,
    RANDOM_OUTPUT,
    RESULTS_LOGGER_TARGET,
    LOAD_CONFIG_TARGET,
    FINDMNT_TARGET,
    FIND_YARA_TARGET,
    CONFIG,
    FAKE_YARA,
    FAKE_YARA_VERSION,
)


config = InsightsConfig(
    legacy_upload=True, base_url="localhost/app", systemid="", proxy=None
)


@patch(FINDMNT_TARGET)
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {"TEST_SCAN": "false", "USE_REMOTE_RULES": "false"})
class TestParseScanOutput:

    @patch(RESULTS_LOGGER_TARGET)
    def test_empty_scan_results(self, log_mock, conf, yara, findmnt):
        # attempt to parse a scan result and assert correct errors are generated
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.scan_results.process_scan_results(mdc.config)
        log_mock.info.assert_any_call("No rule matches found.\n")
        mdc.scan_results.potential_matches = 1
        mdc.scan_results.process_scan_results(mdc.config)
        log_mock.info.assert_any_call(
            "Rule matches potentially found but problems encountered parsing them, so no match data to upload."
        )
        log_mock.info.assert_any_call("Please contact support.\n")

    def test_contrived_scan_output(self, conf, yara, findmnt):
        # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.rule_manager.disabled_rules == []
        mdc.config.add_metadata = False
        mdc.scan_results.parse_scan_output(
            CONTRIVED_SCAN_OUTPUT, mdc.rule_manager.disabled_rules
        )

        # Expect 5 rule matches and 8 source/file matches across the 5 rules
        # 1 source/file match for rule 'this', 3 source/file matches for rule 'Rule',
        # 2 for 'another_matching_rule', 1 for 'Iyamtho' and 1 for 'n_m3_t00'
        assert len(mdc.scan_results.host_scan) == 5  # 5 rules matched
        assert (
            mdc.scan_results.matches == 8
        )  # 8 sources/files matched across the 5 rules

        # 1 matching source/file and 1 matching string for rule 'this'
        rule_match = mdc.scan_results.host_scan["this"]
        rule_sources = set(map(lambda x: x["source"], rule_match))
        assert len(rule_sources) == 1
        assert len(rule_match) == 1
        assert "e-r-r-o-r s-c-a-n-n-i-n-g" in rule_match[0]["source"]
        assert rule_match[0]["string_data"] == "matches 'this' rule"
        assert rule_match[0]["string_identifier"] == "$match"
        assert rule_match[0]["string_offset"] == 291

        # 3 source/file matches and 14 matching strings across those sources for rule 'Rule'
        rule_match = mdc.scan_results.host_scan["Rule"]
        rule_sources = set(map(lambda x: x["source"], rule_match))
        assert len(rule_sources) == 3
        assert len(rule_match) == 14
        assert rule_match[0]["source"] == MATCHING_ENTITY_FILE
        assert (
            rule_match[0]["string_data"] == 'string match in the file "matching_entity"'
        )
        assert rule_match[0]["string_identifier"] == "$match0"
        assert rule_match[0]["string_offset"] == 21
        assert rule_match[1]["source"] == MATCHING_ENTITY_FILE
        assert rule_match[1]["string_data"] == "another string match in matching_entity"
        assert rule_match[1]["string_identifier"] == "$match1"
        assert rule_match[1]["string_offset"] == 83
        assert rule_match[2]["source"] == MATCHING_ENTITY_FILE
        assert (
            rule_match[2]["string_data"]
            == "string with different types of quotes 'here' and \"here\""
        )
        assert rule_match[2]["string_identifier"] == "$match2"
        assert rule_match[2]["string_offset"] == 230

        # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
        assert rule_match[3]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert (
            rule_match[3]["string_data"]
            == "string match containing error scanning but it's ok because its not in a rule line"
        )
        assert rule_match[3]["string_identifier"] == "$match3"
        assert rule_match[3]["string_offset"] == 2
        assert rule_match[4]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]["string_data"] == "contains ="
        assert rule_match[4]["string_identifier"] == "$grep1"
        assert rule_match[4]["string_offset"] == 97
        assert rule_match[6]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]["string_data"] == "contains .+"
        assert rule_match[6]["string_identifier"] == "$grep2"
        assert rule_match[6]["string_offset"] == 153
        assert rule_match[8]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]["string_data"] == 'contains "'
        assert rule_match[8]["string_identifier"] == "$grep3"
        assert rule_match[8]["string_offset"] == 213
        assert rule_match[9]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]["string_data"] == "contains '"
        assert rule_match[9]["string_identifier"] == "$grep4"
        assert rule_match[9]["string_offset"] == 241
        assert rule_match[10]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]["string_data"] == "contains ()[]"
        assert rule_match[10]["string_identifier"] == "$grep5"
        assert rule_match[10]["string_offset"] == 269
        assert rule_match[11]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]["string_data"] == "contains {"
        assert rule_match[11]["string_identifier"] == "$grep6"
        assert rule_match[11]["string_offset"] == 299
        assert rule_match[12]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]["string_data"] == "contains ^$"
        assert rule_match[12]["string_identifier"] == "$grep7"
        assert rule_match[12]["string_offset"] == 327

        assert rule_match[13]["source"].startswith("matching_entity_3")
        assert rule_match[13]["string_data"] == ""
        assert rule_match[13]["string_identifier"] == ""
        assert rule_match[13]["string_offset"] == -1

        # 2 source matches and 4 matching strings for 'another_matching_rule'
        rule_match = mdc.scan_results.host_scan["another_matching_rule"]
        rule_sources = set(map(lambda x: x["source"], rule_match))
        assert len(rule_sources) == 2
        assert len(rule_match) == 4
        assert rule_match[2]["source"].endswith(
            "snap/signal-desktop/350/opt/Signal/resources/app.asar"
        )
        assert rule_match[2]["string_data"] == "#!/bin/sh"
        assert rule_match[2]["string_identifier"] == "$s0"
        assert rule_match[2]["string_offset"] == 60783814
        assert rule_match[3]["source"] == "1234567"
        assert rule_match[3]["string_data"] == "#!/bin/sh"
        assert rule_match[3]["string_identifier"] == "$s0"
        assert rule_match[3]["string_offset"] == 0

        # 1 matching source and 1 matching string for 'Iyamtho'
        rule_match = mdc.scan_results.host_scan["Iyamtho"]
        assert len(rule_match) == 1
        assert rule_match[0]["source"] == "yep"
        assert rule_match[0]["string_data"] == ""
        assert rule_match[0]["string_identifier"] == ""
        assert rule_match[0]["string_offset"] == -1

        # 1 matching source and 1 matching string for 'n_m3_t00'
        rule_match = mdc.scan_results.host_scan["n_m3_t00"]
        assert len(rule_match) == 1
        assert rule_match[0]["source"] == "damn   straight"
        assert rule_match[0]["string_data"] == ""
        assert rule_match[0]["string_identifier"] == ""
        assert rule_match[0]["string_offset"] == -1

    def test_contrived_scan_output_metadata(
        self, conf, yara, findmnt, create_test_files_fake_yara
    ):
        # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
        # but this time check the expected metadata values too

        # Again, need to populate rules_file_location with any rule, but its not relevant for the tests
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.scan_results.parse_scan_output(
            CONTRIVED_SCAN_OUTPUT, mdc.rule_manager.disabled_rules
        )

        # Matches and metadata for MATCHING_ENTITY_FILE
        rule_match = mdc.scan_results.host_scan["Rule"]
        assert rule_match[0]["source"] == MATCHING_ENTITY_FILE
        assert rule_match[0]["string_offset"] == 21
        metadata = rule_match[0]["metadata"]
        assert metadata["source_type"] == "file"
        assert metadata["file_type"] == "ASCII text"
        assert metadata["mime_type"] == "text/plain; charset=us-ascii"
        assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
        assert metadata["line_number"] == 1
        assert metadata["line"] == urlencode(
            'This line contains a string match in the file "matching_entity"'
        )

        # Testing displaying long lines
        assert rule_match[1]["source"] == MATCHING_ENTITY_FILE
        assert rule_match[1]["string_offset"] == 83
        metadata = rule_match[1]["metadata"]
        assert metadata["source_type"] == "file"
        assert metadata["file_type"] == "ASCII text"
        assert metadata["mime_type"] == "text/plain; charset=us-ascii"
        assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
        assert metadata["line_number"] == 2
        assert metadata["line"] == urlencode(
            "This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o..."
        )

        # Testing matching/displaying a mixture of quote types in the string_data
        assert rule_match[2]["source"] == MATCHING_ENTITY_FILE
        assert rule_match[2]["string_offset"] == 230
        metadata = rule_match[2]["metadata"]
        assert metadata["source_type"] == "file"
        assert metadata["file_type"] == "ASCII text"
        assert metadata["mime_type"] == "text/plain; charset=us-ascii"
        assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
        assert metadata["line_number"] == 4
        assert metadata["line"] == urlencode(
            """And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough"""
        )

        # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[3]["string_offset"] == 2
        metadata = rule_match[3]["metadata"]
        assert metadata["source_type"] == "file"
        assert metadata["file_type"] == "ASCII text"
        assert metadata["mime_type"] == "text/plain; charset=us-ascii"
        assert metadata["md5sum"] == "64764d295e92ffeec36d3fcd646a3af4"
        assert metadata["line_number"] == 3
        assert metadata["line"] == urlencode(
            "string match containing error scanning but it's ok because its not in a rule line"
        )

        assert rule_match[4]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[4]["string_offset"] == 97
        metadata = rule_match[4]["metadata"]
        assert metadata["md5sum"] == "64764d295e92ffeec36d3fcd646a3af4"
        assert metadata["line_number"] == 7
        assert metadata["line"] == urlencode("This line contains = char")

        assert rule_match[5]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[5]["string_offset"] == 123
        metadata = rule_match[5]["metadata"]
        assert metadata["line_number"] == 8
        assert metadata["line"] == urlencode("This line contains = char too")

        assert rule_match[6]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[6]["string_offset"] == 153
        metadata = rule_match[6]["metadata"]
        assert metadata["line_number"] == 9
        assert metadata["line"] == urlencode("This line contains .+ chars")

        assert rule_match[8]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[8]["string_offset"] == 213
        metadata = rule_match[8]["metadata"]
        assert metadata["line_number"] == 11
        assert metadata["line"] == urlencode('This line contains "" chars')

        assert rule_match[9]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[9]["string_offset"] == 241
        metadata = rule_match[9]["metadata"]
        assert metadata["line_number"] == 12
        assert metadata["line"] == urlencode("This line contains '' chars")

        assert rule_match[10]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[10]["string_offset"] == 269
        metadata = rule_match[10]["metadata"]
        assert metadata["line_number"] == 13
        assert metadata["line"] == urlencode("This line contains ()[] chars")

        assert rule_match[11]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[11]["string_offset"] == 299
        metadata = rule_match[11]["metadata"]
        assert metadata["line_number"] == 14
        assert metadata["line"] == urlencode("This line contains {} chars")

        assert rule_match[12]["source"] == ANOTHER_MATCHING_ENTITY_FILE
        assert rule_match[12]["string_offset"] == 327
        metadata = rule_match[12]["metadata"]
        assert metadata["line_number"] == 15
        assert metadata["line"] == urlencode("This line contains ^$ chars")

        # Testing a missing file - expect minimal metadata because we can't know the other values
        assert (
            rule_match[13]["source"]
            == "matching_entity_3, but without any string matches - yes that's ok"
        )
        metadata = rule_match[13]["metadata"]
        assert metadata["source_type"] == "file"
        assert all(
            [
                key not in ["file_type", "md5sum", "line_number"]
                for key in metadata.keys()
            ]
        )

        # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
        rule_match = mdc.scan_results.host_scan["another_matching_rule"]
        assert rule_match[2]["source"].endswith(
            "snap/signal-desktop/350/opt/Signal/resources/app.asar"
        )
        metadata = rule_match[2]["metadata"]
        assert metadata["source_type"] == "file"
        assert all(
            [
                key not in ["file_type", "md5sum", "line_number"]
                for key in metadata.keys()
            ]
        )

        # Testing a missing process - again, expect minimal metadata because we can't find out more info
        assert rule_match[3]["source"] == "1234567"
        metadata = rule_match[3]["metadata"]
        assert metadata["source_type"] == "process"
        assert all(
            [
                key not in ["process_name", "file_type", "md5sum", "line_number"]
                for key in metadata.keys()
            ]
        )

    @patch(RESULTS_LOGGER_TARGET)
    def test_contrived_scan_output_with_disabled_rules(
        self, log_mock, conf, yara, findmnt
    ):
        # Parse the CONTRIVED_SCAN_OUTPUT but with a number of disabled rules
        # Disable 3 of the rules in CONTRIVED_SCAN_OUTPUT, expect 2 matching rules
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.rule_manager.disabled_rules = ["this", "rule", "another_matching_rule"]
        mdc.scan_results.parse_scan_output(
            CONTRIVED_SCAN_OUTPUT, mdc.rule_manager.disabled_rules
        )
        assert mdc.scan_results.matches == 2
        assert all(
            list(
                map(
                    lambda x: x not in ["this", "Rule", "another_matching_rule"],
                    mdc.scan_results.host_scan,
                )
            )
        )
        assert all(
            list(
                map(
                    lambda x: x in ["Iyamtho", "n_m3_t00"],
                    mdc.scan_results.host_scan,
                )
            )
        )
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "this", "file", ANY
        )
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "Rule", "file", ANY
        )
        log_mock.info.assert_any_call(
            "Matched rule %s in %s %s", "Iyamtho", "file", ANY
        )
        log_mock.info.assert_any_call(
            "Matched rule %s in %s %s", "n_m3_t00", "file", ANY
        )

        # disable all rules except 'Rule', because it isn't excluded
        log_mock.debug.reset_mock()
        log_mock.info.reset_mock()
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.rule_manager.disabled_rules = [
            "this",
            "rool",
            "another_matching_rule",
            "iyamtho",
            "n_m3_t00",
        ]
        mdc.scan_results.parse_scan_output(
            CONTRIVED_SCAN_OUTPUT, mdc.rule_manager.disabled_rules
        )
        assert list(mdc.scan_results.host_scan) == ["Rule"]
        assert mdc.scan_results.matches == 3
        sources = set(map(lambda x: x["source"], mdc.scan_results.host_scan["Rule"]))
        assert len(sources) == 3
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "Iyamtho", "file", ANY
        )
        log_mock.info.assert_any_call("Matched rule %s in %s %s", "Rule", "file", ANY)

    def test_random_output(self, conf, yara, findmnt):
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.scan_results.parse_scan_output(
            RANDOM_OUTPUT, mdc.rule_manager.disabled_rules
        )
        assert mdc.scan_results.matches == 2
        rule_match = mdc.scan_results.host_scan["Lorem"]
        assert rule_match[0]["source"].startswith("ipsum dolor")
        assert rule_match[0]["string_data"] == ""
        assert rule_match[0]["string_identifier"] == ""
        assert rule_match[0]["string_offset"] == -1
        rule_match = mdc.scan_results.host_scan["Dictum"]
        assert rule_match[0]["source"].startswith("at tempor")
        assert rule_match[0]["string_data"] == ""
        assert rule_match[0]["string_identifier"] == ""
        assert rule_match[0]["string_offset"] == -1

    @patch(RESULTS_LOGGER_TARGET)
    def test_random_output_with_disabled_rules(self, log_mock, conf, yara, findmnt):
        # Test various disabled rules with parsing RANDOM_OUTPUT
        # Disable 'Lorem' rule (and others) and expect just to match the 'Dictum' rule
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.rule_manager.disabled_rules = ["random", "rules", "and", "lorem"]
        mdc.scan_results.parse_scan_output(
            RANDOM_OUTPUT, mdc.rule_manager.disabled_rules
        )

        assert mdc.scan_results.matches == 1
        assert list(mdc.scan_results.host_scan) == ["Dictum"]
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "Lorem", "file", ANY
        )

        # Disable both 'Lorem' and 'Dictum' rules and expect to have no matches
        log_mock.debug.reset_mock()
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.rule_manager.disabled_rules = ["dictum", "lorem"]
        mdc.scan_results.parse_scan_output(
            RANDOM_OUTPUT, mdc.rule_manager.disabled_rules
        )
        assert mdc.scan_results.matches == 0
        assert mdc.scan_results.host_scan == {}
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "Dictum", "file", ANY
        )
        log_mock.debug.assert_any_call(
            "Skipping matches for disabled rule %s in %s %s", "Lorem", "file", ANY
        )

        # Disable rules other than 'Lorem' and 'Dictum' and expect match both those rules
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.rule_manager.disabled_rules = [
            "dictumm",
            "lore",
            "and",
            "other",
            "rules",
        ]
        mdc.scan_results.parse_scan_output(
            RANDOM_OUTPUT, mdc.rule_manager.disabled_rules
        )
        assert mdc.scan_results.matches == 2
        assert sorted(mdc.scan_results.host_scan) == ["Dictum", "Lorem"]
        log_mock.info.assert_any_call("Matched rule %s in %s %s", "Dictum", "file", ANY)
        log_mock.info.assert_any_call("Matched rule %s in %s %s", "Lorem", "file", ANY)


@patch(FINDMNT_TARGET)
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
class TestRuleParser:
    """Test suite for the rule string parser."""

    @pytest.fixture
    def sample_rules(self):
        """Fixture providing the test data from the original request."""
        return [
            'virustotal_test [description="Detects a Go (Golang) compiled binary",author="Your Name",date="2024-10-15",version="1.0"] /home/test_data/golang_binary',
            'CrowdStrike_Test [copyright="(c) 2025 CrowdStrike Inc.",description="Strings and code sequences used by an intermediate loader written in Go that deploys UULoader",reports="CSA-241297,CSIT-24303",version="202411222230",last_modified="2024-11-22",malware_family="UULoader"] /home/test_data/golang_binary',
            'ExampleRule [author="Security Team",description="Detects malicious behavior",reference="https://example.com/analysis",version =1,score =85,in_the_wild=true,deprecated=false,author="Analyst Name",company="Organization Name",description="What this rule detects",version =1,date="2024-01-15",last_modified="2024-01-20",malware_family="Zeus",threat_type="Banking Trojan",severity="high",confidence="high",hash="a1b2c3d4e5f6789...",md5="1234567890abcdef...",sha1="abcdef1234567890...",filetype="PE32",score =75,reference="https://blog.example.com/analysis",source="Internal Research",incident="INC-2024-001",case_id="CASE-12345",rule_id="YR12345",category="trojan",tags="banker,stealer",actor="APT29",campaign="Operation XYZ",sample="malware.exe",first_seen="2024-01-01",production_ready=true,tested=true,deprecated=false,team="Threat Intel",priority="critical",environment="production"] /home/test_data/golang_binary',
            'MinimalRule [author="Me"] /home/test_data/golang_binary',
            'ComprehensiveRule [author="John Doe",company="Security Corp",description="Detects Emotet banking trojan variant",date="2024-01-15",last_modified="2024-01-20",version =2,malware_family="Emotet",threat_type="Banking Trojan",severity="high",confidence="high",hash="a1b2c3d4e5f67890abcdef1234567890abcdef1234567890abcdef1234567890",reference="https://security-blog.example.com/emotet-analysis",source="Internal Sandbox",score =85,in_the_wild=true,production_ready=true] /home/max/workspace/malware-detection-upload-test/test_data/golang_binary',
        ]

    @pytest.fixture
    def sample_test_cases(self):
        return [
            # Test 1: Basic key-value pairs
            {
                "input": 'author="John Doe", version="1.0", date="2025-01-15"',
                "expected": {
                    "author": "John Doe",
                    "version": "1.0",
                    "date": "2025-01-15",
                },
                "description": "Basic quoted string values",
            },
            # Test 2: Mixed quote styles
            {
                "input": "author='John Doe', version=\"1.0\", description='This is a \"test\" rule'",
                "expected": {
                    "author": "John Doe",
                    "version": "1.0",
                    "description": 'This is a "test" rule',
                },
                "description": "Mixed single and double quotes",
            },
            # Test 3: Numbers and booleans
            {
                "input": "count=42, threshold=3.14, enabled=true, disabled=false, empty=null",
                "expected": {
                    "count": 42,
                    "threshold": 3.14,
                    "enabled": True,
                    "disabled": False,
                    "empty": None,
                },
                "description": "Numbers, booleans, and null values",
            },
            # Test 4: Spaces around equals
            {
                "input": "key1 = value1, key2= value2, key3 =value3, key4  =  value4",
                "expected": {
                    "key1": "value1",
                    "key2": "value2",
                    "key3": "value3",
                    "key4": "value4",
                },
                "description": "Various spacing around equals sign",
            },
            # Test 5: Quoted keys
            {
                "input": "\"quoted key\" = \"quoted value\", 'single quoted key' = 'single quoted value'",
                "expected": {
                    "quoted key": "quoted value",
                    "single quoted key": "single quoted value",
                },
                "description": "Quoted keys with spaces",
            },
            # Test 6: Commas inside quoted values
            {
                "input": 'description="This is a test, with commas, inside", author="Smith, John", count=5',
                "expected": {
                    "description": "This is a test, with commas, inside",
                    "author": "Smith, John",
                    "count": 5,
                },
                "description": "Commas inside quoted strings",
            },
            # Test 7: Duplicate keys (should keep last value)
            {
                "input": "version=1.0, author=John, version=2.0, author=Jane",
                "expected": {"version": 2.0, "author": "Jane"},
                "description": "Duplicate keys - keeps last value",
            },
            # Test 8: Empty values
            {
                "input": 'key1="", key2=, key3=" ", key4=\'\'',
                "expected": {"key1": "", "key2": "", "key3": " ", "key4": ""},
                "description": "Empty and whitespace values",
            },
            # Test 9: Complex quoted strings with escapes
            {
                "input": 'message="He said \\"Hello world\\"", path=\'C:\\\\Users\\\\test\'',
                "expected": {
                    "message": 'He said "Hello world"',
                    "path": "C:\\\\Users\\\\test",
                },
                "description": "Escaped quotes in strings",
            },
            # Test 10: Negative numbers
            {
                "input": "temperature=-20, balance=-15.75, positive=100",
                "expected": {"temperature": -20, "balance": -15.75, "positive": 100},
                "description": "Negative numbers",
            },
            # Test 11: Boolean variations
            {
                "input": "flag1=True, flag2=FALSE, flag3=true, flag4=False",
                "expected": {
                    "flag1": True,
                    "flag2": False,
                    "flag3": True,
                    "flag4": False,
                },
                "description": "Boolean case variations",
            },
            # Test 12: Special characters in unquoted values
            {
                "input": "hash=abc123def, url=http://example.com, email=test@example.com",
                "expected": {
                    "hash": "abc123def",
                    "url": "http://example.com",
                    "email": "test@example.com",
                },
                "description": "Special characters in unquoted values",
            },
            # Test 13: Empty input
            {"input": "", "expected": {}, "description": "Empty string input"},
            # Test 14: Whitespace only
            {
                "input": "   \t\n  ",
                "expected": {},
                "description": "Whitespace-only input",
            },
            # Test 15: Malformed entries (should be skipped)
            {
                "input": "valid=true, invalid_no_equals, another=valid, =no_key",
                "expected": {"valid": True, "another": "valid"},
                "description": "Mixed valid and invalid entries",
            },
            # Test 16: Complex real-world example
            {
                "input": 'rule_name="MALWARE_Detection", severity=8, confidence=0.95, tags="malware,trojan", enabled=true, last_updated="2025-01-15T10:30:00Z", description="Detects suspicious behavior patterns"',
                "expected": {
                    "rule_name": "MALWARE_Detection",
                    "severity": 8,
                    "confidence": 0.95,
                    "tags": "malware,trojan",
                    "enabled": True,
                    "last_updated": "2025-01-15T10:30:00Z",
                    "description": "Detects suspicious behavior patterns",
                },
                "description": "Real-world YARA rule metadata",
            },
            # Test 17: Edge case - single key-value pair
            {
                "input": "single_key=single_value",
                "expected": {"single_key": "single_value"},
                "description": "Single key-value pair",
            },
            # Test 18: Floating point edge cases
            {
                "input": "pi=3.14159, zero=0.0, small=0.001",
                "expected": {"pi": 3.14159, "zero": 0.0, "small": 0.001},
                "description": "Various floating point numbers",
            },
        ]

    def test_parse_rule_strings_count(self, conf, yara, findmnt, sample_rules):
        """Test that all rules are parsed and returned."""
        mdc = MalwareDetectionClient(config)
        mdc.scan_results.parse_scan_output("\n".join(sample_rules), [])
        assert len(mdc.scan_results.host_scan) == len(sample_rules)

    def test_example_rule_duplicate_keys(self, conf, yara, findmnt, sample_rules):
        """Test that duplicate keys are handled (should keep last value)."""
        # More flexible pattern to handle various spacing
        pattern = r"^(\S+)\s+\[(.*?)\]\s+(.+)$"
        match = re.match(pattern, sample_rules[2].rstrip(), re.DOTALL)

        rule_name = match.group(1)
        metadata_section = match.group(2).strip()
        metadata_dict = MalwareDetectionClient(
            config
        ).scan_results._parse_metadata_enhanced(metadata_section)

        assert rule_name == "ExampleRule"

        # Check that duplicate keys keep the last value
        # author appears twice: "Security Team" first, then "Analyst Name"
        assert metadata_dict["author"] == "Analyst Name"

        # version appears twice: 1 first, then 1 again
        assert metadata_dict["version"] == 1

        # score appears twice: 85 first, then 75
        assert metadata_dict["score"] == 75

        # description appears twice
        assert metadata_dict["description"] == "What this rule detects"

    def test_metadata_enhanced(self, conf, yara, findmnt, sample_test_cases):
        """Test that metadata parsing is done correctly"""
        for test_case in sample_test_cases:
            result = MalwareDetectionClient(
                config
            ).scan_results._parse_metadata_enhanced(test_case["input"])
            assert test_case["expected"] == result, test_case["description"] + " failed"

    def test_parse_value_enhanced(self, conf, yara, findmnt):
        """Test that _parse_value_enhanced parsing is done correctly"""
        mdc = MalwareDetectionClient(config)
        assert not mdc.scan_results._parse_value_enhanced("")
        assert mdc.scan_results._parse_value_enhanced("true")
        assert not mdc.scan_results._parse_value_enhanced("false")
        assert mdc.scan_results._parse_value_enhanced("null") is None
        assert mdc.scan_results._parse_value_enhanced("4") == 4
        assert mdc.scan_results._parse_value_enhanced("4.5") == 4.5
        assert mdc.scan_results._parse_value_enhanced("lol") == "lol"

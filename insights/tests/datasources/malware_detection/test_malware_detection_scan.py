# -*- coding: UTF-8 -*-
import os
import pytest
import fileinput
import time
from datetime import datetime

from mock.mock import patch, ANY
from insights.client.config import InsightsConfig
from insights.util.subproc import call
from insights.specs.datasources.malware_detection.scan_utils import (
    process_include_exclude_items,
)
from insights.specs.datasources.malware_detection import MalwareDetectionClient
from insights.tests.datasources.malware_detection.conftest import (
    IS_CONTAINER,
    SKIP_IF_CONTAINER_REASON,
    TEST_RULE_FILE,
    THIRD_PARTY_RULES_FILE,
    TEST_PID,
    TEST_PROCESSES_SCAN_SINCE,
    TEST_ALL,
    TEST_RULE_SCRIPT,
    TEMP_CONFIG_FILE,
    TEMP_TEST_SIGNATURES,
    TEMP_TEST_DIR,
    FAKE_YARA,
    FAKE_YARA_VERSION,
    LOAD_CONFIG_TARGET,
    CONFIG,
    CONFIG_FILE_TARGET,
    FINDMNT_TARGET,
    FIND_YARA_TARGET,
    SCAN_UTILS_LOGGER_TARGET,
    SCAN_LOGGER_TARGET,
    RESULTS_LOGGER_TARGET,
    SCAN_CALL_TARGET,
)


config = InsightsConfig(
    legacy_upload=True, base_url="localhost/app", systemid="", proxy=None
)


@patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(SCAN_LOGGER_TARGET)
@patch.dict(os.environ)
class TestProcessScanning:

    @pytest.mark.skipif(IS_CONTAINER, reason=SKIP_IF_CONTAINER_REASON)
    def test_scan_processes(self, log_mock, yara, create_test_files_fake_yara):
        # Test scanning processes to test which processes are going to be scanned
        os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                "scan_processes: true" if line.startswith("scan_processes:") else line
            )
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.rule_manager.rules_files == [
            TEST_RULE_FILE,
            THIRD_PARTY_RULES_FILE,
        ]
        assert mdc.config.do_filesystem_scan is True
        assert mdc.config.do_process_scan is True
        assert mdc.scan_manager.scan_pids == []
        assert mdc.scan_manager.processes_scan_exclude_list == []

        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch(SCAN_CALL_TARGET, return_value=""):
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        assert mdc.scan_manager.processes_scan_exclude_list == [TEST_PID]
        assert len(mdc.scan_manager.scan_pids) > 1
        assert "1" in mdc.scan_manager.scan_pids
        assert TEST_PID not in mdc.scan_manager.scan_pids

        # Exclude some processes via the config file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_exclude: 1\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.scan_manager.processes_scan_exclude_list == ["1"]
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch(SCAN_CALL_TARGET, return_value=""):
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        assert mdc.scan_manager.processes_scan_exclude_list == ["1", TEST_PID]
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([x not in mdc.scan_manager.scan_pids for x in ["1", TEST_PID]])

        # Exclude some processes via env vars
        os.environ["PROCESSES_SCAN_EXCLUDE"] = "systemd,3..10"
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert all(
            [pid in mdc.scan_manager.processes_scan_exclude_list for pid in ["1", "3"]]
        )
        assert "2" not in mdc.scan_manager.processes_scan_exclude_list
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch(SCAN_CALL_TARGET, return_value=""):
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        assert all(
            [
                pid in mdc.scan_manager.processes_scan_exclude_list
                for pid in ["1", "3", TEST_PID]
            ]
        )
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([x not in mdc.scan_manager.scan_pids for x in ["1", "3", TEST_PID]])
        assert "2" in mdc.scan_manager.scan_pids

    @pytest.mark.skipif(
        not (TEST_PROCESSES_SCAN_SINCE or TEST_ALL),
        reason="test_processes_scan_since is slowish and could potentially fail. "
        "Use TEST_PROCESSES_SCAN_SINCE=True to enable test",
    )
    def test_processes_scan_since(self, log_mock, yara, create_test_files_fake_yara):
        # Firstly, start the TEST_RULE_SCRIPT process then scan_only that process
        # Expect that we'll find it
        os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
        ps_call_output = call([["ps", "-eo", "pid=", "-o", "lstart="]])
        os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                "scan_filesystem: false"
                if line.startswith("scan_filesystem:")
                else line
            )
            line = (
                "scan_processes: true" if line.startswith("scan_processes:") else line
            )
            line = (
                "processes_scan_only: test-rule"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.rule_manager.rules_files == [
            TEST_RULE_FILE,
            THIRD_PARTY_RULES_FILE,
        ]
        assert mdc.config.do_filesystem_scan is False
        assert mdc.config.do_process_scan is True
        # Match TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_manager.scan_pids) == 1

        # Now find processes started since the last scan, specifically the TEST_RULE_SCRIPT process
        # However expect to not find it because it wasn't started since the last_scan date
        last_scan = time.time()
        last_scan_fmt = datetime.fromtimestamp(last_scan).strftime("%Y-%m-%d %H:%M:%S")
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_since: last"
                if line.startswith("processes_scan_since:")
                else line
            )
            print(line)
        with patch(
            "insights.specs.datasources.malware_detection.scan.scan_utils.get_scan_since_timestamp",
            return_value=last_scan,
        ):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        assert mdc.scan_manager.processes_scan_since_dict["timestamp"] == last_scan
        assert mdc.scan_manager.processes_scan_since_dict["datetime"] == last_scan_fmt
        # Still match the TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_manager.scan_pids) == 1
        # But when we run scan_processes() it won't be found because it wasn't started since the last scan
        # Patch the calls to yara so it doesn't actually try to scan any processes
        with patch(SCAN_CALL_TARGET, return_value=ps_call_output):
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        assert len(mdc.scan_manager.scan_pids) == 0
        log_mock.error.assert_called_with(
            "No processes to scan - none started since %s", last_scan_fmt
        )

        # Now find processes started since one day ago, specifically the TEST_RULE_SCRIPT process
        # Expect to find it this time it was started since a day ago
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_since: 1"
                if line.startswith("processes_scan_since:")
                else line
            )
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        # Still match the TEST_RULE_SCRIPT process from processes_scan_only
        assert len(mdc.scan_manager.scan_pids) == 1
        with patch(SCAN_CALL_TARGET) as call_mock:
            # Patch calls to 'call' within the scan_processes function
            # The first call is to ps to get the process list, which is what we want
            # The second call is to yara, which we want to ignore since yara may not be installed
            call_mock.side_effect = [ps_call_output, ""]
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        # Expect to find the TEST_RULE_SCRIPT process because it was started since a day ago
        assert len(mdc.scan_manager.scan_pids) == 1

        # Start another process and this time there will be a TEST_RULE_SCRIPT process started since last_scan date
        time.sleep(
            2
        )  # Wait a second to ensure the last_scan time is greater than the process start time
        os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
        ps_call_output = call([["ps", "-eo", "pid=", "-o", "lstart="]])
        with patch(
            "insights.specs.datasources.malware_detection.scan.scan_utils.get_scan_since_timestamp",
            return_value=last_scan,
        ):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        # Match 2 TEST_RULE_SCRIPT processes from processes_scan_only
        assert len(mdc.scan_manager.scan_pids) == 2
        # But when we run scan_processes() only the latest one will be found
        with patch(SCAN_CALL_TARGET) as call_mock:
            call_mock.side_effect = [ps_call_output, ""]
            mdc.scan_manager.process_scanner.scan_processes(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        # Only find the latest TEST_RULE_SCRIPT process
        assert len(mdc.scan_manager.scan_pids) == 1


@patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
@patch(
    "os.remove"
)  # Mock os.remove so it doesn't actually try to remove any existing files
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(SCAN_LOGGER_TARGET)
@patch(SCAN_UTILS_LOGGER_TARGET)
@patch(RESULTS_LOGGER_TARGET)
class TestFilesystemScanning:

    def test_scan_rules_file_with_extra_slashes(
        self,
        result_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        yara,
        remove,
        create_test_files_fake_yara,
    ):
        # Test scanning RULES_FILE with an extra slash only in the rules_location one
        # Even with the extra slashes in the rules_location there will be rules matched
        # because */rules_compiled.yar and *//rules_compiled.yar are the same file
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line
                + "rules_location: %s\n" % TEMP_TEST_SIGNATURES.replace("/tmp", "//tmp")
                if line.startswith("rules_location")
                else line
            )
            line = (
                "filesystem_scan_only: %s" % TEST_RULE_FILE
                if line.startswith("filesystem_scan_only:")
                else line
            )
            line = "add_metadata: false" if line.startswith("add_metadata:") else line
            line = (
                "exclude_network_filesystem_mountpoints: false"
                if line.startswith("exclude_network_filesystem_mountpoints:")
                else line
            )
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        # manually remove TEMP_TEST_SIGNATURES from exclude directories to scan TEST_RULE_FILE
        mdc.scan_manager.filesystem_scan_exclude_list.remove(
            TEMP_TEST_SIGNATURES.replace("/tmp", "//tmp")
        )
        mdc.load_rules()
        assert mdc.config.rules_location == TEMP_TEST_SIGNATURES.replace(
            "/tmp", "//tmp"
        )
        assert mdc.rule_manager.rules_files == [
            TEST_RULE_FILE,
            THIRD_PARTY_RULES_FILE,
        ]
        assert mdc.scan_manager.scan_fsobjects == [TEST_RULE_FILE]
        with patch(SCAN_CALL_TARGET) as call_mock:
            # Mock the scan match data from yara
            call_mock.return_value = (
                'TEST_RedHatInsightsMalwareDetection [author="Red Hat Insights",description="Verifies the Red Hat Insights Malware Detection Client app is present on the system",usage="Verification",date_created="11 June 2021",date_updated="18 October 2021"] %s\n0x4a:$re1: Malware Detection Client'
                % TEST_RULE_FILE
            )
            mdc.scan_manager.filesystem_scanner.scan_filesystem(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.rules_files,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        rule_match = mdc.scan_results.host_scan["TEST_RedHatInsightsMalwareDetection"]
        assert rule_match[0]["source"] == TEST_RULE_FILE
        assert rule_match[0]["string_data"] == "Malware Detection Client"
        assert rule_match[0]["string_identifier"] == "$re1"
        assert rule_match[0]["string_offset"] == 74
        result_log_mock.info.assert_any_call(
            "Matched rule %s in %s %s",
            "TEST_RedHatInsightsMalwareDetection",
            "file",
            TEST_RULE_FILE,
        )

    def test_scan_root_with_extra_slashes(
        self,
        result_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        yara,
        remove,
        create_test_files_fake_yara,
    ):
        # Testing we handle the situation where items in filesystem_scan_only & scan_exclude contain multiple slashes
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line + "rules_location: %s\n" % TEST_RULE_FILE
                if line.startswith("rules_location:")
                else line
            )
            line = line + "- //\n" if line.startswith("filesystem_scan_only:") else line
            line = (
                line + "- //\n" if line.startswith("filesystem_scan_exclude:") else line
            )
            line = (
                "exclude_network_filesystem_mountpoints: false"
                if line.startswith("exclude_network_filesystem_mountpoints:")
                else line
            )
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.scan_manager.scan_fsobjects == ["/"]
        assert "/" in mdc.scan_manager.filesystem_scan_exclude_list
        # Chaos monkey - modify scan_fsobjects and filesystem_scan_exclude_list AFTER they have been verified
        # Assert that they still work and cancel each other out
        mdc.scan_manager.scan_fsobjects = ["//"]
        mdc.scan_manager.filesystem_scan_exclude_list = ["//"]
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False
        scan_utils_log_mock.error.assert_called_with(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )

    @patch("insights.specs.datasources.malware_detection.scan.NamedTemporaryFile")
    @patch(SCAN_CALL_TARGET, return_value="")
    def test_filesystem_scan_since_tmp_files(
        self,
        call_mock,
        tmp_file_mock,
        result_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        yara,
        remove,
        extract_tmp_files,
        create_test_files_fake_yara,
    ):
        # Set filesystem_scan_only, filesystem_scan_exclude options to some of the tmp files and then 'scan' them
        # Then touch files to test the filesystem_scan_since option and make sure that only the touched files will be scanned
        yara_file_list = os.path.join(TEMP_TEST_DIR, "yara_file_list")
        scan_me_file = os.path.join(TEMP_TEST_DIR, "scan_me/scan_me_file")
        scan_me_too_file = os.path.join(TEMP_TEST_DIR, "scan_me_too/scan_me_too_file")
        filesystem_scan_only = tuple(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me", "scan_me_too"])
        )
        filesystem_scan_exclude = tuple(
            map(
                lambda x: os.path.join(TEMP_TEST_DIR, x),
                [
                    "scan_me_not",
                    "scan_me/dont_scan_me",
                    "scan_me_too/dont_scan_me_too",
                ],
            )
        )

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line + "rules_location: %s\n" % TEST_RULE_FILE
                if line.startswith("rules_location:")
                else line
            )
            line = (
                line + "- %s\n- %s" % filesystem_scan_only
                if line.startswith("filesystem_scan_only:")
                else line
            )
            line = (
                line + "- %s\n- %s\n- %s" % filesystem_scan_exclude
                if line.startswith("filesystem_scan_exclude:")
                else line
            )
            line = (
                "exclude_network_filesystem_mountpoints: false"
                if line.startswith("exclude_network_filesystem_mountpoints:")
                else line
            )
            print(line)
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        # manually remove TEMP_TEST_SIGNATURES from exclude directories to scan TEST_RULE_FILE
        mdc.scan_manager.filesystem_scan_exclude_list.remove(TEST_RULE_FILE)
        mdc.load_rules()
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        # Ensure the correct scan include and exclude values are set
        assert list(scan_dict.keys()) == ["/tmp"]
        assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
            filesystem_scan_exclude
        )

        # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
        # Also mock out the call to yara but we don't return anything since we aren't testing it
        with open(yara_file_list, "w") as f:
            tmp_file_mock.return_value = f
            mdc.scan_manager.filesystem_scanner.scan_filesystem(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.rules_files,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )

        with open(yara_file_list, "r") as f:
            contents = f.read().splitlines()
        # Ensure that a number of files are in the list of files passed to yara to scan
        assert len(contents) > 2
        assert all([x in contents for x in [scan_me_file, scan_me_too_file]])

        # With the same filesystem scan_only and scan_exclude values, add filesystem_scan_since: last into the mix and set
        # the last scan time to now.  There should be no matches because no files have been modified since now
        last_scan = time.time()
        last_scan_fmt = datetime.fromtimestamp(last_scan).strftime("%Y-%m-%d %H:%M:%S")
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "filesystem_scan_since: last"
                if line.startswith("filesystem_scan_since:")
                else line
            )
            print(line)
        with patch(
            "insights.specs.datasources.malware_detection.scan.scan_utils.get_scan_since_timestamp",
            return_value=last_scan,
        ):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
        assert mdc.scan_manager.filesystem_scan_since_dict["timestamp"] == last_scan
        assert mdc.scan_manager.filesystem_scan_since_dict["datetime"] == last_scan_fmt
        scan_log_mock.info.assert_called_with(
            "Scanning files created/modified since %s%s", ANY, ANY
        )

        # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
        # Also mock out the call to yara, but we don't return anything since we aren't testing it
        with open(yara_file_list, "w") as f:
            tmp_file_mock.return_value = f
            mdc.scan_manager.filesystem_scanner.scan_filesystem(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.rules_files,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        with open(yara_file_list, "r") as f:
            contents = f.read().splitlines()
        # Ensure no files were passed to yara to scan because none were modified since 'last_scan'
        assert not contents

        # Try again, keeping the same last_scan time, but this time touch 2 files
        # Confirm that only these 2 files appear in the list of files to be passed to yara
        os.system("touch %s %s" % (scan_me_file, scan_me_too_file))
        with patch(
            "insights.specs.datasources.malware_detection.scan.scan_utils.get_scan_since_timestamp",
            return_value=last_scan,
        ):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()

        with open(yara_file_list, "w") as f:
            tmp_file_mock.return_value = f
            mdc.scan_manager.filesystem_scanner.scan_filesystem(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.rules_files,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        with open(yara_file_list, "r") as f:
            contents = f.read().splitlines()
        # Ensure the scan_me_file was passed to yara to scan because it was 'modified' since 'last_scan'
        assert len(contents) == 2
        assert contents == [scan_me_file, scan_me_too_file]

        # Touch some files that are excluded from scanning so even though they have been modified, they won't be
        # in the list of files to scan that is passed to yara
        os.system(
            "touch %s %s %s"
            % (
                os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me/matching_entity"),
                os.path.join(TEMP_TEST_DIR, "scan_me_not/matching_entity"),
                os.path.join(
                    TEMP_TEST_DIR,
                    "scan_me_too/dont_scan_me_too/'another matching_entity'",
                ),
            )
        )
        with patch(
            "insights.specs.datasources.malware_detection.scan.scan_utils.get_scan_since_timestamp",
            return_value=last_scan,
        ):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()

        with open(yara_file_list, "w") as f:
            tmp_file_mock.return_value = f
            mdc.scan_manager.filesystem_scanner.scan_filesystem(
                mdc.config,
                mdc.scan_manager,
                mdc.yara_commander.yara_cmd,
                mdc.rule_manager.rules_files,
                mdc.rule_manager.disabled_rules,
                mdc.scan_results,
            )
        with open(yara_file_list, "r") as f:
            contents = f.read().splitlines()
        # Ensure both scan_me_file and scan_me_too_file were passed to yara because both were modified since last_scan
        assert len(contents) == 2
        assert contents == [scan_me_file, scan_me_too_file]

    @patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
    @patch.dict(os.environ)
    def test_rule_n_glob_files_excluded(
        self,
        conf,
        result_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        yara,
        remove,
        extract_tmp_files,
        create_test_files_fake_yara,
    ):
        # Fake a scan but make sure we are excluding the rules file and globbed files (they are supposed to be
        # insights log files, but that's hard to mock).
        # Also test we are not excluding ones we actually want to scan
        glob_files = [
            os.path.join(TEMP_TEST_DIR, "scan_me", f) for f in ["new_file", "old_file"]
        ]
        os.environ["TEST_SCAN"] = "false"
        os.environ["USE_REMOTE_RULES"] = "false"
        os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
        os.environ["RULES_LOCATION"] = TEST_RULE_FILE
        os.environ["FILESYSTEM_SCAN_ONLY"] = "%s,%s" % (
            TEMP_TEST_DIR,
            glob_files[1],
        )  # we actually want to scan glob_files[1]
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        assert mdc.rule_manager.rules_files == [TEST_RULE_FILE]
        assert mdc.scan_manager.scan_fsobjects == [TEMP_TEST_DIR, glob_files[1]]

        # Patch the call to glob so it returns a specific list of files
        # Patch the calls for running yara and have it return no matches
        with patch(
            "insights.specs.datasources.malware_detection.scan.glob",
            return_value=glob_files,
        ):
            with patch(SCAN_CALL_TARGET, return_value=""):
                mdc.scan_manager.filesystem_scanner.scan_filesystem(
                    mdc.config,
                    mdc.scan_manager,
                    mdc.yara_commander.yara_cmd,
                    mdc.rule_manager.rules_files,
                    mdc.rule_manager.disabled_rules,
                    mdc.scan_results,
                )

        assert (
            mdc.rule_manager.rules_files[0]
            in mdc.scan_manager.filesystem_scan_exclude_list
        )
        assert glob_files[0] in mdc.scan_manager.filesystem_scan_exclude_list
        # Make sure glob_files[1] isn't excluded because we actually want to scan that file
        assert glob_files[1] not in mdc.scan_manager.filesystem_scan_exclude_list

        # This time patch glob so it returns an empty list, ie simulating no extra files to exclude
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        with patch(
            "insights.specs.datasources.malware_detection.scan.glob",
            return_value=[],
        ):
            with patch(SCAN_CALL_TARGET, return_value=""):
                mdc.scan_manager.filesystem_scanner.scan_filesystem(
                    mdc.config,
                    mdc.scan_manager,
                    mdc.yara_commander.yara_cmd,
                    mdc.rule_manager.rules_files,
                    mdc.rule_manager.disabled_rules,
                    mdc.scan_results,
                )
        assert (
            mdc.rule_manager.rules_files[0]
            in mdc.scan_manager.filesystem_scan_exclude_list
        )
        # None of the glob files should be excluded this time
        assert all(
            [f not in mdc.scan_manager.filesystem_scan_exclude_list for f in glob_files]
        )


@patch(FINDMNT_TARGET)
@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(LOAD_CONFIG_TARGET, return_value=CONFIG)
@patch.dict(os.environ, {"TEST_SCAN": "false", "USE_REMOTE_RULES": "false"})
class TestFilesystemIncludeExcludeProcessing:

    def test_process_include_exclude_items_simple(self, conf, yara, findmnt):
        # Test the process_include_exclude_items function with simple modified include and exclude items
        # Simple in that the include and exclude files are modified in such a way that
        # directory listings aren't required get the list of included files
        # Add a single toplevel directory to the include file - expect only a single directory to scan
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.scan_manager.scan_fsobjects = ["/etc"]
        mdc.scan_manager.filesystem_scan_exclude_list = []
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert list(scan_dict.keys()) == ["/etc"]
        assert "include" not in scan_dict["/etc"]
        assert "exclude" not in scan_dict["/etc"]

        # Add some extra subdirectories to scan
        mdc.scan_manager.scan_fsobjects.extend(["/var/lib", "/var/log"])
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert sorted(scan_dict.keys()) == ["/etc", "/var"]
        assert sorted(list(scan_dict["/var"]["include"])) == [
            "/var/lib",
            "/var/log",
        ]
        assert "exclude" not in scan_dict["/var"]

        # Add some extra directories to exclude that won't impact the already included directories
        mdc.scan_manager.filesystem_scan_exclude_list.extend(["/tmp", "/var/run"])
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert sorted(scan_dict.keys()) == ["/etc", "/var"]
        assert sorted(scan_dict["/var"]["include"]) == ["/var/lib", "/var/log"]
        assert scan_dict["/var"]["exclude"]["items"] == ["/var/run"]

        # Exclude /var which will remove it from the list of directories to scan
        mdc.scan_manager.filesystem_scan_exclude_list.append("/var")
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert list(scan_dict.keys()) == ["/etc"]

        # Exclude /etc which means there will be no directories to scan
        mdc.scan_manager.filesystem_scan_exclude_list.append("/etc")
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert scan_dict == {}

    def test_process_include_exclude_items_complex(self, conf, yara, findmnt):
        # Test the process function with modified include and exclude files that will require more complex
        # processing to generate the list of items to be scanned
        # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
        # We don't need to list the contents of the /var directory
        mdc = MalwareDetectionClient(config)
        mdc.parse_scan_options()
        mdc.load_rules()
        mdc.scan_manager.scan_fsobjects = ["/var/lib", "/var/log"]
        mdc.scan_manager.filesystem_scan_exclude_list = [
            "/var/lib/systemd",
            "/var/lib/misc/",
            "/var/log/wtmp",
        ]

        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert list(scan_dict.keys()) == ["/var"]
        assert sorted(scan_dict["/var"]["exclude"]["items"]) == [
            "/var/lib/misc",
            "/var/lib/systemd",
            "/var/log/wtmp",
        ]
        # The exclude items shouldn't be in the include items
        # Nor should other items that aren't in the explicitly included items
        assert all(
            [
                x not in scan_dict["/var"]["include"]
                for x in [
                    "/var/lib/misc",
                    "/var/lib/systemd",
                    "/var/log/wtmp",
                    "/var/cache",
                    "/var/lib",
                    "/var/log",
                    "/var/tmp",
                    "/tmp",
                ]
            ]
        )
        # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
        # but not the excluded items, eg /var/log/wtmp
        # Some of these directories may not exist on the test system, but if they do they will be included
        maybe_dirs = list(
            filter(
                lambda path: os.path.exists(path),
                [
                    "/var/lib/dbus",
                    "/var/lib/pam",
                    "/var/lib/rpm",
                    "/var/log/lastlog",
                ],
            )
        )
        assert all([x in scan_dict["/var"]["include"] for x in maybe_dirs])

        # Change the include directory to /var
        # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
        # Because now we have to list the contents of the /var and /var/lib directories
        mdc.scan_manager.scan_fsobjects.append("/var")
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert list(scan_dict.keys()) == ["/var"]
        assert sorted(scan_dict["/var"]["exclude"]["items"]) == [
            "/var/lib/misc",
            "/var/lib/systemd",
            "/var/log/wtmp",
        ]
        assert all(
            [
                x not in scan_dict["/var"]["include"]
                for x in [
                    "/var/lib/misc",
                    "/var/lib/systemd",
                    "/var/log/wtmp",
                    "/var/lib",
                    "/var/log",
                    "/tmp",
                ]
            ]
        )
        # Some of these directories may not exist on the test system, but if they do they will be included
        maybe_dirs = list(
            filter(
                lambda path: os.path.exists(path),
                [
                    "/var/cache",
                    "/var/tmp",
                    "/var/lib/dbus",
                    "/var/lib/pam",
                    "/var/lib/rpm",
                    "/var/log/lastlog",
                ],
            )
        )
        assert all([x in scan_dict["/var"]["include"] for x in maybe_dirs])

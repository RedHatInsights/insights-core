# -*- coding: UTF-8 -*-
import os
import re

import pytest
import time

import fileinput

from mock.mock import patch, Mock, ANY

from insights.client.config import InsightsConfig

from insights.specs.datasources.malware_detection.scan_utils import (
    process_include_exclude_items,
)
from insights.specs.datasources.malware_detection import MalwareDetectionClient
from insights.tests.datasources.malware_detection.conftest import (
    TEMP_CONFIG_FILE,
    FIND_YARA_TARGET,
    FAKE_YARA,
    FAKE_YARA_VERSION,
    RESULTS_LOGGER_TARGET,
    SCAN_UTILS_LOGGER_TARGET,
    SCAN_LOGGER_TARGET,
    DOWNLOAD_RULES_TARGET,
    FAKE_YARA_CMD,
    CONFIG_LOGGER_TARGET,
    CONFIG_FILE_TARGET,
    TEST_RULE_FILE,
    TEMP_TEST_SIGNATURES,
    TEMP_TEST_DIR,
    TEST_PID,
    IS_CONTAINER,
    THIRD_PARTY_RULES_FILE,
    SCAN_CALL_TARGET,
    SKIP_IF_CONTAINER_REASON,
    RESULTS_CALL_TARGET,
    EXCLUDE_FILES_LIST,
)


INCLUDED_TLDS = [
    "/boot",
    "/dev",
    "/etc",
    "/home",
    "/opt",
    "/root",
    "/tmp",
    "/usr",
    "/var",
]  # after removing exclude items


config = InsightsConfig(
    legacy_upload=True, base_url="localhost/app", systemid="", proxy=None
)


@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(RESULTS_LOGGER_TARGET)
@patch(SCAN_UTILS_LOGGER_TARGET)
@patch(SCAN_LOGGER_TARGET)
@patch(CONFIG_LOGGER_TARGET)
class TestDefaultValues:

    @patch("insights.client.utilities.write_to_disk", Mock())
    @patch(DOWNLOAD_RULES_TARGET)
    def test_running_default_options(
        self,
        download_rules,
        config_log_mock,
        scan_log_mock,
        scan_utils_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Try running malware-detection with the default options
        # With the default options, test_scan is true, so some of the option values will be changed for that and
        # will be different from those in the default config file.
        # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
        # Use a real config file so scan_fsobjects will be populated properly
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.yara_cmd = FAKE_YARA_CMD

        assert mdc.config.yara_binary == FAKE_YARA
        assert mdc.config.yara_version == FAKE_YARA_VERSION
        assert mdc.config.rules_location == TEMP_TEST_SIGNATURES
        assert mdc.rule_manager.rules_files == [
            TEST_RULE_FILE,
            THIRD_PARTY_RULES_FILE,
        ]
        assert mdc.rule_manager.disabled_rules == []
        assert mdc.config.do_filesystem_scan is True
        assert mdc.config.do_process_scan is True
        assert mdc.scan_manager.scan_fsobjects == [TEMP_CONFIG_FILE]
        assert mdc.scan_manager.scan_pids == [TEST_PID]
        assert mdc.scan_manager.filesystem_scan_since_dict == {
            "timestamp": None,
            "datetime": None,
        }
        assert mdc.scan_manager.filesystem_scan_exclude_list == EXCLUDE_FILES_LIST
        assert mdc.scan_manager.processes_scan_exclude_list == []
        assert mdc.scan_manager.processes_scan_since_dict == {
            "timestamp": None,
            "datetime": None,
        }
        assert mdc.scan_manager.network_filesystem_mountpoints == []
        assert mdc.config.scan_timeout == 3600
        assert mdc.config.nice_value == 19

        with patch(SCAN_CALL_TARGET) as scan_mock:
            # Mock all the scan calls to 'call' to get the yara matches for the test scan
            # 1st call is yara output from scanning TEST_RULE_FILE
            # 2nd call is yara output from scanning the current process
            scan_mock.side_effect = [
                'TEST_RedHatInsightsMalwareDetection [author="Red Hat Insights",description="Verifies the Red Hat Insights Malware Detection Client app is present on the system",usage="Verification",date_created="11 June 2021",date_updated="18 October 2021"] %s\n0x4a:$re1: Malware Detection Client'
                % TEST_RULE_FILE,
                'TEST_RedHatInsightsMalwareDetection [author="Red Hat Insights",description="Verifies the Red Hat Insights Malware Detection Client app is present on the system",usage="Verification",date_created="11 June 2021",date_updated="18 October 2021"] %s\n0x4a:$re1: Malware Detection Client'
                % TEST_PID,
            ]
            with patch(RESULTS_CALL_TARGET) as result_mock:
                # Mock all the results calls to 'call' too get the metadata about the matches for the test scan
                # calls 1-5 are to get TEST_RULE_FILE metadata
                # 7th is to get current process metadata
                result_mock.side_effect = [
                    "ASCII text",
                    "text/plain; charset=us-ascii",
                    "d5b0aeb3e18df68f47287e14ef144489",
                    "2:74:Malware Detection Client",
                    "// Verifies the Red Hat Insights Malware Detection Client app is present on the system",
                    "python insights_client/run.py --collector malware-detection",
                ]
                mutation = mdc.run()
            results_log_mock.info.assert_any_call("Found %d rule match%s.", 2, "es")
        # Test scan results in mutation format
        assert 'ruleName: "TEST_RedHatInsightsMalwareDetection"' in mutation[0]
        assert 'source: "%s"' % TEST_RULE_FILE in mutation[0]
        assert 'source: "%s"' % TEST_PID in mutation[0]
        assert re.search("metadata:.*line_number", mutation[0])
        assert re.search("metadata:.*process_name", mutation[0])
        # Test scan results in JSON format
        rule = "TEST_RedHatInsightsMalwareDetection"
        assert len(mutation[1][rule]) == 2
        assert mutation[1][rule][0]["source"] == TEST_RULE_FILE
        assert mutation[1][rule][1]["source"] == TEST_PID
        assert mutation[1][rule][0]["string_data"] == "Malware Detection Client"
        assert mutation[1][rule][1]["string_data"] == "Malware Detection Client"
        assert mutation[1][rule][0]["metadata"]["source_type"] == "file"
        assert (
            mutation[1][rule][0]["metadata"]["line"]
            == "//%20Verifies%20the%20Red%20Hat%20Insights%20Malware%20Detection%20Client%20app%20is%20present%20on%20the%20system"
        )
        assert mutation[1][rule][1]["metadata"]["source_type"] == "process"
        assert (
            mutation[1][rule][1]["metadata"]["process_name"]
            == "python insights_client/run.py --collector malware-detection"
        )


@patch(FIND_YARA_TARGET, return_value=(FAKE_YARA, FAKE_YARA_VERSION))
@patch(RESULTS_LOGGER_TARGET)
@patch(SCAN_LOGGER_TARGET)
@patch(SCAN_UTILS_LOGGER_TARGET)
@patch(CONFIG_LOGGER_TARGET)
@patch.dict(
    os.environ,
    {"TEST_SCAN": "false", "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS": "false"},
)
class TestMalwareDetectionOptions:

    def test_running_modified_options(
        self,
        config_log_mock,
        scan_log_mock,
        scan_utils_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Disable test_scan and the mdc attribute values should mostly match what's in the config file
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.yara_cmd = FAKE_YARA_CMD

        assert mdc.rule_manager.rules_files == [
            TEST_RULE_FILE,
            THIRD_PARTY_RULES_FILE,
        ]
        assert mdc.rule_manager.disabled_rules == []
        assert mdc.config.yara_binary == FAKE_YARA
        assert mdc.config.yara_version == FAKE_YARA_VERSION
        assert mdc.config.do_filesystem_scan is True
        assert mdc.config.do_process_scan is False
        assert mdc.scan_manager.scan_fsobjects == []
        assert mdc.scan_manager.scan_pids == []
        assert mdc.scan_manager.filesystem_scan_since_dict == {
            "timestamp": None,
            "datetime": None,
        }
        assert all(
            [
                d in mdc.scan_manager.filesystem_scan_exclude_list
                for d in ["/proc", "/sys", "/mnt", "/media"]
            ]
        )
        # filesystem_scan_* attributes will exist whereas processes_scan_* will not
        assert all(
            [
                hasattr(mdc.scan_manager, "filesystem_scan_" + attr) is True
                and hasattr(mdc.scan_manager, "processes_scan_" + attr) is True
                for attr in ("exclude_list", "since_dict")
            ]
        )

        assert mdc.scan_manager.network_filesystem_mountpoints == []
        assert mdc.config.scan_timeout == 3600
        assert mdc.config.nice_value == 19

    def test_scan_only_options(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Test various combinations of filesystem_scan_only, process_scan_only, scan_filesystem & scan_processes
        # Firstly, test the default option values

        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.do_filesystem_scan is True
        assert mdc.scan_manager.scan_fsobjects == []
        assert mdc.config.do_process_scan is False
        assert mdc.scan_manager.scan_pids == []

        # Add some directories
        os.environ["FILESYSTEM_SCAN_ONLY"] = "/tmp,/var"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == ["/tmp", "/var"]

        # Disable filesystem scanning and only expect the process to be scanned
        os.environ["SCAN_FILESYSTEM"] = "false"
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_called_with(
            "Both scan_filesystem and scan_processes are disabled. Nothing to scan."
        )

        # Add scan_only for a process
        os.environ["PROCESSES_SCAN_ONLY"] = "1"
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_called_with(
            "Both scan_filesystem and scan_processes are disabled. Nothing to scan."
        )

        # Enable process scanning and now the scan_only value should be used
        os.environ["SCAN_PROCESSES"] = "true"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.do_filesystem_scan is False
        assert mdc.config.do_process_scan is True
        assert mdc.scan_manager.scan_pids == ["1"]

        # Enable process scanning and now the scan_only value should be used
        os.environ["SCAN_FILESYSTEM"] = "true"
        os.environ["SCAN_PROCESSES"] = "false"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.do_filesystem_scan is True
        assert mdc.config.do_process_scan is False

    @patch.dict(os.environ)
    def test_removed_config_values(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # If the user uses old config items, eg scan_only and scan_exclude, then notify them

        with open(TEMP_CONFIG_FILE, "a") as f:
            f.write("scan_only: /tmp\nscan_exclude: /home\n")
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_any_call(
            "The '%s' option has been replaced with 'filesystem_%s' and 'processes_%s' options in %s",
            "scan_exclude",
            "scan_exclude",
            "scan_exclude",
            TEMP_CONFIG_FILE,
        )
        scan_log_mock.error.assert_called_with(
            "Please remove %s file and a new config file will be created with updated options",
            TEMP_CONFIG_FILE,
        )

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "#scan_only: /tmp" if line.startswith("scan_only: ") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_any_call(
            "The '%s' option has been replaced with 'filesystem_%s' and 'processes_%s' options in %s",
            "scan_exclude",
            "scan_exclude",
            "scan_exclude",
            TEMP_CONFIG_FILE,
        )

        os.environ["SCAN_ONLY"] = "/tmp"
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "#scan_exclude: /home" if line.startswith("scan_exclude: ") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_any_call(
            "The '%s' option has been replaced with 'filesystem_%s' and 'processes_%s' options in %s",
            "scan_only",
            "scan_only",
            "scan_only",
            TEMP_CONFIG_FILE,
        )

        del os.environ["SCAN_ONLY"]
        os.environ["FILESYSTEM_SCAN_ONLY"] = "/tmp"
        os.environ["SCAN_EXCLUDE"] = "/home"
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_any_call(
            "The '%s' option has been replaced with 'filesystem_%s' and 'processes_%s' options in %s",
            "scan_exclude",
            "scan_exclude",
            "scan_exclude",
            TEMP_CONFIG_FILE,
        )

        del os.environ["SCAN_EXCLUDE"]
        os.environ["FILESYSTEM_SCAN_EXCLUDE"] = "/home"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == ["/tmp"]
        assert mdc.scan_manager.filesystem_scan_exclude_list == [
            "/home",
            mdc.config.rules_location,
        ]

    def test_invalid_config_values(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Check the malware client app behaves in a predictable way if the user specifies invalid option values
        # in the config file.  Some of these will fail yaml parsing, others will fail type checking

        # Invalid value for nice - fails casting to an integer
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: nineteen" if line.startswith("nice_value") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Problem setting configuration option %s: %s", "nice_value", ANY
        )
        yara.assert_called_once()  # It failed after the _find_yara method

        # Missing colon for nice_value option - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = "nice_value 19\n" if line.startswith("nice_value") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            TEMP_CONFIG_FILE,
            ANY,
        )
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, mixing single item and list items - fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "nice_value: 19\n" if line.startswith("nice_value") else line
            line = (
                "filesystem_scan_only: /bad\n- /bad"
                if line.startswith("filesystem_scan_only:")
                else line
            )
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            TEMP_CONFIG_FILE,
            ANY,
        )
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not a list item -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "filesystem_scan_only:"
                if line.startswith("filesystem_scan_only:")
                else line
            )
            line = "/bad" if line.startswith("- /bad") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            TEMP_CONFIG_FILE,
            ANY,
        )
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, not enough spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "-/bad" if line.startswith("/bad") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            TEMP_CONFIG_FILE,
            ANY,
        )
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

        # Bad list items for scan_only, using tabs instead of spaces -  fails yaml parsing
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "\t- /bad" if line.startswith("-/bad") else line
            print(line)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        config_log_mock.error.assert_called_with(
            "Error encountered loading the malware-detection app config file %s:\n%s",
            TEMP_CONFIG_FILE,
            ANY,
        )
        yara.assert_called_once()  # It failed before the _find_yara method because it was invalid yaml

    # Patch the os.environ dict so all the changes are only temporary
    @patch.dict(os.environ)
    def test_using_env_vars(
        self,
        config_log_mock,
        test_invalid_config_values,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Set certain option values via environment variables

        env_var_list = [
            ("RULES_LOCATION", TEST_RULE_FILE),
            ("TEST_SCAN", "hello"),  # will be interpreted as false
            ("SCAN_FILESYSTEM", "YES"),
            ("SCAN_PROCESSES", "T"),
            ("FILESYSTEM_SCAN_ONLY", "/tmp"),
            ("FILESYSTEM_SCAN_EXCLUDE", "/tmp"),
            ("PROCESSES_SCAN_ONLY", "1,2"),
            ("PROCESSES_SCAN_EXCLUDE", "2,1"),
            ("FILESYSTEM_SCAN_SINCE", "2"),
            ("PROCESSES_SCAN_SINCE", "10"),
            ("SCAN_TIMEOUT", "1800"),
            ("CPU_THREAD_LIMIT", "1"),
        ]
        for key, value in env_var_list:
            os.environ[key] = value
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.yara_binary == FAKE_YARA
        assert mdc.config.yara_version == FAKE_YARA_VERSION
        assert mdc.rule_manager.rules_files == [TEST_RULE_FILE]
        assert mdc.config.test_scan is False
        assert mdc.config.do_filesystem_scan is True
        assert mdc.config.do_process_scan is True
        assert mdc.scan_manager.scan_fsobjects == ["/tmp"]
        assert mdc.scan_manager.filesystem_scan_exclude_list == [
            "/tmp",
            TEST_RULE_FILE,
        ]
        if not IS_CONTAINER:
            assert mdc.scan_manager.scan_pids == ["1", "2"]
            assert mdc.scan_manager.processes_scan_exclude_list == ["1", "2"]
        assert mdc.scan_manager.filesystem_scan_since_dict[
            "timestamp"
        ] < time.time() - (2 * 86400)
        assert mdc.scan_manager.processes_scan_since_dict["timestamp"] < time.time() - (
            10 * 86400
        )
        assert mdc.config.scan_timeout == 1800
        # Not env vars, but just checking they have the expected values
        assert mdc.config.nice_value == 19
        assert mdc.config.cpu_thread_limit == 1

        # Start a filesystem scan and expect scan_only and scan_exclude to cancel each other out
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False

        # Start a process scan and expect scan_only and scan_exclude to cancel each other out
        mdc.scan_manager.process_scanner.scan_processes(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_process_scan is False

        # Test when SCAN_ONLY and SCAN_EXCLUDE values are comma separated
        # No items will be scanned because '/' is to be excluded
        for key, value in [
            ("FILESYSTEM_SCAN_ONLY", "/tmp,/,/var/tmp"),
            ("FILESYSTEM_SCAN_EXCLUDE", "/home,/,/fred,barney"),
        ]:
            os.environ[key] = value
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.do_filesystem_scan is True
        assert mdc.scan_manager.scan_fsobjects == ["/tmp", "/", "/var/tmp"]
        assert mdc.scan_manager.filesystem_scan_exclude_list == [
            "/home",
            "/",
            TEST_RULE_FILE,
        ]
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False

        # Test when FILESYSTEM_SCAN_ONLY is empty, so no items will be scanned because '/' is to be excluded
        os.environ["FILESYSTEM_SCAN_ONLY"] = ""
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.config.do_filesystem_scan is True
        assert mdc.scan_manager.scan_fsobjects == []
        assert mdc.scan_manager.filesystem_scan_exclude_list == [
            "/home",
            "/",
            TEST_RULE_FILE,
        ]
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False

        # Test when FILESYSTEM_SCAN_EXCLUDE is empty
        os.environ["FILESYSTEM_SCAN_EXCLUDE"] = ""
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == []
        assert mdc.scan_manager.filesystem_scan_exclude_list == [TEST_RULE_FILE]

        if not IS_CONTAINER:
            # Test when FILESYSTEM_SCAN_EXCLUDE is empty
            os.environ["PROCESSES_SCAN_ONLY"] = "systemd,2,3..10"
            os.environ["PROCESSES_SCAN_EXCLUDE"] = "3..100,systemd,2"
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
            assert all([pid in mdc.scan_manager.scan_pids for pid in ["1", "2", "3"]])
            assert all(
                [
                    pid in mdc.scan_manager.processes_scan_exclude_list
                    for pid in ["1", "2", "3"]
                ]
            )

        # Further testing of list type env vars
        os.environ["NETWORK_FILESYSTEM_TYPES"] = ""
        assert mdc.config._get_config_option("network_filesystem_types") == []
        os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs"
        assert mdc.config._get_config_option("network_filesystem_types") == ["nfs"]
        os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs,nfs4"
        assert mdc.config._get_config_option("network_filesystem_types") == [
            "nfs",
            "nfs4",
        ]

    @patch.dict(
        os.environ,
        {
            "TEST_SCAN": "false",
            "NICE_VALUE": "nineteen",
            "FILESYSTEM_SCAN_SINCE": "blast",
        },
    )
    def test_invalid_env_vars(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # NICE_VALUE and FILESYSTEM_SCAN_SINCE have invalid values
        # First time through the NICE_VALUE should generate an error

        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        config_log_mock.error.assert_called_with(
            "Problem parsing environment variable %s: %s", "NICE_VALUE", ANY
        )

        # Set NICE_VALUE to proper value to avoid it giving an error this time.
        # Only FILESYSTEM_SCAN_SINCE should generate an error
        os.environ["NICE_VALUE"] = "19"
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        scan_utils_log_mock.error.assert_called_with(
            "Unknown value '%s' for %s option. "
            "Valid values are integers >= 1 and 'last'",
            "blast",
            "filesystem_scan_since",
        )

        # Fix FILESYSTEM_SCAN_SINCE to proper value to avoid it giving an error this time.
        # Give an invalid value for PROCESSES_SCAN_SINCE, but need to enable SCAN_PROCESSES too
        os.environ["FILESYSTEM_SCAN_SINCE"] = "last"
        os.environ["SCAN_PROCESSES"] = "true"
        os.environ["PROCESSES_SCAN_SINCE"] = "0"
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        scan_utils_log_mock.error.assert_called_with(
            "Invalid processes_scan_since value 0. Valid values are integers >= 1 and 'last'"
        )

        # Disable SCAN_PROCESSES and the invalid PROCESSES_SCAN_SINCE doesn't raise an error anymore
        # because it isn't even parsed
        os.environ["SCAN_PROCESSES"] = "false"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.processes_scan_since_dict == {}

    def test_filesystem_scan_only_root(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):

        # Nothing special about root when parsing the filesystem_scan_only option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        filesystem_scan_only = "/"
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                "filesystem_scan_only: %s" % filesystem_scan_only
                if line.startswith("filesystem_scan_only:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == [filesystem_scan_only]
        # This is called by scan_filesystem to convert '/' into its top level subdirectories
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert "/" not in list(scan_dict.keys())

        # Multiple directories aren't consolidated until later
        filesystem_scan_only = ["/", "/tmp", "/home"]
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "filesystem_scan_only: %s" % filesystem_scan_only
                if line.startswith("filesystem_scan_only:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == filesystem_scan_only
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
        assert "/" not in list(scan_dict.keys())

    def test_filesystem_scan_exclude_root(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):

        # Nothing special about root when parsing the filesystem_scan_exclude option
        # There is no parsing of root to individual toplevel directories until running scan_filesystem
        # Add '/' to the list of filesystem_scan_exclude items.  Add it directly after the filesystem_scan_exclude: line
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line + "\n- /" if line.startswith("filesystem_scan_exclude:") else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert "/" in mdc.scan_manager.filesystem_scan_exclude_list
        # When scan_filesystem is run, '/' will be expanded into toplevel directories that cancel out everything
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
        )
        assert scan_dict == {}
        scan_utils_log_mock.error.assert_called_with(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )

    def test_filesystem_scan_only_exclude_nullify(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):

        # Testing filesystem scan_only and scan_exclude items such that the exclude items nullify the scan_only items
        # In which case there will be nothing to scan
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line + "\n- /var/log\n- /usr/lib/systemd\n- /tmp"
                if line.startswith("filesystem_scan_only:")
                else line
            )
            line = (
                line + "\n- /tmp/\n- /usr/lib/\n- /var/log"
                if line.startswith("filesystem_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == [
            "/var/log",
            "/usr/lib/systemd",
            "/tmp",
        ]
        assert all(
            [
                x in mdc.scan_manager.filesystem_scan_exclude_list
                for x in ["/tmp", "/usr/lib", "/var/log"]
            ]
        )
        # The exclude list covers all the items to be scanned, thus there is nothing to scan
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False
        scan_utils_log_mock.error.assert_called_with(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )

        # Both filesystem scan_only and scan_exclude contain root
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- /" if line.startswith("filesystem_scan_only:") else line
            line = (
                line + "\n- /" if line.startswith("filesystem_scan_exclude:") else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_fsobjects == [
            "/",
            "/var/log",
            "/usr/lib/systemd",
            "/tmp",
        ]
        assert all(
            [
                x in mdc.scan_manager.filesystem_scan_exclude_list
                for x in ["/", "/tmp", "/usr/lib", "/var/log"]
            ]
        )
        # Because both lists contain /, they will cancel each other out and there is nothing to scan
        mdc.scan_manager.filesystem_scanner.scan_filesystem(
            mdc.config,
            mdc.scan_manager,
            mdc.yara_commander.yara_cmd,
            mdc.rule_manager.rules_files,
            mdc.rule_manager.disabled_rules,
            mdc.scan_results,
        )
        assert mdc.config.do_filesystem_scan is False
        scan_utils_log_mock.error.assert_called_with(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )

    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    def test_filesystem_scan_only_exclude_symlinks(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        extract_tmp_files,
        create_test_files_fake_yara,
    ):

        # Testing using symlinks for filesystem scan_only and scan_exclude items
        # Symlinks will be skipped, whereas broken symlinks are treated like missing files
        symlink = os.path.join(TEMP_TEST_DIR, "scan_me/link_file")
        broken_symlink = os.path.join(TEMP_TEST_DIR, "scan_me/broken_link")
        os.environ["FILESYSTEM_SCAN_ONLY"] = "%s,%s" % (symlink, broken_symlink)
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
            assert mdc.scan_manager.scan_fsobjects == []

        scan_log_mock.info.assert_any_call(
            "Skipping symlink filesystem_scan_only item: '%s'. Use non-symlink items",
            symlink,
        )
        scan_log_mock.info.assert_any_call(
            "Skipping missing filesystem_scan_only item: '%s'", broken_symlink
        )
        scan_log_mock.error.assert_called_with(
            "Nothing to scan with filesystem_scan_only option and scan_processes disabled"
        )

        scan_only = os.path.join(TEMP_TEST_DIR, "scan_me")
        os.environ["FILESYSTEM_SCAN_ONLY"] = scan_only
        os.environ["FILESYSTEM_SCAN_EXCLUDE"] = "%s,%s" % (symlink, broken_symlink)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.filesystem_scan_exclude_list == [TEMP_TEST_SIGNATURES]
        assert mdc.scan_manager.scan_fsobjects == [scan_only]
        scan_log_mock.info.assert_any_call(
            "Skipping symlink filesystem_scan_exclude item: '%s'. Use non-symlink items",
            symlink,
        )
        scan_log_mock.info.assert_any_call(
            "Skipping missing filesystem_scan_exclude item: '%s'", broken_symlink
        )
        scan_log_mock.info.assert_any_call(
            "Unable to find items specified for the filesystem_scan_exclude option"
        )

    @patch(SCAN_CALL_TARGET)
    def test_network_filesystem_mountpoints(
        self,
        scan_call,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        extract_tmp_files,
        create_test_files_fake_yara,
    ):

        # Test the exclude_network_filesystem_mountpoints option by 'creating' various mountpoints to exclude
        os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = (
            "true"  # Override the default setting for this test class
        )
        scan_me_scan_me = os.path.join(TEMP_TEST_DIR, "scan_me/scan_me")
        scan_me_too = os.path.join(TEMP_TEST_DIR, "scan_me_too")
        scan_me_not_mnt = os.path.join(TEMP_TEST_DIR, "scan_me_not")
        dont_scan_me_mnt = os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me")

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                line + "rules_location: %s\n" % TEST_RULE_FILE
                if line.startswith("---")
                else line
            )
            line = (
                "filesystem_scan_only: %s" % TEMP_TEST_DIR
                if line.startswith("filesystem_scan_only:")
                else line
            )
            print(line)

        # This is the mocked output returned from the findmnt command
        scan_call.return_value = "%s\n%s\n" % (scan_me_not_mnt, dont_scan_me_mnt)

        # Setting exclude_network_filesystem_mountpoints to false means we don't care about excluding mountpoints
        os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
        os.environ["NETWORK_FILESYSTEM_TYPES"] = ""
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.network_filesystem_mountpoints == []

        # Removing the env var (it'll be true from the config file) but still not having any
        # network_filesystem_types value will generate an error
        del os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"]
        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD
        scan_log_mock.error.assert_called_with(
            "No value specified for 'network_filesystem_types' option"
        )

        # Ok, now with exclude mountpoints true and a value for types we will produce a list of mountpoints
        os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs"
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            # don't use rules_location to keep temp rule from excluce
            mdc.config.rules_location = ""
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.network_filesystem_mountpoints == [
            scan_me_not_mnt,
            dont_scan_me_mnt,
        ]

        # Now we can process all the include and exclude items to build the scan_dict of things to scan
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
            exclude_mountpoints=mdc.scan_manager.network_filesystem_mountpoints,
        )

        # The exclude_mountpoints will be added to the list of items to exclude
        assert list(scan_dict.keys()) == ["/tmp"]
        assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
            [scan_me_not_mnt, dont_scan_me_mnt]
        )
        assert all(
            [x in scan_dict["/tmp"]["include"] for x in [scan_me_scan_me, scan_me_too]]
        )
        # scan_me dir won't be in the list of include items because it has a sub-item to be excluded
        assert (
            os.path.join(TEMP_TEST_DIR, "scan_me") not in scan_dict["/tmp"]["include"]
        )

        # Now make TEMP_TEST_DIR a mountpoint and it will cancel out TEMP_TEST_DIR for scan_only
        scan_call.return_value = "%s\n" % TEMP_TEST_DIR
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.network_filesystem_mountpoints == [TEMP_TEST_DIR]
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
            exclude_mountpoints=mdc.scan_manager.network_filesystem_mountpoints,
        )
        assert scan_dict == {}
        scan_utils_log_mock.error.assert_called_with(
            "No filesystem items to scan because the specified exclude items cancel them out"
        )

    @patch(SCAN_CALL_TARGET)
    @patch("os.path.samefile", side_effect=OSError(13, "Permission denied"))
    @patch.dict(
        os.environ,
        {
            "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS": "true",
            "TEST_SCAN": "false",
            "RULES_LOCATION": TEST_RULE_FILE,
            "FILESYSTEM_SCAN_ONLY": TEMP_TEST_DIR,
        },
    )
    def test_network_filesystem_permission_denied(
        self,
        samefile_mock,
        scan_call,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        extract_tmp_files,
        create_test_files_fake_yara,
    ):
        # Test accessing network filesystem mountpoints that result in permission denied errors
        # Yes, even root can get permission denied trying to access fuse filesystems
        # Should produce the same results as the corresponding test in test_network_filesystem_mountpoints
        scan_me_not_mnt = os.path.join(TEMP_TEST_DIR, "scan_me_not")
        dont_scan_me_mnt = os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me")
        # This is the mocked output returned from the findmnt command
        scan_call.return_value = "%s\n%s\n" % (scan_me_not_mnt, dont_scan_me_mnt)

        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            # disable rules_location to exclude if from exclude list
            # todo may be a better way to disable this
            mdc.config.rules_location = ""
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.build_yara_commands()
        assert mdc.scan_manager.network_filesystem_mountpoints == [
            scan_me_not_mnt,
            dont_scan_me_mnt,
        ]

        # process_include_exclude_items uses os.path.samefile, but should gracefully handle the permission denied errors
        scan_dict = process_include_exclude_items(
            include_items=mdc.scan_manager.scan_fsobjects,
            exclude_items=mdc.scan_manager.filesystem_scan_exclude_list,
            exclude_mountpoints=mdc.scan_manager.network_filesystem_mountpoints,
        )
        assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
            [scan_me_not_mnt, dont_scan_me_mnt]
        )

    @pytest.mark.skipif(IS_CONTAINER, reason=SKIP_IF_CONTAINER_REASON)
    def test_processes_scan_options(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Test the processes scan options
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                "scan_filesystem: false"
                if line.startswith("scan_filesystem:")
                else line
            )
            line = (
                "scan_processes: true" if line.startswith("scan_processes:") else line
            )
            line = (
                "processes_scan_only: 1\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: 1\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)

        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD

        assert mdc.scan_manager.scan_pids == ["1"]
        assert mdc.scan_manager.processes_scan_exclude_list == ["1"]

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only: 1..10\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: 1..10\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([pid in mdc.scan_manager.scan_pids for pid in ["1", "2"]])
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert all(
            [pid in mdc.scan_manager.processes_scan_exclude_list for pid in ["1", "2"]]
        )

        # Test an open ended range, but really just saves typing '1' - scan all processes from 1 to 10
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only: ..10\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: ..10\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([int(pid) <= 10 for pid in mdc.scan_manager.scan_pids])
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert all(
            [int(pid) <= 10 for pid in mdc.scan_manager.processes_scan_exclude_list]
        )

        # Testing an open ended range - scan all processes from 101 to the max_pid value
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only: 101..\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: 101..\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([int(pid) > 100 for pid in mdc.scan_manager.scan_pids])
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert all(
            [int(pid) > 100 for pid in mdc.scan_manager.processes_scan_exclude_list]
        )

        # Not invalid ranges, just testing them to confirm they are handled gracefully
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only: 1...10\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: .1.....10.\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([int(pid) <= 10 for pid in mdc.scan_manager.scan_pids])
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert all(
            [int(pid) <= 10 for pid in mdc.scan_manager.processes_scan_exclude_list]
        )

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only: systemd\n"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude: systemd\n"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert "1" in mdc.scan_manager.scan_pids
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert "1" in mdc.scan_manager.processes_scan_exclude_list

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = (
                "processes_scan_only:\n- 2\n- 3..10\n- systemd"
                if line.startswith("processes_scan_only:")
                else line
            )
            line = (
                "processes_scan_exclude:\n- systemd\n- 2\n- 3..10"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert len(mdc.scan_manager.scan_pids) > 1
        assert all([pid in mdc.scan_manager.scan_pids for pid in ["1", "2", "3"]])
        assert len(mdc.scan_manager.processes_scan_exclude_list) > 1
        assert all(
            [
                pid in mdc.scan_manager.processes_scan_exclude_list
                for pid in ["1", "2", "3"]
            ]
        )

    def test_processes_scan_options_invalid_or_missing_values(
        self,
        config_log_mock,
        scan_utils_log_mock,
        scan_log_mock,
        results_log_mock,
        yara,
        create_test_files_fake_yara,
    ):
        # Test the processes scan options
        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = "test_scan: false" if line.startswith("test_scan:") else line
            line = (
                "scan_filesystem: false"
                if line.startswith("scan_filesystem:")
                else line
            )
            line = (
                "scan_processes: true" if line.startswith("scan_processes:") else line
            )
            line = (
                line + "\n- pid2\n- three..10\n- 20.50\n- notsystemd"
                if line.startswith("processes_scan_only:")
                else line
            )
            print(line)

        with pytest.raises(SystemExit):
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(config)
                mdc.parse_scan_options()
                mdc.load_rules()
                mdc.yara_commander.cmd = FAKE_YARA_CMD

        scan_log_mock.error.assert_any_call(
            "Unable to parse '%s' in to a range of PIDs: %s", "three..10", ANY
        )
        scan_log_mock.error.assert_any_call(
            "Unable to find items specified for the processes_scan_only option"
        )
        scan_log_mock.error.assert_any_call(
            "Nothing to scan with processes_scan_only option and scan_filesystem disabled"
        )

        for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
            line = line + "\n- 1" if line.startswith("processes_scan_only:") else line
            line = (
                line + "\n- -1\n- 3..ten\n- 123 systemd"
                if line.startswith("processes_scan_exclude:")
                else line
            )
            print(line)
        with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
            mdc = MalwareDetectionClient(config)
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.yara_commander.cmd = FAKE_YARA_CMD
        assert mdc.scan_manager.scan_pids == ["1"]
        assert mdc.scan_manager.processes_scan_exclude_list == []
        scan_log_mock.error.assert_any_call(
            "Unable to parse '%s' in to a range of PIDs: %s", "3..ten", ANY
        )
        scan_log_mock.error.assert_any_call(
            "Unable to find items specified for the processes_scan_only option"
        )

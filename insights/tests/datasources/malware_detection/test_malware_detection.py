# -*- coding: utf-8 -*-
import os
import re
import sys

import pytest
import yaml
import time
import string
import random
import fileinput

from datetime import datetime
from mock.mock import patch, Mock, ANY

try:
    from urllib import quote as urlencode  # python 2
except ImportError:
    from urllib.parse import quote as urlencode  # python 3

from insights.client.config import InsightsConfig
from insights.client.utilities import write_data_to_file
from insights.core.exceptions import CalledProcessError
from insights.specs.manifests import manifests, content_types
from insights.tests.helpers import getenv_bool
from insights.util.subproc import call

from insights.specs.datasources.malware_detection import (
    MalwareDetectionClient,
    InsightsConnection,
    logger,
)
from insights.specs.datasources.malware_detection.config import (
    DEFAULT_MALWARE_CONFIG,
    load_or_create_malware_config,
    find_yara,
)
from insights.specs.datasources.malware_detection.utils import (
    process_include_exclude_items,
    process_exclude_items,
    process_include_items,
    remove_child_items,
    get_parent_dirs,
    remove_included_excluded_items,
    get_toplevel_dirs,
)

# Temporary directory for testing stuff in
RANDOM_STRING = "".join(random.choice(string.ascii_lowercase) for _ in range(5))
TEMP_TEST_DIR = "/tmp/malware-detection_test_dir_%s" % RANDOM_STRING

FAKE_YARA = "/bin/yara"  # Need to fake yara for a number of tests
FAKE_YARA_VERSION = "4.5.2"

RULES_FILE = os.path.join(TEMP_TEST_DIR, "malware-detection_yara_rules.yar")
TEST_RULE_FILE = os.path.join(TEMP_TEST_DIR, "test-rule.yar")
TEST_REMOTE_RULE_LOCATION = (
    "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
)

TEST_RULE_SCRIPT = os.path.join(TEMP_TEST_DIR, "test-rule_process_match.sh")
MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, "matching_entity")
ANOTHER_MATCHING_ENTITY_FILE = os.path.join(TEMP_TEST_DIR, "another matching_entity")
CONFIG = yaml.safe_load(DEFAULT_MALWARE_CONFIG)  # Config 'returned' from _load_config
MALWARE_CONFIG = yaml.safe_load(
    DEFAULT_MALWARE_CONFIG
)  # Config 'returned' from load_or_create_malware_config

TEST_RULE_LOCATION = "/tmp/signatures"
# Important: containers can't write to /etc/insights-client/signatures so substitute it
if not os.path.isdir(TEST_RULE_LOCATION):
    os.mkdir(TEST_RULE_LOCATION)
MALWARE_CONFIG["rules_location"] = TEST_RULE_LOCATION
CONFIG["rules_location"] = TEST_RULE_LOCATION

TEMP_CONFIG_FILE = os.path.join(TEMP_TEST_DIR, "malware-detection-config.yml")
TEST_PID = str(os.getpid())  # This running processes ID

REMOTE_RULES_FILE = os.path.join(TEMP_TEST_DIR, "test-rule.yar")
THIRD_PARTY_RULES_FILE = os.path.join(TEMP_TEST_DIR, "third-party.yar")

# Get the number of CPU threads to run yara
CPUS = 1 if int(call("nproc").strip()) <= 2 else 2

# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = [
    "/boot",
    "/dev",
    "/etc",
    "/home",
    "/opt",
    "/proc",
    "/root",
    "/sys",
    "/tmp",
    "/usr",
    "/var",
]
INCLUDED_TLDS = [
    "/boot",
    "/dev",
    "/etc",
    "/home",
    "/opt",
    "/root",
    "/tmp",
    "/usr",
    "/var",
]  # after removing exclude items
DEFAULT_SCAN_EXCLUDE = [
    "/cgroup",
    "/media",
    "/mnt",
    "/net",
    "/proc",
    "/selinux",
    "/sys",
]

# Various patch targets
LOGGER_TARGET = "insights.specs.datasources.malware_detection.logger"
CONFIG_LOGGER_TARGET = "insights.specs.datasources.malware_detection.config.logger"
UTILS_LOGGER_TARGET = "insights.specs.datasources.malware_detection.utils.logger"
RULES_LOGGER_TARGET = "insights.specs.datasources.malware_detection.rules.logger"

LOAD_CONFIG_TARGET = (
    "insights.specs.datasources.malware_detection.config.load_or_create_malware_config"
)

FINDMNT_TARGET = "insights.specs.datasources.malware_detection.MalwareDetectionClient._parse_exclude_network_filesystem_mountpoints_option"

CALL_TARGET = "insights.specs.datasources.malware_detection.call"
CONFIG_CALL_TARGET = "insights.specs.datasources.malware_detection.config.call"

CONFIG_FILE_TARGET = (
    "insights.specs.datasources.malware_detection.config.MALWARE_CONFIG_FILE"
)

NAMEDTMPFILE_TARGET = (
    "insights.specs.datasources.malware_detection.rules.NamedTemporaryFile"
)


# Run these slowish tests?
TEST_PROCESSES_SCAN_SINCE = getenv_bool("TEST_PROCESSES_SCAN_SINCE", False)
TEST_DOWNLOAD_FAILURE_RETRIES = getenv_bool("TEST_DOWNLOAD_FAILURE_RETRIES", False)
TEST_GET_DISABLED_RULES_FAILURE = getenv_bool("TEST_GET_DISABLED_RULES_FAILURE", False)
TEST_ALL = getenv_bool("TEST_ALL", False)

# Are we running on RHEL6? (well actually, with python 2.6)
IS_RHEL6 = sys.version_info < (2, 7)
SKIP_IF_RHEL6_REASON = (
    "The malware-detection client isn't supported on RHEL6 / python 2.6"
)
# Is the best way to determine if we are running in a container?
IS_CONTAINER = (
    os.path.exists("/.dockerenv")
    or os.path.exists("/run/.containerenv")
    or "1" not in call("pidof init systemd").strip().split()
)

SKIP_IF_CONTAINER_REASON = (
    "This test uses running process that may not exist when run in a container"
)


class InsightsClientConfig:
    def __init__(self):
        self.loglevel = "INFO"
        self.auto_config = "True"
        self.authmethod = "BASIC"
        self.username = "your_username"
        self.password = "your_password"
        self.base_url = "https://cert-api.access.redhat.com:443/r/insights"
        self.cert_verify = "/etc/insights-client/cert-api.access.redhat.com.pem"
        self.proxy = "http://proxy.example.com:8080"
        self.cmd_timeout = "120"
        self.http_timeout = "120"
        self.auto_update = "True"
        self.obfuscate = "False"
        self.obfuscate_hostname = "False"
        self.legacy_upload = "True"
        self.upload_url = "https://upload.insights.redhat.com/api"
        self.branch_info_url = "https://branch-info.redhat.com"
        self.systemid = "default_system_id"
        self.no_proxy = False
        self.retries = 3


THIRD_PARTY_RULE_CONTENTS = """
rule golang_file
{
    meta:
        description = "Detects a Go (Golang) compiled binary"
        author = "Your Name"
        date = "2024-10-15"
        version = "1.0"
    strings:
        // Strings that are typical in Go binaries
        $go_pclntab = { 5f 63 67 6f 5f 6d 75 6e  6d 61 70 00 5f 63 67 6f }
    condition:
        // Check if any of the Go-specific strings and the section signature are present
        any of ($go_pclntab)
}
"""

THIRD_PARTY_RULE = "third-party.yara"
SECOND_THIRD_PARTY_RULE = "third-party2.yara"
# todo use os join
THIRD_PARTY_RULE_LOCATION = TEST_RULE_LOCATION + "/" + THIRD_PARTY_RULE
SECOND_THIRD_PARTY_RULE_LOCATION = TEST_RULE_LOCATION + "/" + SECOND_THIRD_PARTY_RULE


@pytest.fixture
def add_3rd_party_rules():
    write_data_to_file(THIRD_PARTY_RULE_CONTENTS, THIRD_PARTY_RULE_LOCATION)
    write_data_to_file(THIRD_PARTY_RULE_CONTENTS, SECOND_THIRD_PARTY_RULE_LOCATION)
    yield
    os.system("rm %s" % THIRD_PARTY_RULE_LOCATION)
    os.system("rm %s" % SECOND_THIRD_PARTY_RULE_LOCATION)


@pytest.fixture
def create_test_files_fake_yara():
    # Write the test files to the temp directory
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    # if not os.path.exists(TEMP_THIRD_PARTY_TEST_DIR):
    #     os.mkdir(TEMP_THIRD_PARTY_TEST_DIR)
    with open(TEMP_CONFIG_FILE, "w") as tcf:
        tcf.write(DEFAULT_MALWARE_CONFIG)
    test_files = [
        (MATCHING_ENTITY_FILE, MATCHING_ENTITY_FILE_CONTENTS),
        (ANOTHER_MATCHING_ENTITY_FILE, ANOTHER_MATCHING_ENTITY_FILE_CONTENTS),
        (TEST_RULE_FILE, TEST_RULE_FILE_CONTENTS),
        (TEST_RULE_SCRIPT, TEST_RULE_SCRIPT_CONTENTS),
    ]
    for test_file, contents in test_files:
        if not os.path.exists(test_file):
            with open(test_file, "w") as f:
                f.write(contents)
    os.chmod(TEST_RULE_SCRIPT, 0o755)
    yield
    os.system("rm -rf %s" % TEMP_TEST_DIR)


@pytest.fixture
def extract_tmp_files():
    if not os.path.exists(TEMP_TEST_DIR):
        os.mkdir(TEMP_TEST_DIR)
    os.system(
        "echo '%s' | base64 -d - | tar -C %s -zxf -"
        % (SCAN_FILES_BASE64, TEMP_TEST_DIR)
    )
    yield
    os.system("rm -rf %s" % TEMP_TEST_DIR)


#######################################################################
# The following section tests functionality that does not require yara
#######################################################################
@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
class TestsNotUtilizingYara:

    def test_default_spec(self):
        # Read in the default malware spec and check its values
        manifest = yaml.safe_load(manifests["malware-detection"])
        content_type = content_types["malware-detection"]
        assert content_type == "application/vnd.redhat.malware-detection.results+tgz"
        specs = manifest["plugins"]["configs"]
        for spec in [
            "mac_addresses",
            "etc_machine_id",
            "hostname",
            "dmidecode",
            "machine_id",
            "ip_addresses",
            "subscription_manager_id",
        ]:
            assert {
                "enabled": True,
                "name": "insights.specs.default.DefaultSpecs.%s" % spec,
            } in specs
            assert {"enabled": True, "name": "insights.specs.Specs.%s" % spec} in specs

    def test_default_options(self):
        # Read in the default malware_detection_config options and check their values
        assert CONFIG["test_scan"] is True
        assert CONFIG["scan_filesystem"] is True
        assert CONFIG["scan_processes"] is False
        assert CONFIG["filesystem_scan_only"] is None
        assert CONFIG["processes_scan_only"] is None
        assert CONFIG["filesystem_scan_since"] is None
        assert CONFIG["processes_scan_since"] is None
        assert all(
            [
                x in CONFIG["filesystem_scan_exclude"]
                for x in [
                    "/proc",
                    "/sys",
                    "/cgroup",
                    "/selinux",
                    "/net",
                    "/mnt",
                    "/media",
                ]
            ]
        )
        assert CONFIG["processes_scan_exclude"] is None
        assert CONFIG["exclude_network_filesystem_mountpoints"] is True
        assert CONFIG["rules_location"] == TEST_RULE_LOCATION
        assert CONFIG["use_remote_rules"] is True

    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs("/usr/lib/systemd/user/basic.target", parent_dir_list)
        assert sorted(parent_dir_list) == [
            "/usr",
            "/usr/lib",
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

        parent_dir_list = []
        get_parent_dirs(
            "/usr/lib/systemd/user/basic.target", parent_dir_list, "/usr/lib"
        )
        assert sorted(parent_dir_list) == [
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

        parent_dir_list = []
        get_parent_dirs("/usr/lib/systemd/user/basic.target", parent_dir_list, "/var")
        assert sorted(parent_dir_list) == [
            "/usr",
            "/usr/lib",
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = [
            "/path/to/some/item/child",
            "/path/to/another/item",
            "/path/to/some/item",
        ]
        assert remove_child_items(items) == [
            "/path/to/another/item",
            "/path/to/some/item",
        ]

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = [
            "/var/lib64",
            "/home/bob",
            "/var/lib/docker",
            "/home/bob",
            "/var/lib",
            "/home/bobby-droptables",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib63/im ok",
            "/var/lib64/im not",
        ]
        assert remove_child_items(items) == [
            "/home/bob",
            "/home/bobby-droptables",
            "/var/lib",
            "/var/lib63/im ok",
            "/var/lib64",
        ]

        # /path is common to both so that will be all that is returned
        items = ["/path/to/another/item", "/path/to/some/item", "/path"]
        assert remove_child_items(items) == ["/path"]

        # The root directory will always win
        items = ["/path/to/another/item", "/path/to/some/item", "/"]
        assert remove_child_items(items) == ["/"]

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ["/path/to/another/item", "", "/path/to/some/item"]
        assert remove_child_items(items) == [
            "/path/to/another/item",
            "/path/to/some/item",
        ]

    def test_remove_included_excluded_items(self):
        include_items = ["/home/bob", "/tmp", "/var/www/html"]
        exclude_items = [
            "/home/bo",
            "/home/bob/exclude",
            "/home/bobby",
            "/temp",
            "/var/www",
        ]
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ["/home/bob", "/tmp"]

        # Some fairly random lists similar to before
        include_items = [
            "/var/lib64/docker",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib/docker",
            "/home/bob",
            "/var/lib",
            "/usr",
        ]
        exclude_items = [
            "/var/lib/docker2",
            "/home/bob",
            "/home/bobby-droptables",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib63/im ok",
            "/var/lib64/im not",
            "/boot",
        ]
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ["/usr", "/var/lib", "/var/lib64/docker"]

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    def test_process_include_items(self, caplog):
        # Call process_include_items with variously populated lists
        logger.setLevel("DEBUG")

        # Add some valid entries to include_items list, esp subdirectories
        include_items = ["/etc/pam.d", "/tmp", "/var/log/"]
        processed_items = process_include_items(include_items)
        assert processed_items == ["/etc/pam.d", "/tmp", "/var/log"]

        # Add some more subdirectories
        include_items.extend(["/etc/alternatives", "/tmp", "/var/lib/"])
        processed_items = process_include_items(include_items)
        assert processed_items == [
            "/etc/alternatives",
            "/etc/pam.d",
            "/tmp",
            "/var/lib",
            "/var/log",
        ]

        # Add some top level directories to override the subdirectories
        include_items.extend(["/etc", "/var"])
        processed_items = process_include_items(include_items)
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add some invalid entries that will get ignored
        caplog.clear()
        include_items.extend(["..", "/var/run", "/missing"])
        processed_items = process_include_items(include_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping link '/var/run' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add the root directory (/) which will override all the other entries
        caplog.clear()
        include_items.append("/")
        processed_items = process_include_items(include_items)
        assert (
            "Found root directory in list of items to scan.  Ignoring the other items ..."
            in caplog.text
        )
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    def test_process_exclude_items(self, caplog):
        # Call process_exclude_items with variously populated lists
        logger.setLevel("DEBUG")

        # Remove the default entries from the exclude file
        processed_items = process_exclude_items()
        assert "No items specified to be excluded" in caplog.text
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ["/etc/ssh", "/tmp", "/var/run/"]
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ["/etc/ssh", "/tmp", "/var/run"]

        # Add some more subdirectories
        exclude_items.extend(["/etc/alternatives", "/tmp", "/var/lock/"])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == [
            "/etc/alternatives",
            "/etc/ssh",
            "/tmp",
            "/var/lock",
            "/var/run",
        ]

        # Add some top level directories to override the subdirectories
        exclude_items.extend(["/etc", "/var"])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add some invalid entries to exclude items
        caplog.clear()
        exclude_items.extend(["..", "/missing"])
        processed_items = process_exclude_items(exclude_items)
        assert "Skipping partial directory path '..' ..." in caplog.text
        assert "Skipping missing item '/missing' ..." in caplog.text
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add the root directory
        caplog.clear()
        exclude_items.append("/")
        processed_items = process_exclude_items(exclude_items)
        assert (
            "Found root directory in the exclude list.  Expanding it to all toplevel directories ..."
            in caplog.text
        )
        assert processed_items == get_toplevel_dirs()

    def test_process_include_exclude_tmp_files(self, extract_tmp_files):
        # Test the including/excluding some of the files in the tmp archive
        # Specifically tests excluding link files (good or broken) and pipe files (as well as explicit exclude items)

        include_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me", "scan_me_too"])
        )
        exclude_items = list(
            map(
                lambda x: os.path.join(TEMP_TEST_DIR, x),
                ["scan_me_not", "scan_me/dont_scan_me", "scan_me_too/dont_scan_me_too"],
            )
        )
        scan_dict = process_include_exclude_items(
            include_items=include_items, exclude_items=exclude_items
        )
        assert list(scan_dict.keys()) == ["/tmp"]
        assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
            exclude_items
        )

        include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/new_file",
                        "scan_me/old_file",
                        "scan_me/scan_me",
                        "scan_me/scan_me_file",
                        "scan_me_too/new_file",
                        "scan_me_too/old_file",
                        "scan_me_too/scan_me_too",
                        "scan_me_too/scan_me_too_file",
                    ],
                )
            )
        )
        dont_include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/link_file",
                        "scan_me/pipe_file",
                        "scan_me/broken_link",
                        "scan_me/dont_scan_me",
                        "scan_me_too/link_file",
                        "scan_me_too/pipe_file",
                        "scan_me_too/broken_link",
                        "scan_me_too/dont_scan_me_too",
                    ],
                )
            )
        )
        assert sorted(scan_dict["/tmp"]["include"]) == include_files
        assert all([x not in scan_dict["/tmp"]["include"] for x in dont_include_files])

        # Another test to assert a bug I found is fixed ... due to only having scan_items = set([])
        # Basically include_files should = ['scan_me/scan_me'] but the bug made include_files = []
        include_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me/scan_me"])
        )
        exclude_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me_not"])
        )
        scan_dict = process_include_exclude_items(
            include_items=include_items, exclude_items=exclude_items
        )

        include_files = sorted(
            list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me/scan_me"]))
        )
        assert sorted(scan_dict["/tmp"]["include"]) == include_files
        dont_include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/scan_me_file",
                        "scan_me/dont_scan_me",
                        "scan_me/scan_me/here_i_am",
                    ],
                )
            )
        )
        assert all([x not in scan_dict["/tmp"]["include"] for x in dont_include_files])


###################################################################################################
# The following section tests functionality that requires yara but can do with its execution faked
###################################################################################################
@pytest.mark.skipif(IS_RHEL6, reason=SKIP_IF_RHEL6_REASON)
class TestsUtilizingFakeYara:

    @patch(LOGGER_TARGET)
    class TestDefaultValues:

        @patch("insights.client.utilities.write_to_disk", Mock())
        def test_default_options(
            self,
            log_mock,
        ):
            # Try running malware-detection with the default options
            # With the default options, test_scan is true, so some of the option values will be changed for that and
            # will be different from those in the default config file.
            # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
            # Use a real config file so scan_fsobjects will be populated properly
            mdc = MalwareDetectionClient(
                InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            assert mdc.yara_binary == FAKE_YARA
            assert mdc.yara_version == FAKE_YARA_VERSION
            assert mdc.test_scan is True
            assert mdc.rules_files == []
            assert mdc.remote_rules_location == ""
            assert mdc.use_remote_rules is True
            assert mdc.disabled_rules == []
            assert mdc.do_filesystem_scan is True
            assert mdc.do_process_scan is False
            assert mdc.scan_fsobjects == []
            assert mdc.scan_pids == []
            assert mdc.filesystem_scan_since_dict == {}
            assert mdc.filesystem_scan_exclude_list == [TEST_RULE_LOCATION]
            assert mdc.processes_scan_exclude_list == []
            assert mdc.processes_scan_since_dict == {}
            assert mdc.network_filesystem_mountpoints == []
            assert mdc.scan_timeout == 3600
            assert mdc.nice_value == 19

        @patch(
            "insights.specs.datasources.malware_detection.MalwareDetectionClient.load_rules",
            return_value=TEST_RULE_FILE,
        )
        @patch("insights.specs.datasources.malware_detection.rules.download_rules")
        @patch("insights.client.utilities.write_to_disk", Mock())
        def test_running_default_options(
            self,
            rule_location,
            download_rules,
            log_mock,
            create_test_files_fake_yara,
        ):
            # Try running malware-detection with the default options
            # With the default options, test_scan is true, so some of the option values will be changed for that and
            # will be different from those in the default config file.
            # For example, do_filesystem_scan AND do_process_scan are both True when doing a test scan
            # Use a real config file so scan_fsobjects will be populated properly
            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                # parse options of a test scan
                mdc.parse_scan_options()
                # manually adding rules file
                mdc.rules_files.append(mdc.load_rules())

            assert mdc.yara_binary == FAKE_YARA
            assert mdc.yara_version == FAKE_YARA_VERSION
            assert mdc.rules_files == [TEST_RULE_FILE]
            assert mdc.rules_location == TEST_RULE_LOCATION
            assert mdc.remote_rules_location == TEST_REMOTE_RULE_LOCATION
            assert mdc.use_remote_rules is True
            assert mdc.disabled_rules == []
            assert mdc.do_filesystem_scan is True
            assert mdc.do_process_scan is True
            assert mdc.scan_fsobjects == [TEMP_CONFIG_FILE]
            assert mdc.scan_pids == [TEST_PID]
            # todo is this timestamp none needed to be set in test scan?
            assert mdc.filesystem_scan_since_dict == {"timestamp": None}
            assert mdc.filesystem_scan_exclude_list == []
            assert mdc.processes_scan_exclude_list == []
            # todo is this timestamp none needed to be set in test scan?
            assert mdc.processes_scan_since_dict == {"timestamp": None}
            assert mdc.network_filesystem_mountpoints == []
            assert mdc.scan_timeout == 3600
            assert mdc.nice_value == 19

            with patch(CALL_TARGET) as call_mock:
                # Mock all the calls to 'call' to get the yara matches and the metadata about the matches for the test scan
                # 1st call is yara output from scanning TEST_RULE_FILE, calls 2-6 are to get its metadata
                # 7th call is yara output from scanning the current process and 8th is to get its metadata
                call_mock.side_effect = [
                    "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client"
                    % TEST_RULE_FILE,
                    "ASCII text",
                    "text/plain; charset=us-ascii",
                    "d5b0aeb3e18df68f47287e14ef144489",
                    "2:74:Malware Detection Client",
                    "// Verifies the Red Hat Insights Malware Detection Client app is present on the system",
                    "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client"
                    % TEST_PID,
                    "python insights_client/run.py --collector malware-detection",
                ]
                # have to manually set yara_cmd
                mdc.yara_cmd = ["manually_set_yara"]
                mutation = mdc.run()
            log_mock.info.assert_any_call("Found %d rule match%s.", 2, "es")
            # Test scan results in mutation format
            assert 'ruleName: "TEST_RedHatInsightsMalwareDetection"' in mutation[0]
            assert 'source: "%s"' % TEST_RULE_FILE in mutation[0]
            assert 'source: "%s"' % TEST_PID in mutation[0]
            assert re.search("metadata:.*line_number", mutation[0])
            assert re.search("metadata:.*process_name", mutation[0])
            # Test scan results in JSON format
            rule = "TEST_RedHatInsightsMalwareDetection"
            assert len(mutation[1][rule]) == 2
            assert mutation[1][rule][0]["source"] == TEST_RULE_FILE
            assert mutation[1][rule][1]["source"] == TEST_PID
            assert mutation[1][rule][0]["string_data"] == "Malware Detection Client"
            assert mutation[1][rule][1]["string_data"] == "Malware Detection Client"
            assert mutation[1][rule][0]["metadata"]["source_type"] == "file"
            assert (
                mutation[1][rule][0]["metadata"]["line"]
                == "//%20Verifies%20the%20Red%20Hat%20Insights%20Malware%20Detection%20Client%20app%20is%20present%20on%20the%20system"
            )
            assert mutation[1][rule][1]["metadata"]["source_type"] == "process"
            assert (
                mutation[1][rule][1]["metadata"]["process_name"]
                == "python insights_client/run.py --collector malware-detection"
            )

    @patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
    @patch.dict(
        os.environ,
        {"TEST_SCAN": "false", "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS": "false"},
    )
    class TestMalwareDetectionOptions:

        def test_running_modified_options(self):
            # Disable test_scan and the mdc attribute values should mostly match what's in the config file
            mdc = MalwareDetectionClient(
                InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            # parse the malware options
            mdc.parse_scan_options()

            assert mdc.rules_files == []
            assert mdc.disabled_rules == []
            assert mdc.yara_binary == FAKE_YARA
            assert mdc.do_filesystem_scan is True
            assert mdc.do_process_scan is False
            assert mdc.scan_fsobjects == []
            assert mdc.scan_pids == []
            assert mdc.filesystem_scan_since_dict == {
                "timestamp": None,
                "datetime": None,
            }
            assert all(
                [
                    d in mdc.filesystem_scan_exclude_list
                    for d in ["/proc", "/sys", "/mnt", "/media"]
                ]
            )
            # filesystem_scan_* attributes will exist whereas
            # processes_scan_* will be set to false
            assert mdc.filesystem_scan_since_dict
            assert mdc.filesystem_scan_exclude_list
            assert mdc.processes_scan_since_dict == {}
            assert mdc.processes_scan_exclude_list == []

        @patch(LOGGER_TARGET)
        def test_scan_only_options(self, log_mock):
            # Test various combinations of filesystem_scan_only, process_scan_only, scan_filesystem & scan_processes
            # Firstly, test the default option values
            mdc = MalwareDetectionClient(
                InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            assert mdc.do_filesystem_scan is True
            assert mdc.scan_fsobjects == []
            assert mdc.do_process_scan is False
            assert mdc.scan_pids == []

            # Add some directories
            os.environ["FILESYSTEM_SCAN_ONLY"] = "/tmp,/var"
            mdc = MalwareDetectionClient(
                InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            # parse malware options
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == ["/tmp", "/var"]

            # Disable filesystem scanning and only expect the process to be scanned
            os.environ["SCAN_FILESYSTEM"] = "false"
            with pytest.raises(SystemExit):
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()

            log_mock.error.assert_called_with(
                "Both scan_filesystem and scan_processes are disabled.  Nothing to scan."
            )

            # Add scan_only for a process
            os.environ["PROCESSES_SCAN_ONLY"] = "1"
            with pytest.raises(SystemExit):
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_called_with(
                "Both scan_filesystem and scan_processes are disabled.  Nothing to scan."
            )

            # Enable process scanning and now the scan_only value should be used
            os.environ["SCAN_PROCESSES"] = "true"
            mdc = MalwareDetectionClient(
                InsightsClientConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            # parse malware options
            mdc.parse_scan_options()
            assert mdc.do_filesystem_scan is False
            assert mdc.do_process_scan is True
            assert mdc.scan_pids == ["1"]

        @patch(LOGGER_TARGET)
        @patch.dict(os.environ)
        def test_removed_config_values(
            self,
            log_mock,
            create_test_files_fake_yara,
        ):
            # If the user uses old config items, eg scan_only and scan_exclude, then notify them
            with open(TEMP_CONFIG_FILE, "a") as f:
                f.write("scan_only: /tmp\nscan_exclude: /home\n")

            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_any_call(
                "The 'scan_only' option has been replaced with the 'filesystem_scan_only' and 'processes_scan_only' options in "
                + TEMP_CONFIG_FILE
            )
            log_mock.error.assert_called_with(
                "Please remove the %s file and a new config file will be written with the new options",
                TEMP_CONFIG_FILE,
            )

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "#scan_only: /tmp" if line.startswith("scan_only: ") else line
                print(line)
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_any_call(
                "The 'scan_exclude' option has been replaced with the 'filesystem_scan_exclude' and 'processes_scan_exclude' options in "
                + TEMP_CONFIG_FILE
            )

            os.environ["SCAN_ONLY"] = "/tmp"
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "#scan_exclude: /home"
                    if line.startswith("scan_exclude: ")
                    else line
                )
                print(line)
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_any_call(
                "The 'scan_only' option has been replaced with the 'filesystem_scan_only' and 'processes_scan_only' options in "
                + TEMP_CONFIG_FILE
            )

            del os.environ["SCAN_ONLY"]
            os.environ["FILESYSTEM_SCAN_ONLY"] = "/tmp"
            os.environ["SCAN_EXCLUDE"] = "/home"
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_any_call(
                "The 'scan_exclude' option has been replaced with the 'filesystem_scan_exclude' and 'processes_scan_exclude' options in "
                + TEMP_CONFIG_FILE
            )

            del os.environ["SCAN_EXCLUDE"]
            os.environ["FILESYSTEM_SCAN_EXCLUDE"] = "/home"
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == ["/tmp"]
            assert mdc.filesystem_scan_exclude_list == ["/home"]

        @patch(LOGGER_TARGET)
        @patch(CONFIG_LOGGER_TARGET)
        def test_invalid_config_values(
            self,
            config_log_mock,
            log_mock,
            create_test_files_fake_yara,
        ):
            # Check the malware client app behaves in a predictable way if the user specifies invalid option values
            # in the config file.  Some of these will fail yaml parsing, others will fail type checking

            # Invalid value for nice - fails casting to an integer
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "nice_value: nineteen" if line.startswith("nice_value") else line
                print(line)
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            log_mock.error.assert_called_with(
                "Problem setting configuration option %s: %s", "nice_value", ANY
            )

            # Missing colon for nice_value option - fails yaml parsing
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = "nice_value 19\n" if line.startswith("nice_value") else line
                print(line)
            with pytest.raises(SystemExit):
                load_or_create_malware_config()

            config_log_mock.error.assert_called_with(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                TEMP_CONFIG_FILE,
                ANY,
            )

            # Bad list items for scan_only, mixing single item and list items - fails yaml parsing
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "nice_value: 19\n" if line.startswith("nice_value") else line
                line = (
                    "filesystem_scan_only: /bad\n- /bad"
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                print(line)
            with pytest.raises(SystemExit):
                load_or_create_malware_config()
            config_log_mock.error.assert_called_with(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                TEMP_CONFIG_FILE,
                ANY,
            )

            # Bad list items for scan_only, not a list item -  fails yaml parsing
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "filesystem_scan_only:"
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                line = "/bad" if line.startswith("- /bad") else line
                print(line)
            with pytest.raises(SystemExit):
                load_or_create_malware_config()
            config_log_mock.error.assert_called_with(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                TEMP_CONFIG_FILE,
                ANY,
            )

            # Bad list items for scan_only, not enough spaces -  fails yaml parsing
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "-/bad" if line.startswith("/bad") else line
                print(line)
            with pytest.raises(SystemExit):
                load_or_create_malware_config()
            config_log_mock.error.assert_called_with(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                TEMP_CONFIG_FILE,
                ANY,
            )

            # Bad list items for scan_only, using tabs instead of spaces -  fails yaml parsing
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "\t- /bad" if line.startswith("-/bad") else line
                print(line)
            with pytest.raises(SystemExit):
                load_or_create_malware_config()
            config_log_mock.error.assert_called_with(
                "Error encountered loading the malware-detection app config file %s:\n%s",
                TEMP_CONFIG_FILE,
                ANY,
            )

        # Patch the os.environ dict so all the changes are only temporary
        @patch.dict(os.environ)
        def test_using_env_vars(self, create_test_files_fake_yara):
            # Set certain option values via environment variables
            env_var_list = [
                ("RULES_LOCATION", TEMP_TEST_DIR),
                ("USE_REMOTE_RULES", "false"),
                ("TEST_SCAN", "hello"),  # will be interpreted as false
                ("SCAN_FILESYSTEM", "YES"),
                ("SCAN_PROCESSES", "T"),
                ("FILESYSTEM_SCAN_ONLY", "/tmp"),
                ("FILESYSTEM_SCAN_EXCLUDE", "/tmp"),
                ("PROCESSES_SCAN_ONLY", "1,2"),
                ("PROCESSES_SCAN_EXCLUDE", "2,1"),
                ("FILESYSTEM_SCAN_SINCE", "2"),
                ("PROCESSES_SCAN_SINCE", "10"),
                ("SCAN_TIMEOUT", "1800"),
                ("CPU_THREAD_LIMIT", "1"),
            ]
            for key, value in env_var_list:
                os.environ[key] = value

            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.yara_binary == FAKE_YARA
            assert mdc.yara_version == FAKE_YARA_VERSION
            assert mdc.rules_files == [TEST_RULE_FILE]
            assert mdc.test_scan is False
            assert mdc.do_filesystem_scan is True
            assert mdc.do_process_scan is True
            assert mdc.scan_fsobjects == ["/tmp"]
            assert mdc.filesystem_scan_exclude_list == ["/tmp"]
            if not IS_CONTAINER:
                assert mdc.scan_pids == ["1", "2"]
                assert mdc.processes_scan_exclude_list == ["1", "2"]
            assert mdc.filesystem_scan_since_dict["timestamp"] < time.time() - (
                2 * 86400
            )
            assert mdc.processes_scan_since_dict["timestamp"] < time.time() - (
                10 * 86400
            )
            assert mdc.scan_timeout == 1800
            # Not env vars, but just checking they have the expected values
            assert mdc.nice_value == 19
            assert mdc.cpu_thread_limit == 1

            # Start a filesystem scan and expect scan_only and scan_exclude to cancel each other out
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False

            # Start a process scan and expect scan_only and scan_exclude to cancel each other out
            mdc.scan_processes()
            assert mdc.do_process_scan is False

            # Test when SCAN_ONLY and SCAN_EXCLUDE values are comma separated
            # No items will be scanned because '/' is to be excluded
            for key, value in [
                ("FILESYSTEM_SCAN_ONLY", "/tmp,/,/var/tmp"),
                ("FILESYSTEM_SCAN_EXCLUDE", "/home,/,/fred,barney"),
            ]:
                os.environ[key] = value
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.do_filesystem_scan is True
            assert mdc.scan_fsobjects == ["/tmp", "/", "/var/tmp"]
            assert mdc.filesystem_scan_exclude_list == ["/home", "/"]
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False

            # Test when FILESYSTEM_SCAN_ONLY is empty, so no items will be scanned because '/' is to be excluded
            os.environ["FILESYSTEM_SCAN_ONLY"] = ""
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.do_filesystem_scan is True
            assert mdc.scan_fsobjects == []
            assert mdc.filesystem_scan_exclude_list == ["/home", "/"]
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False

            # Test when FILESYSTEM_SCAN_EXCLUDE is empty
            os.environ["FILESYSTEM_SCAN_EXCLUDE"] = ""
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.scan_fsobjects == []
            assert mdc.filesystem_scan_exclude_list == []

            if not IS_CONTAINER:
                # Test when FILESYSTEM_SCAN_EXCLUDE is empty
                os.environ["PROCESSES_SCAN_ONLY"] = "systemd,2,3..10"
                os.environ["PROCESSES_SCAN_EXCLUDE"] = "3..100,systemd,2"
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
                assert all([pid in mdc.scan_pids for pid in ["1", "2", "3"]])
                assert all(
                    [pid in mdc.processes_scan_exclude_list for pid in ["1", "2", "3"]]
                )

            # Further testing of list type env vars
            os.environ["NETWORK_FILESYSTEM_TYPES"] = ""
            assert mdc._get_config_option("network_filesystem_types") == []
            os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs"
            assert mdc._get_config_option("network_filesystem_types") == ["nfs"]
            os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs,nfs4"
            assert mdc._get_config_option("network_filesystem_types") == [
                "nfs",
                "nfs4",
            ]

        @patch(LOGGER_TARGET)
        @patch(CONFIG_LOGGER_TARGET)
        @patch(UTILS_LOGGER_TARGET)
        @patch.dict(
            os.environ,
            {
                "TEST_SCAN": "false",
                "NICE_VALUE": "nineteen",
                "FILESYSTEM_SCAN_SINCE": "blast",
            },
        )
        def test_invalid_env_vars(self, utils_log_mock, config_log_mock, log_mock):
            # NICE_VALUE and FILESYSTEM_SCAN_SINCE have invalid values
            # First time through the NICE_VALUE should generate an error
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
            config_log_mock.error.assert_called_with(
                "Problem parsing environment variable %s: %s", "NICE_VALUE", ANY
            )

            # Set NICE_VALUE to proper value to avoid it giving an error this time.
            # Only FILESYSTEM_SCAN_SINCE should generate an error
            os.environ["NICE_VALUE"] = "19"
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            utils_log_mock.error.assert_called_with(
                "Unknown value '%s' for %s option.  "
                "Valid values are integers >= 1 and 'last'",
                "blast",
                "filesystem_scan_since",
            )

            # Fix FILESYSTEM_SCAN_SINCE to proper value to avoid it giving an error this time.
            # Give an invalid value for PROCESSES_SCAN_SINCE, but need to enable SCAN_PROCESSES too
            os.environ["FILESYSTEM_SCAN_SINCE"] = "last"
            os.environ["SCAN_PROCESSES"] = "true"
            os.environ["PROCESSES_SCAN_SINCE"] = "0"
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                ).parse_scan_options()
            utils_log_mock.error.assert_called_with(
                "Invalid processes_scan_since value 0.  Valid values are integers >= 1 and 'last'"
            )

            # Disable SCAN_PROCESSES and the invalid PROCESSES_SCAN_SINCE doesn't raise an error anymore
            # because it isn't even parsed
            os.environ["SCAN_PROCESSES"] = "false"
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.processes_scan_since_dict == {}

        def test_filesystem_scan_only_root(
            self,
            create_test_files_fake_yara,
        ):
            # Nothing special about root when parsing the filesystem_scan_only option
            # There is no parsing of root to individual toplevel directories until running scan_filesystem
            filesystem_scan_only = "/"
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    "filesystem_scan_only: %s" % filesystem_scan_only
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == [filesystem_scan_only]
            # This is called by scan_filesystem to convert '/' into its top level subdirectories
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
            assert "/" not in list(scan_dict.keys())

            # Multiple directories aren't consolidated until later
            filesystem_scan_only = ["/", "/tmp", "/home"]
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "filesystem_scan_only: %s" % filesystem_scan_only
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == filesystem_scan_only
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert all([x in list(scan_dict.keys()) for x in INCLUDED_TLDS])
            assert "/" not in list(scan_dict.keys())

        @patch(UTILS_LOGGER_TARGET)
        def test_filesystem_scan_exclude_root(
            self,
            utils_log_mock,
            create_test_files_fake_yara,
        ):
            # Nothing special about root when parsing the filesystem_scan_exclude option
            # There is no parsing of root to individual toplevel directories until running scan_filesystem
            # Add '/' to the list of filesystem_scan_exclude items.  Add it directly after the filesystem_scan_exclude: line
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "\n- /"
                    if line.startswith("filesystem_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert "/" in mdc.filesystem_scan_exclude_list
            # When scan_filesystem is run, '/' will be expanded into toplevel directories that cancel out everything
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert scan_dict == {}
            utils_log_mock.error.assert_called_with(
                "No filesystem items to scan because the specified exclude items cancel them out"
            )

        @patch(UTILS_LOGGER_TARGET)
        def test_filesystem_scan_only_exclude_nullify(
            self,
            utils_log_mock,
            create_test_files_fake_yara,
        ):
            # Testing filesystem scan_only and scan_exclude items such that the exclude items nullify the scan_only items
            # In which case there will be nothing to scan
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "\n- /var/log\n- /usr/lib/systemd\n- /tmp"
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                line = (
                    line + "\n- /tmp/\n- /usr/lib/\n- /var/log"
                    if line.startswith("filesystem_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == ["/var/log", "/usr/lib/systemd", "/tmp"]
            assert all(
                [
                    x in mdc.filesystem_scan_exclude_list
                    for x in ["/tmp", "/usr/lib", "/var/log"]
                ]
            )
            # The exclude list covers all the items to be scanned, thus there is nothing to scan
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False
            utils_log_mock.error.assert_called_with(
                "No filesystem items to scan because the specified exclude items cancel them out"
            )

            # Both filesystem scan_only and scan_exclude contain root
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    line + "\n- /" if line.startswith("filesystem_scan_only:") else line
                )
                line = (
                    line + "\n- /"
                    if line.startswith("filesystem_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == [
                "/",
                "/var/log",
                "/usr/lib/systemd",
                "/tmp",
            ]
            assert all(
                [
                    x in mdc.filesystem_scan_exclude_list
                    for x in ["/", "/tmp", "/usr/lib", "/var/log"]
                ]
            )
            # Because both lists contain /, they will cancel each other out and there is nothing to scan
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False
            utils_log_mock.error.assert_called_with(
                "No filesystem items to scan because the specified exclude items cancel them out"
            )

        @patch(LOGGER_TARGET)
        @patch.dict(os.environ, {"TEST_SCAN": "false"})
        def test_filesystem_scan_only_exclude_symlinks(
            self,
            log_mock,
            extract_tmp_files,
            create_test_files_fake_yara,
        ):
            # Testing using symlinks for filesystem scan_only and scan_exclude items
            # Symlinks will be skipped, whereas broken symlinks are treated like missing files
            symlink = os.path.join(TEMP_TEST_DIR, "scan_me/link_file")
            broken_symlink = os.path.join(TEMP_TEST_DIR, "scan_me/broken_link")
            os.environ["FILESYSTEM_SCAN_ONLY"] = "%s,%s" % (symlink, broken_symlink)
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                assert mdc.scan_fsobjects == []
            log_mock.info.assert_any_call(
                "Skipping symlink filesystem_scan_only item: '%s'.  Please use non-symlink items",
                symlink,
            )
            log_mock.info.assert_any_call(
                "Skipping missing filesystem_scan_only item: '%s'", broken_symlink
            )
            log_mock.error.assert_called_with(
                "Nothing to scan with filesystem_scan_only option and scan_processes is disabled"
            )

            scan_only = os.path.join(TEMP_TEST_DIR, "scan_me")
            os.environ["FILESYSTEM_SCAN_ONLY"] = scan_only
            os.environ["FILESYSTEM_SCAN_EXCLUDE"] = "%s,%s" % (
                symlink,
                broken_symlink,
            )
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.filesystem_scan_exclude_list == []
            assert mdc.scan_fsobjects == [scan_only]
            log_mock.info.assert_any_call(
                "Skipping symlink filesystem_scan_exclude item: '%s'.  Please use non-symlink items",
                symlink,
            )
            log_mock.info.assert_any_call(
                "Skipping missing filesystem_scan_exclude item: '%s'",
                broken_symlink,
            )
            log_mock.info.assert_any_call(
                "Unable to find the items specified for the filesystem_scan_exclude option.  Not excluding any filesystem items"
            )

        @patch(CALL_TARGET)
        @patch(LOGGER_TARGET)
        @patch(UTILS_LOGGER_TARGET)
        def test_network_filesystem_mountpoints(
            self,
            utils_log_mock,
            log_mock,
            call_mock,
            extract_tmp_files,
            create_test_files_fake_yara,
        ):
            # Test the exclude_network_filesystem_mountpoints option by 'creating' various mountpoints to exclude
            os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = (
                "true"  # Override the default setting for this test class
            )
            scan_me_scan_me = os.path.join(TEMP_TEST_DIR, "scan_me/scan_me")
            scan_me_too = os.path.join(TEMP_TEST_DIR, "scan_me_too")
            scan_me_not_mnt = os.path.join(TEMP_TEST_DIR, "scan_me_not")
            dont_scan_me_mnt = os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me")

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "rules_location: %s\n" % TEST_RULE_FILE
                    if line.startswith("---")
                    else line
                )
                line = (
                    "filesystem_scan_only: %s" % TEMP_TEST_DIR
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                print(line)

            # This is the mocked output returned from the findmnt command
            call_mock.return_value = "%s\n%s\n" % (
                scan_me_not_mnt,
                dont_scan_me_mnt,
            )

            # Setting exclude_network_filesystem_mountpoints to false means we don't care about excluding mountpoints
            os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
            os.environ["NETWORK_FILESYSTEM_TYPES"] = ""
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.network_filesystem_mountpoints == []

            # Removing the env var (it'll be true from the config file) but still not having any
            # network_filesystem_types value will generate an error
            del os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"]
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
            log_mock.error.assert_called_with(
                "No value specified for 'network_filesystem_types' option"
            )

            # Ok, now with exclude mountpoints true and a value for types we will produce a list of mountpoints
            os.environ["NETWORK_FILESYSTEM_TYPES"] = "nfs"
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.network_filesystem_mountpoints == [
                scan_me_not_mnt,
                dont_scan_me_mnt,
            ]

            # Now we can process all the include and exclude items to build the scan_dict of things to scan
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
                exclude_mountpoints=mdc.network_filesystem_mountpoints,
            )

            # The exclude_mountpoints will be added to the list of items to exclude
            assert list(scan_dict.keys()) == ["/tmp"]
            assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
                [scan_me_not_mnt, dont_scan_me_mnt]
            )
            assert all(
                [
                    x in scan_dict["/tmp"]["include"]
                    for x in [scan_me_scan_me, scan_me_too]
                ]
            )
            # scan_me dir won't be in the list of include items because it has a sub-item to be excluded
            assert (
                os.path.join(TEMP_TEST_DIR, "scan_me")
                not in scan_dict["/tmp"]["include"]
            )

            # Now make TEMP_TEST_DIR a mountpoint and it will cancel out TEMP_TEST_DIR for scan_only
            call_mock.return_value = "%s\n" % TEMP_TEST_DIR
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.network_filesystem_mountpoints == [TEMP_TEST_DIR]
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
                exclude_mountpoints=mdc.network_filesystem_mountpoints,
            )
            assert scan_dict == {}
            utils_log_mock.error.assert_called_with(
                "No filesystem items to scan because the specified exclude items cancel them out"
            )

        @patch(CALL_TARGET)
        @patch("os.path.samefile", side_effect=OSError(13, "Permission denied"))
        @patch(LOGGER_TARGET)
        @patch.dict(
            os.environ,
            {
                "EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS": "true",
                "TEST_SCAN": "false",
                "RULES_LOCATION": TEST_RULE_FILE,
                "FILESYSTEM_SCAN_ONLY": TEMP_TEST_DIR,
            },
        )
        def test_network_filesystem_permission_denied(
            self,
            log_mock,
            samefile_mock,
            call_mock,
            extract_tmp_files,
            create_test_files_fake_yara,
        ):
            # Test accessing network filesystem mountpoints that result in permission denied errors
            # Yes, even root can get permission denied trying to access fuse filesystems
            # Should produce the same results as the corresponding test in test_network_filesystem_mountpoints
            scan_me_not_mnt = os.path.join(TEMP_TEST_DIR, "scan_me_not")
            dont_scan_me_mnt = os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me")
            # This is the mocked output returned from the findmnt command
            call_mock.return_value = "%s\n%s\n" % (
                scan_me_not_mnt,
                dont_scan_me_mnt,
            )

            with patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
            assert mdc.network_filesystem_mountpoints == [
                scan_me_not_mnt,
                dont_scan_me_mnt,
            ]

            # process_include_exclude_items uses os.path.samefile, but should gracefully handle the permission denied errors
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
                exclude_mountpoints=mdc.network_filesystem_mountpoints,
            )
            assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
                [scan_me_not_mnt, dont_scan_me_mnt]
            )

        @pytest.mark.skipif(IS_CONTAINER, reason=SKIP_IF_CONTAINER_REASON)
        def test_processes_scan_options(
            self,
            create_test_files_fake_yara,
        ):
            # Test the processes scan options
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    "scan_filesystem: false"
                    if line.startswith("scan_filesystem:")
                    else line
                )
                line = (
                    "scan_processes: true"
                    if line.startswith("scan_processes:")
                    else line
                )
                line = (
                    "processes_scan_only: 1\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: 1\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_pids == ["1"]
            assert mdc.processes_scan_exclude_list == ["1"]

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only: 1..10\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: 1..10\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert all([pid in mdc.scan_pids for pid in ["1", "2"]])
            assert len(mdc.processes_scan_exclude_list) > 1
            assert all([pid in mdc.processes_scan_exclude_list for pid in ["1", "2"]])

            # Test an open ended range, but really just saves typing '1' - scan all processes from 1 to 10
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only: ..10\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: ..10\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert all([int(pid) <= 10 for pid in mdc.scan_pids])
            assert len(mdc.processes_scan_exclude_list) > 1
            assert all([int(pid) <= 10 for pid in mdc.processes_scan_exclude_list])

            # Testing an open ended range - scan all processes from 101 to the max_pid value
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only: 101..\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: 101..\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert all([int(pid) > 100 for pid in mdc.scan_pids])
            assert len(mdc.processes_scan_exclude_list) > 1
            assert all([int(pid) > 100 for pid in mdc.processes_scan_exclude_list])

            # Not invalid ranges, just testing them to confirm they are handled gracefully
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only: 1...10\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: .1.....10.\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert all([int(pid) <= 10 for pid in mdc.scan_pids])
            assert len(mdc.processes_scan_exclude_list) > 1
            assert all([int(pid) <= 10 for pid in mdc.processes_scan_exclude_list])

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only: systemd\n"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude: systemd\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert "1" in mdc.scan_pids
            assert len(mdc.processes_scan_exclude_list) > 1
            assert "1" in mdc.processes_scan_exclude_list

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_only:\n- 2\n- 3..10\n- systemd"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "processes_scan_exclude:\n- systemd\n- 2\n- 3..10"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert len(mdc.scan_pids) > 1
            assert all([pid in mdc.scan_pids for pid in ["1", "2", "3"]])
            assert len(mdc.processes_scan_exclude_list) > 1
            assert all(
                [pid in mdc.processes_scan_exclude_list for pid in ["1", "2", "3"]]
            )

        @patch(LOGGER_TARGET)
        def test_processes_scan_options_invalid_or_missing_values(
            self,
            log_mock,
            create_test_files_fake_yara,
        ):
            # Test the processes scan options
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    "scan_filesystem: false"
                    if line.startswith("scan_filesystem:")
                    else line
                )
                line = (
                    "scan_processes: true"
                    if line.startswith("scan_processes:")
                    else line
                )
                line = (
                    line + "\n- pid2\n- three..10\n- 20.50\n- notsystemd"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                print(line)
            with pytest.raises(SystemExit):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsClientConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
            log_mock.error.assert_any_call(
                "Unable to parse '%s' in to a range of PIDs: %s", "three..10", ANY
            )
            log_mock.error.assert_any_call(
                "Unable to find the items specified for the processes_scan_only option.  Skipping ..."
            )
            log_mock.error.assert_any_call(
                "Nothing to scan with processes_scan_only option and scan_filesystem is disabled"
            )

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    line + "\n- 1" if line.startswith("processes_scan_only:") else line
                )
                line = (
                    line + "\n- -1\n- 3..ten\n- 123 systemd"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsClientConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert mdc.scan_pids == ["1"]
            assert mdc.processes_scan_exclude_list == []
            log_mock.error.assert_any_call(
                "Unable to parse '%s' in to a range of PIDs: %s", "3..ten", ANY
            )
            log_mock.error.assert_any_call(
                "Unable to find the items specified for the processes_scan_exclude option.  Not excluding any processes."
            )

    @patch(LOGGER_TARGET)
    @patch.dict(
        os.environ,
        {"USE_REMOTE_RULES": "false", "TEST_SCAN": "false"},
    )
    class TestFindYara:

        def test_find_yara_binary(self, log_mock):
            # Testing finding yara with correct version
            with patch("os.path.exists", return_value=True):
                with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                    yara, yara_version = find_yara()
                    mdc = MalwareDetectionClient(
                        InsightsConfig(),
                        MALWARE_CONFIG,
                        yara,
                        yara_version,
                    )
            assert mdc.yara_binary == "/bin/yara"
            assert mdc.yara_version == "4.1"

            # 'Find' yara in /usr/bin/yara (fails to 'find' /bin/yara)
            with patch("os.path.exists", side_effect=[False, True]):
                with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                    yara, yara_version = find_yara()
                    mdc = MalwareDetectionClient(
                        InsightsClientConfig(),
                        MALWARE_CONFIG,
                        yara,
                        yara_version,
                    )
            assert mdc.yara_binary == "/usr/bin/yara"
            assert mdc.yara_version == "4.1"

        @patch(CONFIG_LOGGER_TARGET)
        def test_find_unsupported_yara(self, config_log_mock, log_mock):
            # Test finding unsupported yara version
            with patch("os.path.exists", return_value=True):
                with patch(CONFIG_CALL_TARGET, return_value="3.10"):
                    with pytest.raises(SystemExit):
                        find_yara()

            config_log_mock.error.assert_called_with(
                "Found /bin/yara with version 3.10, but malware-detection requires version >= 4.1.0\n"
                "Please install a later version of yara."
            )

        @patch(CONFIG_LOGGER_TARGET)
        def test_find_invalid_yara(self, config_log_mock, log_mock):
            # Test finding a binary called yara, but its not yara
            with patch("os.path.exists", return_value=True):
                with patch(CONFIG_CALL_TARGET, return_value="not yara 1.2.3"):
                    with pytest.raises(SystemExit):
                        find_yara()
            config_log_mock.error.assert_called_with(
                "Error getting the version of the specified yara binary %s: %s",
                "/bin/yara",
                ANY,
            )

        @patch(CONFIG_LOGGER_TARGET)
        def test_cant_find_yara(self, config_log_mock, log_mock):
            # Test can't find yara on the system
            with patch("os.path.exists", return_value=False):
                with pytest.raises(SystemExit):
                    find_yara()
            config_log_mock.error.assert_called_with(
                "Couldn't find yara.  Please ensure the yara package is installed"
            )

        @patch("os.path.exists", return_value=True)
        @patch(CONFIG_CALL_TARGET)  # mock call to 'yara --version'
        @patch(CONFIG_LOGGER_TARGET)
        def test_yara_versions(
            self,
            config_log_mock,
            version_mock,
            exists_mock,
            log_mock,
        ):
            # Test checking the version of yara
            # Invalid versions of yara
            for version in ["4.0.99", "4"]:
                version_mock.return_value = version
                with pytest.raises(SystemExit):
                    find_yara()

            # Valid versions of yara
            for version in ["4.1", "4.10.10", "10.100.1000.0", "5"]:
                version_mock.return_value = version
                yara_binary, yara_version = find_yara()
                assert yara_binary == "/bin/yara"
                assert yara_version in ["4.1", "4.10.10", "10.100.1000.0", "5"]

    # Use patch.object, just because I wanted to try using patch.object instead of using patch all the time :shrug:
    @patch(
        NAMEDTMPFILE_TARGET
    )  # Mock NamedTemporaryFile so it doesn't try to create the temporary file
    @patch(
        "os.remove"
    )  # Mock os.remove so it doesn't actually try to remove any existing files
    @patch.object(
        MalwareDetectionClient,
        "_parse_exclude_network_filesystem_mountpoints_option",
    )
    @patch.object(
        InsightsConnection,
        "get",
        return_value=Mock(status_code=200, content=b"Rule Content"),
    )
    @patch.object(InsightsConnection, "get_proxies")
    @patch.object(InsightsConnection, "_init_session", return_value=Mock())
    # NOTE: Downloading the malware rules file happens within the malware client code so it's possible to test it here
    # However uploading the results archive is done outside the malware client code so it's not possible to test here
    class TestGetRules:
        """Testing the _get_rules method"""

        @patch.dict(os.environ, {"TEST_SCAN": "true"})
        def test_download_rules_cert_auth(
            self,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test the standard rules_location urls, but will result in cert auth being used to download the rules
            # Test with insights-config None, expect an error when trying to use the insights-config object
            with pytest.raises(SystemExit):

                mdc = MalwareDetectionClient(
                    None, MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            session.assert_not_called()
            # With default insights config and test scan true ...
            # Expect to use cert auth because no username or password specified and expect to download test-rule.yar
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.rules_location == TEST_RULE_LOCATION
            assert (
                mdc.remote_rules_location
                == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
            )
            # rules_file a list now? probably need to update this
            assert mdc.rules_files[0].startswith(
                "/tmp"
            )  # rules will be saved into a temp file
            get.assert_called_with(
                "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar",
                log_response_text=True,
                verify=True,
                stream=True,
            )

            # With authmethod=CERT, expect 'cert.' to be prefixed to the url
            mdc = MalwareDetectionClient(
                InsightsConfig(authmethod="CERT"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.rules_location == TEST_RULE_LOCATION
            assert (
                mdc.remote_rules_location
                == "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar"
            )
            get.assert_called_with(
                "https://cert.console.redhat.com/api/malware-detection/v1/test-rule.yar",
                log_response_text=True,
                verify=True,
                stream=True,
            )

            # With authmethod=BASIC and test scan false ...
            # Expect to still use cert auth because no username or password specified
            os.environ["TEST_SCAN"] = "false"
            mdc = MalwareDetectionClient(
                InsightsConfig(authmethod="BASIC"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.rules_location == TEST_RULE_LOCATION
            assert (
                mdc.remote_rules_location
                == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version="
                + FAKE_YARA_VERSION
            )
            get.assert_called_with(
                "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version="
                + FAKE_YARA_VERSION,
                log_response_text=False,
                verify=True,
                stream=True,
            )

            mdc = MalwareDetectionClient(
                InsightsConfig(authmethod="CERT"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.rules_location == TEST_RULE_LOCATION
            assert (
                mdc.remote_rules_location
                == "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version="
                + FAKE_YARA_VERSION
            )
            get.assert_called_with(
                "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar?yara_version="
                + FAKE_YARA_VERSION,
                log_response_text=False,
                verify=True,
                stream=True,
            )

        @patch.dict(os.environ, {"TEST_SCAN": "true"})
        @patch(RULES_LOGGER_TARGET)
        def test_download_rules_basic_auth(
            self,
            rules_log_mock,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test the standard rules_location urls, with basic auth attempting to be used to download the rules
            # Basic auth is used by default, but needs to have a valid username and password for it to work
            # Without a username and password, then cert auth will be used
            expected_rules_url = (
                "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
            )

            # Test with just a username specified - expect basic auth to be used but fails
            get.return_value = Mock(
                status_code=401, reason="Unauthorized", text="No can do"
            )
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(username="user"),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            get.assert_called_with(
                expected_rules_url, log_response_text=True, verify=True, stream=True
            )
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "401 Unauthorized: No can do",
            )

            # Test with just a password specified - expect basic auth to be used but fails
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(password="pass"),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            get.assert_called_with(
                expected_rules_url, log_response_text=True, verify=True, stream=True
            )
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "401 Unauthorized: No can do",
            )

            # Test with 'incorrect' username and/or password - expect basic auth failure
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(username="user", password="badpass"),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()

            get.assert_called_with(
                expected_rules_url, log_response_text=True, verify=True, stream=True
            )
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "401 Unauthorized: No can do",
            )

            # Test with 'correct' username and password - expect basic auth success
            get.return_value = Mock(status_code=200, content=b"Rule Content")

            mdc = MalwareDetectionClient(
                InsightsConfig(username="user", password="goodpass"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url, log_response_text=True, verify=True, stream=True
            )

        @patch.dict(os.environ, {"TEST_SCAN": "false"})
        @patch(
            "os.path.exists", return_value=True
        )  # mock call to os.path.exists in _find_yara
        @patch(
            CONFIG_CALL_TARGET, return_value="4.2.1"
        )  # mock call to 'yara --version'
        def test_download_rules_versioned_files(
            self,
            version_mock,
            exists_mock,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test downloading different signatures files depending on the yara version found on the system
            expected_rules_url = "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, yara, yara_version
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert mdc.yara_version == "4.2.1"
            assert (
                mdc.remote_rules_location == expected_rules_url + "?yara_version=4.2.1"
            )
            get.assert_called_with(
                expected_rules_url + "?yara_version=4.2.1",
                log_response_text=False,
                verify=True,
                stream=True,
            )

            version_mock.return_value = "4.1.0"
            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, yara, yara_version
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert (
                mdc.remote_rules_location == expected_rules_url + "?yara_version=4.1.0"
            )
            get.assert_called_with(
                expected_rules_url + "?yara_version=4.1.0",
                log_response_text=False,
                verify=True,
                stream=True,
            )

            version_mock.return_value = "10.100"
            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, yara, yara_version
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert (
                mdc.remote_rules_location == expected_rules_url + "?yara_version=10.100"
            )
            get.assert_called_with(
                expected_rules_url + "?yara_version=10.100",
                log_response_text=False,
                verify=True,
                stream=True,
            )

        @patch.dict(os.environ, {"TEST_SCAN": "false"})
        @patch(
            "os.path.exists", return_value=True
        )  # mock call to os.path.exists in _find_yara
        @patch(
            CONFIG_CALL_TARGET, return_value="4.2.0"
        )  # mock call to 'yara --version'
        def test_download_rules_from_stage(
            self,
            version_mock,
            exists_mock,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test downloading signatures files from the stage environment
            # cert_verify is set to 'False' (string) for stage - check its changed to False (boolean)

            base_url = "cert.console.stage.example.com:443/r/insights"
            expected_rules_url = "https://cert.console.stage.example.com/api/malware-detection/v1/signatures.yar?yara_version=4.2.0"

            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(base_url=base_url, cert_verify="False"),
                MALWARE_CONFIG,
                yara,
                yara_version,
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.yara_version == "4.2.0"
            assert mdc.rules_location == TEST_RULE_LOCATION
            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=False,
                stream=True,
            )

            for base_url in (
                "cert.console.stage.example.com/r/insights",
                "cert.console.stage.example.com",
            ):

                yara, yara_version = find_yara()
                mdc = MalwareDetectionClient(
                    InsightsConfig(base_url=base_url, cert_verify="false"),
                    MALWARE_CONFIG,
                    yara,
                    yara_version,
                )
                mdc.parse_scan_options()
                mdc.load_rules()

                assert mdc.rules_location == TEST_RULE_LOCATION
                assert mdc.remote_rules_location == expected_rules_url
                get.assert_called_with(
                    expected_rules_url,
                    log_response_text=False,
                    verify=False,
                    stream=True,
                )

            base_url = "https://cert.console.stage.example.com:443/r/insights"
            expected_rules_url = "https://cert.console.stage.example.com:443/api/malware-detection/v1/signatures.yar?yara_version=4.2.0"

            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(base_url=base_url, cert_verify="True"),
                MALWARE_CONFIG,
                yara,
                yara_version,
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.rules_location == TEST_RULE_LOCATION
            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=True,
                stream=True,
            )

            os.environ["TEST_SCAN"] = "true"
            base_url = "cloud.stage.example.com"
            expected_rules_url = (
                "https://cloud.stage.example.com/api/malware-detection/v1/test-rule.yar"
            )

            yara, yara_version = find_yara()
            mdc = MalwareDetectionClient(
                InsightsConfig(base_url=base_url, cert_verify=""),
                MALWARE_CONFIG,
                yara,
                yara_version,
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.rules_location == TEST_RULE_LOCATION
            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url, log_response_text=True, verify=True, stream=True
            )

        @patch.dict(
            os.environ,
            {
                "TEST_SCAN": "true",
                "REMOTE_RULES_LOCATION": "console.redhat.com/api/malware-detection/v1/rules.yar",
            },
        )
        def test_get_rules_missing_protocol(
            self,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Non-standard rules URLS - without https:// at the start and not signatures.yar
            # test-scan true and BASIC auth by default expect test-rule.yar and no 'cert.' in URL
            mdc = MalwareDetectionClient(
                InsightsConfig(username="user", password="pass"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert (
                mdc.remote_rules_location
                == "https://console.redhat.com/api/malware-detection/v1/test-rule.yar"
            )
            get.assert_called_with(
                "https://console.redhat.com/api/malware-detection/v1/test-rule.yar",
                log_response_text=True,
                verify=True,
                stream=True,
            )

            # test-scan false and CERT auth - expect 'cert.' prefixed to the URL and not test-rule.yar
            os.environ["TEST_SCAN"] = "false"
            mdc = MalwareDetectionClient(
                InsightsConfig(authmethod="CERT"),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            assert (
                mdc.remote_rules_location
                == "https://cert.console.redhat.com/api/malware-detection/v1/rules.yar"
            )
            get.assert_called_with(
                "https://cert.console.redhat.com/api/malware-detection/v1/rules.yar",
                log_response_text=False,
                verify=True,
                stream=True,
            )

        @patch.dict(
            os.environ,
            {
                "TEST_SCAN": "false",
                "REMOTE_RULES_LOCATION": "http://localhost/rules.yar",
            },
        )
        @patch(RULES_LOGGER_TARGET)
        def test_download_failures(
            self,
            rules_log_mock,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            from requests.exceptions import ConnectionError, Timeout

            # Test various problems downloading rules
            expected_rules_url = os.environ["REMOTE_RULES_LOCATION"]

            # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
            get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "404 Not found: Nup",
            )
            assert get.call_count == 1

            # Test other errors downloading rules from the backend - these are more likely to occur
            # Firstly handling an error like connection refused (Couldn't connect)
            get.side_effect = [
                ConnectionError("Couldn't connect"),
                Timeout("Timeout"),
            ]
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(username="user", password="pass"),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "Couldn't connect",
            )
            assert get.call_count == 2

            # Then handling a Timeout error
            # Note, because we aren't downloading from console.redhat.com, there won't be 'cert.*' appended to the URL
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "Timeout",
            )
            assert get.call_count == 3

        @pytest.mark.skipif(
            not (TEST_DOWNLOAD_FAILURE_RETRIES or TEST_ALL),
            reason="test_download_failure_retries is slow due to the inherent delay in the retry logic. "
            "Use TEST_DOWNLOAD_FAILURE_RETRIES=True to enable test",
        )
        @patch.dict(
            os.environ,
            {
                "TEST_SCAN": "false",
                "REMOTE_RULES_LOCATION": "http://localhost/rules.yar",
            },
        )
        @patch("os.path.isfile", return_value=True)
        @patch(LOGGER_TARGET)
        @patch(RULES_LOGGER_TARGET)
        def test_download_failure_retries(
            self,
            rules_log_mock,
            log_mock,
            isfile,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            from requests.exceptions import ConnectionError, SSLError

            # Testing the download failure retry logic
            expected_rules_url = os.environ["REMOTE_RULES_LOCATION"]

            # Status code != 200 will trigger a retry, but only if retries > 1
            get.return_value = Mock(status_code=404, reason="Not found", text="Nup")
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=1),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "404 Not found: Nup",
            )
            # Last call to logger.debug will be about downloading rules, not about retrying, which shows retrying wasn't invoked
            log_mock.debug.assert_called_with("Using cert_verify value %s ...", True)
            log_mock.debug.assert_any_call(
                "Downloading rules from: %s", expected_rules_url
            )

            # Set retries > 1 and now retrying happens
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "404 Not found: Nup",
            )
            # This time, the last call to logger.debug will be about retrying the download
            rules_log_mock.debug.assert_called_with("Trying again in %d seconds ...", 1)

            # Other network errors that raise an exception will trigger a retry
            get.side_effect = ConnectionError("Couldn't connect")
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=3),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                "Couldn't connect",
            )
            # Because we've set retries to 3, the last attempted retry will wait 2 seconds
            rules_log_mock.debug.assert_called_with("Trying again in %d seconds ...", 2)

            # Certificate verify failed SSL Errors will cause a different CA certificate bundle to be tried
            ca_cert = "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"  # default ca cert bundle file to try
            ssl_error = "SSL Error: certificate verify failed"
            get.side_effect = SSLError(ssl_error)
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=ca_cert,
                stream=True,
            )
            rules_log_mock.debug.assert_called_with(
                "Trying cert_verify value %s ...", ca_cert
            )
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                ssl_error,
            )

            # CA certificate bundles can be specified in the config file or via env vars too
            ca_cert = "/some/cert/file.crt"
            os.environ["CA_CERT"] = (
                ca_cert  # customers can specify their own ca bundle file via config/env vars
            )
            ssl_error = "SslError CERTIFICATE_VERIFY_FAILED"
            get.side_effect = SSLError(ssl_error)
            with pytest.raises(SystemExit):
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
                mdc.load_rules()
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=ca_cert,
                stream=True,
            )
            rules_log_mock.debug.assert_called_with(
                "Trying cert_verify value %s ...", ca_cert
            )
            rules_log_mock.error.assert_called_with(
                "Unable to download rules from %s: %s",
                expected_rules_url,
                ssl_error,
            )

        # todo think this test is no longer necessary since rule_location should be local
        # @patch.dict(
        #     os.environ,
        #     {
        #         "TEST_SCAN": "true",
        #         "RULES_LOCATION": "//api/malware-detection/v1/rules.yar",
        #         "USE_REMOTE_RULES": "FALSE",
        #     },
        # )
        # @patch("os.path.isfile", return_value=True)
        # def test_get_rules_location_as_file(
        #     self,
        #     isfile,
        #     session,
        #     proxies,
        #     get,
        #     findmnt,
        #     remove,
        #     tmpfile,
        # ):
        #     # Test using files for rules_location, esp irregular file names
        #     # rules_location that starts with a '/' is assumed to be a file, even if its a double '//'
        #     # Re-writing the rule to be test-rule.yar doesn't apply to local files
        #     mdc = MalwareDetectionClient(
        #         InsightsConfig(), MALWARE_CONFIG,
        #         FAKE_YARA, FAKE_YARA_VERSION)
        #     mdc.parse_scan_options()
        #     mdc.load_rules()
        #     assert mdc.rules_location == "//api/malware-detection/v1/rules.yar"
        #     assert mdc.rules_files == ['/api/malware-detection/v1/rules.yar']
        #     get.assert_not_called()
        #
        #     # Just to confirm the filename stays the same for regardless of test_rule value
        #     os.environ["TEST_SCAN"] = "false"
        #     mdc = MalwareDetectionClient(InsightsConfig())
        #     assert mdc.rules_location == "//api/malware-detection/v1/rules.yar"
        #     assert mdc.rules_file == ['/api/malware-detection/v1/rules.yar']
        #     get.assert_not_called()

        @patch.dict(os.environ, {"TEST_SCAN": "true"})
        @patch(LOGGER_TARGET)
        def test_download_rules_via_satellite(
            self,
            log_mock,
            session,
            proxies,
            get,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test recognizing and handling of Satellite URLs.
            # Satellite URLs have '/redhat_access/' in their path (so Satellite knows to redirect the query to C.R.C)
            # For malware-detection requests through a Satellite we append the malware-detection path and add https://
            satellite_url = (
                "satellite.example.com:443/redhat_access/r/insights/platform"
            )
            satellite_cert = "/etc/rhsm/ca/katello-server-ca.pem"
            expected_rules_url_prefix = "https://satellite.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/"
            insights_config = InsightsConfig(
                base_url=satellite_url, verbose=True, cert_verify=satellite_cert
            )

            # Firstly try with test-rule
            expected_rules_url = expected_rules_url_prefix + "test-rule.yar"
            mdc = MalwareDetectionClient(
                insights_config, MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=True,
                verify=satellite_cert,
                stream=True,
            )
            log_mock.debug.assert_called_with(
                "Using cert_verify value %s ...", satellite_cert
            )
            log_mock.debug.assert_any_call(
                "Downloading rules from: %s", expected_rules_url
            )

            # Then with the actual rules file
            os.environ["TEST_SCAN"] = "false"
            expected_rules_url = expected_rules_url_prefix + "signatures.yar"
            default_expected_rules_url = (
                expected_rules_url + "?yara_version=" + FAKE_YARA_VERSION
            )

            mdc = MalwareDetectionClient(
                insights_config, MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_rules()

            assert mdc.remote_rules_location == default_expected_rules_url
            get.assert_called_with(
                default_expected_rules_url,
                log_response_text=False,
                verify=satellite_cert,
                stream=True,
            )
            log_mock.debug.assert_called_with(
                "Using cert_verify value %s ...", satellite_cert
            )
            log_mock.debug.assert_any_call(
                "Downloading rules from: %s", default_expected_rules_url
            )

            expected_rules_url += "?yara_version=4.1"
            with patch("os.path.exists", return_value=True):
                with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                    yara, yara_version = find_yara()
                    mdc = MalwareDetectionClient(
                        insights_config, MALWARE_CONFIG, yara, yara_version
                    )
                    mdc.parse_scan_options()
                    mdc.load_rules()
            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=satellite_cert,
                stream=True,
            )
            log_mock.debug.assert_called_with(
                "Using cert_verify value %s ...", satellite_cert
            )
            log_mock.debug.assert_any_call(
                "Downloading rules from: %s", expected_rules_url
            )

            # Test a Satellite URL with 'cloud.stage.' in its name - expect to still download from Satellite
            # Also test using cert_verify=None in the InsightsConfig and check it changes to cert_verify=True
            satellite_url = "satellite.cloud.stage.example.com:443/redhat_access/r/insights/platform"
            expected_rules_url = "https://satellite.cloud.stage.example.com:443/redhat_access/r/insights/platform/malware-detection/v1/"
            expected_rules_url += "signatures.yar?yara_version=4.1"
            with patch("os.path.exists", return_value=True):
                with patch(CONFIG_CALL_TARGET, return_value="4.1"):
                    yara, yara_version = find_yara()
                    mdc = MalwareDetectionClient(
                        InsightsConfig(
                            base_url=satellite_url, verbose=True, cert_verify=None
                        ),
                        MALWARE_CONFIG,
                        yara,
                        yara_version,
                    )
                    mdc.parse_scan_options()
                    mdc.load_rules()
            assert mdc.remote_rules_location == expected_rules_url
            get.assert_called_with(
                expected_rules_url,
                log_response_text=False,
                verify=True,
                stream=True,
            )
            log_mock.debug.assert_called_with("Using cert_verify value %s ...", True)
            log_mock.debug.assert_any_call(
                "Downloading rules from: %s", expected_rules_url
            )

    @patch(
        NAMEDTMPFILE_TARGET
    )  # Mock NamedTemporaryFile so it doesn't try to create the temporary file
    @patch(
        "os.remove"
    )  # Mock os.remove so it doesn't actually try to remove any existing files
    @patch(FINDMNT_TARGET)
    class TestDisabledRules:
        """Testing the _get_disabled_rules method"""

        @patch.dict(os.environ)
        def test_skip_getting_disabled_rules(self, findmnt, remove, tmpfile):
            # Skip getting disabled rules if doing a test scan
            os.environ["TEST_SCAN"] = "true"
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_disabled_rules()
            assert mdc.disabled_rules == []

            # Skip getting disabled rules if the rules are coming from a file (which is really only for testing anyway)
            os.environ["TEST_SCAN"] = "false"
            os.environ["RULES_LOCATION"] = ""
            os.environ["USE_REMOTE_RULES"] = "false"  # sets use_remote_rules to False
            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_disabled_rules()
            assert mdc.disabled_rules == []

        @patch.object(InsightsConnection, "post")
        @patch.object(
            InsightsConnection,
            "get",
            return_value=Mock(status_code=200, content=b"Rule Content"),
        )
        @patch.object(InsightsConnection, "get_proxies")
        @patch.object(InsightsConnection, "_init_session", return_value=Mock())
        @patch.dict(os.environ, {"TEST_SCAN": "false"})
        def test_get_disabled_rules(
            self,
            session,
            proxies,
            get,
            post,
            findmnt,
            remove,
            tmpfile,
        ):
            # Test with no disabled rules
            rules_location = "https://cert.console.redhat.com/api/malware-detection/v1/signatures.yar"
            expected_graphql_url = (
                "https://cert.console.redhat.com/api/malware-detection/v1/graphql"
            )
            post.return_value = Mock(
                status_code=200, json=Mock(return_value={"data": {"rulesList": []}})
            )

            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.load_disabled_rules()

            assert (
                mdc.remote_rules_location
                == rules_location + "?yara_version=" + FAKE_YARA_VERSION
            )
            post.assert_called_with(
                expected_graphql_url,
                json=ANY,
                headers=ANY,
                verify=True,
                stream=True,
            )
            assert mdc.disabled_rules == []

            # Test with one disabled rule
            post.return_value = Mock(
                status_code=200,
                json=Mock(return_value={"data": {"rulesList": [{"name": "Rule1"}]}}),
            )

            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_disabled_rules()

            assert mdc.disabled_rules == ["rule1"]

            # Test with multiple disabled rules and a different rules_location
            rules_location = "http://localhost/rules.yar"
            os.environ["REMOTE_RULES_LOCATION"] = rules_location
            expected_graphql_url = "http://localhost/graphql"
            post.return_value = Mock(
                status_code=200,
                json=Mock(
                    return_value={
                        "data": {
                            "rulesList": [
                                {"name": "Rule2"},
                                {"name": "Rule1"},
                                {"name": "XYZ"},
                                {"name": "abc"},
                            ]
                        }
                    }
                ),
            )

            mdc = MalwareDetectionClient(
                InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
            )
            mdc.parse_scan_options()
            mdc.load_disabled_rules()

            assert mdc.remote_rules_location == rules_location
            post.assert_called_with(
                expected_graphql_url,
                json=ANY,
                headers=ANY,
                verify=True,
                stream=True,
            )
            assert mdc.disabled_rules == ["abc", "rule1", "rule2", "xyz"]

        @pytest.mark.skipif(
            not (TEST_GET_DISABLED_RULES_FAILURE or TEST_ALL),
            reason="test_get_disabled_rules_failure_retries is slow due to the inherent delay in the retry logic. "
            "Use TEST_GET_DISABLED_RULES_FAILURE=True to enable test",
        )
        @patch.object(InsightsConnection, "post")
        @patch.object(
            InsightsConnection,
            "get",
            return_value=Mock(status_code=200, content=b"Rule Content"),
        )
        @patch.object(InsightsConnection, "get_proxies")
        @patch.object(InsightsConnection, "_init_session", return_value=Mock())
        @patch.dict(
            os.environ,
            {"TEST_SCAN": "false", "REMOTE_RULES_LOCATION": "localhost/rules.yar"},
        )
        @patch(LOGGER_TARGET)
        def test_get_disabled_rules_failure(
            self,
            log,
            session,
            proxies,
            get,
            post,
            findmnt,
            remove,
            tmpfile,
        ):
            from requests.exceptions import ConnectionError, Timeout

            expected_graphql_url = "https://localhost/graphql"

            # 404 error - unlikely to occur unless an incorrect rules_location was manually specified
            post.return_value = Mock(status_code=404, reason="Not found", text="Nup")
            mdc = MalwareDetectionClient(
                InsightsConfig(retries=2),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.load_disabled_rules()
            log.debug.assert_any_call(
                "Unable to get disabled rules list from %s: %s",
                expected_graphql_url,
                "404 Not found: Nup",
            )
            log.debug.assert_any_call(
                "Unable to get disabled rules list.  Skipping ..."
            )
            log.debug.assert_called_with("Disabled rules: %s", [])
            assert post.called_with(
                expected_graphql_url, ANY, ANY, verify=True, stream=True
            )
            assert post.call_count == 2
            assert mdc.disabled_rules == []

            # Test other errors downloading rules from the backend - these are more likely to occur
            post.reset_mock()
            post.side_effect = [
                ConnectionError("Couldn't connect"),
                Timeout("Timeout"),
            ]
            mdc = MalwareDetectionClient(
                InsightsConfig(retries=3),
                MALWARE_CONFIG,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            mdc.load_rules()
            mdc.load_disabled_rules()
            log.debug.assert_any_call(
                "Unable to get disabled rules list from %s: %s",
                expected_graphql_url,
                "Couldn't connect",
            )
            log.debug.assert_any_call(
                "Unable to get disabled rules list from %s: %s",
                expected_graphql_url,
                "Timeout",
            )
            log.debug.assert_any_call(
                "Unable to get disabled rules list.  Skipping ..."
            )
            log.debug.assert_called_with("Disabled rules: %s", [])
            assert post.called_with(
                expected_graphql_url, ANY, ANY, verify=True, stream=True
            )
            assert post.call_count == 3
            assert mdc.disabled_rules == []

    class TestBuildYaraCmd:

        @patch("os.path.getsize")
        def test_build_yara_command_success(self, size):
            expected_yara_cmd = "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1}".format(
                FAKE_YARA, RULES_FILE
            )
            size.return_value = 1
            # Use side_effect with 3 'call' values because build_yara_command calls 'call' 3 times ...
            # 1 to get the type of the rules file; 2 to see if the rules files contains valid rules; 3 to call nproc
            # Test with text rules file - file type is 'ascii'
            with patch(CALL_TARGET, side_effect=["ascii", "ok", "2"]) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                # manually set rules
                mdc.rules_files = [RULES_FILE]
                mdc.parse_scan_options()
                mdc.build_yara_commands()

                assert call_mock.call_count == 3
            assert " ".join(mdc.yara_cmd) == expected_yara_cmd % ""

            # Test with 'compiled' rules file - file type is 'Yara 3.x'
            with patch(CALL_TARGET, side_effect=["Yara 3.X", "ok", "2"]) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                # manually set rules
                mdc.rules_files = [RULES_FILE]
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 3
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd % " -C"

            # Another test with compiled rules file - file type is 'data'
            with patch(CALL_TARGET, side_effect=["data", "ok", "2"]) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                # manually set rules
                mdc.rules_files = [RULES_FILE]
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 3
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd % " -C"

        @patch("os.path.getsize")
        @patch.dict(
            os.environ,
            {"TEST_SCAN": "false", "USE_REMOTE_RULES": "false"},
        )
        @patch(FINDMNT_TARGET)
        def test_build_yara_multiple_success(self, findmnt, size, add_3rd_party_rules):
            expected_yara_cmd1 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f -C%s {1}".format(
                    FAKE_YARA, SECOND_THIRD_PARTY_RULE_LOCATION
                )
            )
            expected_yara_cmd2 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f -C%s {1}".format(
                    FAKE_YARA, THIRD_PARTY_RULE_LOCATION
                )
            )
            expected_yara_cmd3 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f -C%s {1}".format(
                    FAKE_YARA, TEST_RULE_FILE
                )
            )
            expected_uncompiled_yara_cmd1 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1}".format(
                    FAKE_YARA, TEST_RULE_FILE
                )
            )
            expected_uncompiled_multiple_yara_cmd2 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1} {2}".format(
                    FAKE_YARA, SECOND_THIRD_PARTY_RULE_LOCATION, TEST_RULE_FILE
                )
            )
            expected_uncompiled_multiple_yara_cmd3 = (
                "nice -n 19 {0} -s -N -a 3600 -p 1 -r -f%s {1} {2} {3}".format(
                    FAKE_YARA,
                    SECOND_THIRD_PARTY_RULE_LOCATION,
                    THIRD_PARTY_RULE_LOCATION,
                    TEST_RULE_FILE,
                )
            )
            size.return_value = 1
            # Use side_effect with 3 'call' values because build_yara_command calls 'call' 3 times ...
            # 1 to get the type of the rules file; 2 to see if the rules files contains valid rules; 3 to call nproc
            # Test with text rules file - file type is 'ascii'
            # do this 3 times
            with patch(
                CALL_TARGET,
                side_effect=["data", "data", "data", "ok", "oc", "ok", "2"],
            ) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                mdc.load_rules()
                # manually add test rule
                mdc.rules_files.append(TEST_RULE_FILE)
                mdc.parse_scan_options()
                mdc.build_yara_commands()

                assert call_mock.call_count == 7
            assert not mdc.yara_cmd
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd1 % ""
            assert " ".join(mdc.yara_compiled_cmds[1]) == expected_yara_cmd2 % ""
            assert " ".join(mdc.yara_compiled_cmds[2]) == expected_yara_cmd3 % ""

            # Test with 'compiled' rules file - file type is 'Yara 3.x'
            with patch(
                CALL_TARGET,
                side_effect=[
                    "Yara 3.X",
                    "Yara 3.X",
                    "Yara 3.X",
                    "ok",
                    "ok",
                    "ok",
                    "2",
                ],
            ) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(), MALWARE_CONFIG, FAKE_YARA, FAKE_YARA_VERSION
                )
                mdc.load_rules()
                # manually add test rule
                mdc.rules_files.append(TEST_RULE_FILE)
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 7
            assert not mdc.yara_cmd
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd1 % ""
            assert " ".join(mdc.yara_compiled_cmds[1]) == expected_yara_cmd2 % ""
            assert " ".join(mdc.yara_compiled_cmds[2]) == expected_yara_cmd3 % ""

            # Test both compiled and uncompiled rules
            with patch(
                CALL_TARGET,
                side_effect=["data", "Yara 3.X", "ascii", "ok", "ok", "ok", "2"],
            ) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                # manually add test rule
                mdc.rules_files.append(TEST_RULE_FILE)
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 7
            assert " ".join(mdc.yara_cmd) == expected_uncompiled_yara_cmd1 % ""
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd1 % ""
            assert " ".join(mdc.yara_compiled_cmds[1]) == expected_yara_cmd2 % ""

            # Test both compiled and uncompiled rules
            with patch(
                CALL_TARGET,
                side_effect=["ascii", "Yara 3.X", "ascii", "ok", "ok", "ok", "2"],
            ) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                # manually add test rule
                mdc.rules_files.append(TEST_RULE_FILE)
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 7
            assert " ".join(mdc.yara_cmd) == expected_uncompiled_multiple_yara_cmd2 % ""
            assert " ".join(mdc.yara_compiled_cmds[0]) == expected_yara_cmd2 % ""

            # Test both compiled and uncompiled rules
            with patch(
                CALL_TARGET,
                side_effect=["ascii", "ascii", "ascii", "ok", "ok", "ok", "2"],
            ) as call_mock:
                mdc = MalwareDetectionClient(
                    InsightsConfig(retries=2),
                    MALWARE_CONFIG,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                # manually add test rule
                mdc.rules_files.append(TEST_RULE_FILE)
                mdc.parse_scan_options()
                mdc.build_yara_commands()
                assert call_mock.call_count == 7
            assert " ".join(mdc.yara_cmd) == expected_uncompiled_multiple_yara_cmd3 % ""

        @patch(LOGGER_TARGET)
        @patch("os.path.getsize")
        def test_build_yara_command_fail(self, size_mock, log_mock):
            # Test with empty rules file, ie file size is 0
            size_mock.return_value = 0
            with patch(CALL_TARGET, side_effect=["wtf?", "yikes", "2"]) as call_mock:
                with pytest.raises(SystemExit):
                    mdc = MalwareDetectionClient(
                        InsightsConfig(),
                        MALWARE_CONFIG,
                        FAKE_YARA,
                        FAKE_YARA_VERSION,
                    )
                    # manually set rule
                    mdc.rules_files = [RULES_FILE]
                    mdc.parse_scan_options()
                    mdc.build_yara_commands()
                call_mock.assert_called_once()  # Only 1 call to 'call' before we exit
            log_mock.error.assert_called_with("Rules file %s is empty", RULES_FILE)

            # Test with empty rules files, ie the file type is 'empty'
            size_mock.return_value = 1
            with patch(CALL_TARGET, side_effect=["empty", "yikes", "2"]) as call_mock:
                with pytest.raises(SystemExit):
                    mdc = MalwareDetectionClient(
                        InsightsConfig(),
                        MALWARE_CONFIG,
                        FAKE_YARA,
                        FAKE_YARA_VERSION,
                    )
                    # manually set rule
                    mdc.rules_files = [RULES_FILE]
                    mdc.parse_scan_options()
                    mdc.build_yara_commands()
                call_mock.assert_called_once()  # Only 1 call to 'call' before we exit
            log_mock.error.assert_called_with("Rules file %s is empty", RULES_FILE)

            # Test with 'invalid' rules file - raise CalledProcessError when running command
            with patch(CALL_TARGET) as call_mock:
                call_mock.side_effect = [
                    "yara",
                    CalledProcessError(1, "cmd", b"invalid\n"),
                    "2",
                ]
                with pytest.raises(SystemExit):
                    mdc = MalwareDetectionClient(
                        InsightsConfig(),
                        MALWARE_CONFIG,
                        FAKE_YARA,
                        FAKE_YARA_VERSION,
                    )
                    # manually set rule
                    mdc.rules_files = [RULES_FILE]
                    mdc.parse_scan_options()
                    mdc.build_yara_commands()
                assert call_mock.call_count == 2  # 2 calls to 'call' before we exit
            log_mock.error.assert_called_with(
                "Unable to use rules file %s: %s", RULES_FILE, "invalid"
            )

    @patch(LOGGER_TARGET)
    @patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
    @patch.dict(os.environ)
    class TestProcessScanning:

        @pytest.mark.skipif(IS_CONTAINER, reason=SKIP_IF_CONTAINER_REASON)
        def test_scan_processes(
            self,
            log_mock,
            create_test_files_fake_yara,
        ):
            # Test scanning processes to test which processes are going to be scanned
            os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    "scan_processes: true"
                    if line.startswith("scan_processes:")
                    else line
                )
                line = (
                    "add_metadata: false" if line.startswith("add_metadata:") else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rule
            mdc.rules_files = [TEST_RULE_FILE]
            mdc.parse_scan_options()
            assert mdc.do_filesystem_scan is True
            assert mdc.do_process_scan is True
            assert mdc.scan_pids == []
            assert mdc.processes_scan_exclude_list == []

            # Patch the calls to yara so it doesn't actually try to scan any processes
            with patch(CALL_TARGET, return_value=""):
                mdc.scan_processes()
            assert mdc.processes_scan_exclude_list == [TEST_PID]
            assert len(mdc.scan_pids) > 1
            assert "1" in mdc.scan_pids
            assert TEST_PID not in mdc.scan_pids

            # Exclude some processes via the config file
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_exclude: 1\n"
                    if line.startswith("processes_scan_exclude:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rule
            mdc.parse_scan_options()
            assert mdc.processes_scan_exclude_list == ["1"]
            # Patch the calls to yara so it doesn't actually try to scan any processes
            with patch(CALL_TARGET, return_value=""):
                mdc.scan_processes()
            assert mdc.processes_scan_exclude_list == ["1", TEST_PID]
            assert len(mdc.scan_pids) > 1
            assert all([x not in mdc.scan_pids for x in ["1", TEST_PID]])

            # Exclude some processes via env vars
            os.environ["PROCESSES_SCAN_EXCLUDE"] = "systemd,3..10"
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            assert all([pid in mdc.processes_scan_exclude_list for pid in ["1", "3"]])
            assert "2" not in mdc.processes_scan_exclude_list
            # Patch the calls to yara so it doesn't actually try to scan any processes
            with patch(CALL_TARGET, return_value=""):
                mdc.scan_processes()
            assert all(
                [pid in mdc.processes_scan_exclude_list for pid in ["1", "3", TEST_PID]]
            )
            assert len(mdc.scan_pids) > 1
            assert all([x not in mdc.scan_pids for x in ["1", "3", TEST_PID]])
            assert "2" in mdc.scan_pids

        @pytest.mark.skipif(
            not (TEST_PROCESSES_SCAN_SINCE or TEST_ALL),
            reason="test_processes_scan_since is slowish and could potentially fail. "
            "Use TEST_PROCESSES_SCAN_SINCE=True to enable test",
        )
        def test_processes_scan_since(self, log_mock, create_test_files_fake_yara):
            # Firstly, start the TEST_RULE_SCRIPT process then scan_only that process
            # Expect that we'll find it
            os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
            ps_call_output = call([["ps", "-eo", "pid=", "-o", "lstart="]])
            os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    "scan_filesystem: false"
                    if line.startswith("scan_filesystem:")
                    else line
                )
                line = (
                    "scan_processes: true"
                    if line.startswith("scan_processes:")
                    else line
                )
                line = (
                    "processes_scan_only: test-rule"
                    if line.startswith("processes_scan_only:")
                    else line
                )
                line = (
                    "add_metadata: false" if line.startswith("add_metadata:") else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rule
            mdc.rules_files = [TEST_RULE_FILE]
            mdc.parse_scan_options()

            assert mdc.do_filesystem_scan is False
            assert mdc.do_process_scan is True
            # Match TEST_RULE_SCRIPT process from processes_scan_only
            assert len(mdc.scan_pids) == 1

            # Now find processes started since the last scan, specifically the TEST_RULE_SCRIPT process
            # However expect to not find it because it wasn't started since the last_scan date
            last_scan = time.time()
            last_scan_fmt = datetime.fromtimestamp(last_scan).strftime(
                "%Y-%m-%d %H:%M:%S"
            )
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_since: last"
                    if line.startswith("processes_scan_since:")
                    else line
                )
                print(line)
            with patch(
                "insights.specs.datasources.malware_detection.utils.get_scan_since_timestamp",
                return_value=last_scan,
            ):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
            assert mdc.processes_scan_since_dict["timestamp"] == last_scan
            assert mdc.processes_scan_since_dict["datetime"] == last_scan_fmt
            # Still match the TEST_RULE_SCRIPT process from processes_scan_only
            assert len(mdc.scan_pids) == 1
            # But when we run scan_processes() it won't be found because it wasn't started since the last scan
            # Patch the calls to yara so it doesn't actually try to scan any processes
            with patch(CALL_TARGET, return_value=ps_call_output):
                mdc.scan_processes()
            assert len(mdc.scan_pids) == 0
            log_mock.error.assert_called_with(
                "No processes to scan because none were started since %s", last_scan_fmt
            )

            # Now find processes started since one day ago, specifically the TEST_RULE_SCRIPT process
            # Expect to find it this time it was started since a day ago
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "processes_scan_since: 1"
                    if line.startswith("processes_scan_since:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.parse_scan_options()
            # Still match the TEST_RULE_SCRIPT process from processes_scan_only
            assert len(mdc.scan_pids) == 1
            with patch(CALL_TARGET) as call_mock:
                # Patch calls to 'call' within the scan_processes function
                # The first call is to ps to get the process list, which is what we want
                # The second call is to yara, which we want to ignore since yara may not be installed
                call_mock.side_effect = [ps_call_output, ""]
                mdc.scan_processes()
            # Expect to find the TEST_RULE_SCRIPT process because it was started since a day ago
            assert len(mdc.scan_pids) == 1

            # Start another process and this time there will be a TEST_RULE_SCRIPT process started since last_scan date
            time.sleep(
                2
            )  # Wait a second to ensure the last_scan time is greater than the process start time
            os.system(TEST_RULE_SCRIPT + " &")  # Run the script in the background
            ps_call_output = call([["ps", "-eo", "pid=", "-o", "lstart="]])
            with patch(
                "insights.specs.datasources.malware_detection.utils.get_scan_since_timestamp",
                return_value=last_scan,
            ):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.parse_scan_options()
            # Match 2 TEST_RULE_SCRIPT processes from processes_scan_only
            assert len(mdc.scan_pids) == 2
            # But when we run scan_processes() only the latest one will be found
            with patch(CALL_TARGET) as call_mock:
                call_mock.side_effect = [ps_call_output, ""]
                mdc.scan_processes()
            # Only find the latest TEST_RULE_SCRIPT process
            assert len(mdc.scan_pids) == 1

    @patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
    @patch(
        "os.remove"
    )  # Mock os.remove so it doesn't actually try to remove any existing files
    @patch("insights.specs.datasources.malware_detection.rules.download_rules")
    @patch(
        "insights.specs.datasources.malware_detection.rules.save_rules_to_temp_file",
        return_value=RULES_FILE,
    )
    @patch(LOGGER_TARGET)
    class TestFilesystemScanning:

        def test_scan_rules_file_with_extra_slashes(
            self,
            log_mock,
            save,
            download,
            remove,
            create_test_files_fake_yara,
        ):
            # Test scanning RULES_FILE with an extra slash only in the rules_location one
            # Even with the extra slashes in the rules_location there will be rules matched
            # because */rules_compiled.yar and *//rules_compiled.yar are the same file
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "rules_location: %s\n" % TEST_RULE_FILE.replace("/", "//")
                    if line.startswith("rules_location:")
                    else line
                )
                line = (
                    "filesystem_scan_only: %s" % TEST_RULE_FILE
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                line = (
                    "add_metadata: false" if line.startswith("add_metadata:") else line
                )
                line = (
                    "exclude_network_filesystem_mountpoints: false"
                    if line.startswith("exclude_network_filesystem_mountpoints:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.load_rules()
            mdc.parse_scan_options()
            assert mdc.rules_location == TEST_RULE_FILE.replace("/", "//")
            assert mdc.rules_files == [TEST_RULE_FILE, RULES_FILE]
            assert mdc.scan_fsobjects == [TEST_RULE_FILE]
            with patch(CALL_TARGET) as call_mock:
                # Mock the scan match data from yara
                call_mock.return_value = (
                    "TEST_RedHatInsightsMalwareDetection %s\n0x4a:$re1: Malware Detection Client"
                    % TEST_RULE_FILE
                )
                mdc.scan_filesystem()
            rule_match = mdc.host_scan["TEST_RedHatInsightsMalwareDetection"]
            assert rule_match[0]["source"] == TEST_RULE_FILE
            assert rule_match[0]["string_data"] == "Malware Detection Client"
            assert rule_match[0]["string_identifier"] == "$re1"
            assert rule_match[0]["string_offset"] == 74
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s",
                "TEST_RedHatInsightsMalwareDetection",
                "file",
                TEST_RULE_FILE,
            )

        @patch(UTILS_LOGGER_TARGET)
        def test_scan_root_with_extra_slashes(
            self,
            util_log_mock,
            log_mock,
            save,
            download,
            remove,
            create_test_files_fake_yara,
        ):
            # Testing we handle the situation where items in filesystem_scan_only & scan_exclude contain multiple slashes
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "rules_location: %s\n" % TEST_RULE_FILE
                    if line.startswith("rules_location:")
                    else line
                )
                line = (
                    line + "- //\n"
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                line = (
                    line + "- //\n"
                    if line.startswith("filesystem_scan_exclude:")
                    else line
                )
                line = (
                    "exclude_network_filesystem_mountpoints: false"
                    if line.startswith("exclude_network_filesystem_mountpoints:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.load_rules()
            mdc.parse_scan_options()
            assert mdc.scan_fsobjects == ["/"]
            assert "/" in mdc.filesystem_scan_exclude_list
            # Chaos monkey - modify scan_fsobjects and filesystem_scan_exclude_list AFTER they have been verified
            # Assert that they still work and cancel each other out
            mdc.scan_fsobjects = ["//"]
            mdc.filesystem_scan_exclude_list = ["//"]
            mdc.scan_filesystem()
            assert mdc.do_filesystem_scan is False
            util_log_mock.error.assert_called_with(
                "No filesystem items to scan because the specified exclude items cancel them out"
            )

        @patch("insights.specs.datasources.malware_detection.NamedTemporaryFile")
        @patch(CALL_TARGET, return_value="")
        def test_filesystem_scan_since_tmp_files(
            self,
            call_mock,
            tmp_file_mock,
            log_mock,
            save,
            download,
            remove,
            extract_tmp_files,
            create_test_files_fake_yara,
        ):
            # Set filesystem_scan_only, filesystem_scan_exclude options to some of the tmp files and then 'scan' them
            # Then touch files to test the filesystem_scan_since option and make sure that only the touched files will be scanned
            yara_file_list = os.path.join(TEMP_TEST_DIR, "yara_file_list")
            scan_me_file = os.path.join(TEMP_TEST_DIR, "scan_me/scan_me_file")
            scan_me_too_file = os.path.join(
                TEMP_TEST_DIR, "scan_me_too/scan_me_too_file"
            )
            filesystem_scan_only = tuple(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me", "scan_me_too"]
                )
            )
            filesystem_scan_exclude = tuple(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me_not",
                        "scan_me/dont_scan_me",
                        "scan_me_too/dont_scan_me_too",
                    ],
                )
            )

            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = "test_scan: false" if line.startswith("test_scan:") else line
                line = (
                    line + "rules_location: %s\n" % TEST_RULE_FILE
                    if line.startswith("rules_location:")
                    else line
                )
                line = (
                    line + "- %s\n- %s" % filesystem_scan_only
                    if line.startswith("filesystem_scan_only:")
                    else line
                )
                line = (
                    line + "- %s\n- %s\n- %s" % filesystem_scan_exclude
                    if line.startswith("filesystem_scan_exclude:")
                    else line
                )
                line = (
                    "exclude_network_filesystem_mountpoints: false"
                    if line.startswith("exclude_network_filesystem_mountpoints:")
                    else line
                )
                print(line)
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.load_rules()
            mdc.parse_scan_options()
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            # Ensure the correct scan include and exclude values are set
            assert list(scan_dict.keys()) == ["/tmp"]
            assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
                filesystem_scan_exclude
            )

            # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
            # Also mock out the call to yara but we don't return anything since we aren't testing it
            with open(yara_file_list, "w") as f:
                tmp_file_mock.return_value = f
                mdc.scan_filesystem()
            with open(yara_file_list, "r") as f:
                contents = f.read().splitlines()
            # Ensure that a number of files are in the list of files passed to yara to scan
            assert len(contents) > 2
            assert all([x in contents for x in [scan_me_file, scan_me_too_file]])

            # With the same filesystem scan_only and scan_exclude values, add filesystem_scan_since: last into the mix and set
            # the last scan time to now.  There should be no matches because no files have been modified since now
            last_scan = time.time()
            last_scan_fmt = datetime.fromtimestamp(last_scan).strftime(
                "%Y-%m-%d %H:%M:%S"
            )
            for line in fileinput.FileInput(TEMP_CONFIG_FILE, inplace=1):
                line = (
                    "filesystem_scan_since: last"
                    if line.startswith("filesystem_scan_since:")
                    else line
                )
                print(line)
            with patch(
                "insights.specs.datasources.malware_detection.utils.get_scan_since_timestamp",
                return_value=last_scan,
            ):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                mdc.parse_scan_options()
            assert mdc.filesystem_scan_since_dict["timestamp"] == last_scan
            assert mdc.filesystem_scan_since_dict["datetime"] == last_scan_fmt
            log_mock.info.assert_called_with(
                "Scan for files created/modified since %s%s", ANY, ANY
            )

            # Run scan_filesystem, but mock out NamedTemporaryFile so we can use our own file and inspect its contents after
            # Also mock out the call to yara, but we don't return anything since we aren't testing it
            with open(yara_file_list, "w") as f:
                tmp_file_mock.return_value = f
                mdc.scan_filesystem()
            with open(yara_file_list, "r") as f:
                contents = f.read().splitlines()
            # Ensure no files were passed to yara to scan because none were modified since 'last_scan'
            assert not contents

            # Try again, keeping the same last_scan time, but this time touch 2 files
            # Confirm that only these 2 files appear in the list of files to be passed to yara
            os.system("touch %s %s" % (scan_me_file, scan_me_too_file))
            with patch(
                "insights.specs.datasources.malware_detection.utils.get_scan_since_timestamp",
                return_value=last_scan,
            ):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                mdc.parse_scan_options()

            with open(yara_file_list, "w") as f:
                tmp_file_mock.return_value = f
                mdc.scan_filesystem()
            with open(yara_file_list, "r") as f:
                contents = f.read().splitlines()
            # Ensure the scan_me_file was passed to yara to scan because it was 'modified' since 'last_scan'
            assert len(contents) == 2
            assert contents == [scan_me_file, scan_me_too_file]

            # Touch some files that are excluded from scanning so even though they have been modified, they won't be
            # in the list of files to scan that is passed to yara
            os.system(
                "touch %s %s %s"
                % (
                    os.path.join(TEMP_TEST_DIR, "scan_me/dont_scan_me/matching_entity"),
                    os.path.join(TEMP_TEST_DIR, "scan_me_not/matching_entity"),
                    os.path.join(
                        TEMP_TEST_DIR,
                        "scan_me_too/dont_scan_me_too/'another matching_entity'",
                    ),
                )
            )
            with patch(
                "insights.specs.datasources.malware_detection.utils.get_scan_since_timestamp",
                return_value=last_scan,
            ):
                altered_malware_config = load_or_create_malware_config()
                mdc = MalwareDetectionClient(
                    InsightsConfig(),
                    altered_malware_config,
                    FAKE_YARA,
                    FAKE_YARA_VERSION,
                )
                mdc.load_rules()
                mdc.parse_scan_options()

            with open(yara_file_list, "w") as f:
                tmp_file_mock.return_value = f
                mdc.scan_filesystem()
            with open(yara_file_list, "r") as f:
                contents = f.read().splitlines()
            # Ensure both scan_me_file and scan_me_too_file were passed to yara because both were modified since last_scan
            assert len(contents) == 2
            assert contents == [scan_me_file, scan_me_too_file]

        @patch(LOAD_CONFIG_TARGET, return_value=MALWARE_CONFIG)
        @patch.dict(os.environ)
        def test_rule_n_glob_files_excluded(
            self,
            conf,
            log_mock,
            save,
            download,
            remove,
            extract_tmp_files,
            create_test_files_fake_yara,
        ):
            # Fake a scan but make sure we are excluding the rules file and globbed files (they are supposed to be
            # insights log files, but that's hard to mock).
            # Also test we are not excluding ones we actually want to scan
            glob_files = [
                os.path.join(TEMP_TEST_DIR, "scan_me", f)
                for f in ["new_file", "old_file"]
            ]
            os.environ["TEST_SCAN"] = "false"
            os.environ["USE_REMOTE_RULES"] = "false"
            os.environ["EXCLUDE_NETWORK_FILESYSTEM_MOUNTPOINTS"] = "false"
            os.environ["RULES_LOCATION"] = TEST_RULE_FILE
            os.environ["FILESYSTEM_SCAN_ONLY"] = "%s,%s" % (
                TEMP_TEST_DIR,
                glob_files[1],
            )  # we actually want to scan glob_files[1]
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.load_rules()
            mdc.parse_scan_options()

            assert mdc.rules_files == [TEST_RULE_FILE]
            assert mdc.scan_fsobjects == [TEMP_TEST_DIR, glob_files[1]]

            # Patch the call to glob so it returns a specific list of files
            # Patch the calls for running yara and have it return no matches
            with patch(
                "insights.specs.datasources.malware_detection.glob",
                return_value=glob_files,
            ):
                with patch(CALL_TARGET, return_value=""):
                    mdc.scan_filesystem()
            for r in mdc.rules_files:
                assert r in mdc.filesystem_scan_exclude_list
            assert glob_files[0] in mdc.filesystem_scan_exclude_list
            # Make sure glob_files[1] isn't excluded because we actually want to scan that file
            assert glob_files[1] not in mdc.filesystem_scan_exclude_list

            # This time patch glob so it returns an empty list, ie simulating no extra files to exclude
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            mdc.load_rules()
            mdc.parse_scan_options()
            with patch(
                "insights.specs.datasources.malware_detection.glob", return_value=[]
            ):
                with patch(CALL_TARGET, return_value=""):
                    mdc.scan_filesystem()
            for r in mdc.rules_files:
                assert r in mdc.filesystem_scan_exclude_list
            # None of the glob files should be excluded this time
            assert all([f not in mdc.filesystem_scan_exclude_list for f in glob_files])

    @patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
    @patch(FINDMNT_TARGET)
    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    class TestFilesystemIncludeExcludeProcessing:

        def test_process_include_exclude_items_simple(self, findmnt):
            # Test the process_include_exclude_items function with simple modified include and exclude items
            # Simple in that the include and exclude files are modified in such a way that
            # directory listings aren't required get the list of included files
            # Add a single toplevel directory to the include file - expect only a single directory to scan
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            mdc.parse_scan_options()

            mdc.scan_fsobjects = ["/etc"]
            mdc.filesystem_scan_exclude_list = []
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert list(scan_dict.keys()) == ["/etc"]
            assert "include" not in scan_dict["/etc"]
            assert "exclude" not in scan_dict["/etc"]

            # Add some extra subdirectories to scan
            mdc.scan_fsobjects.extend(["/var/lib", "/var/log"])
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert sorted(scan_dict.keys()) == ["/etc", "/var"]
            assert sorted(list(scan_dict["/var"]["include"])) == [
                "/var/lib",
                "/var/log",
            ]
            assert "exclude" not in scan_dict["/var"]

            # Add some extra directories to exclude that won't impact the already included directories
            mdc.filesystem_scan_exclude_list.extend(["/tmp", "/var/run"])
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert sorted(scan_dict.keys()) == ["/etc", "/var"]
            assert sorted(scan_dict["/var"]["include"]) == ["/var/lib", "/var/log"]
            assert scan_dict["/var"]["exclude"]["items"] == ["/var/run"]

            # Exclude /var which will remove it from the list of directories to scan
            mdc.filesystem_scan_exclude_list.append("/var")
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert list(scan_dict.keys()) == ["/etc"]

            # Exclude /etc which means there will be no directories to scan
            mdc.filesystem_scan_exclude_list.append("/etc")
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert scan_dict == {}

        def test_process_include_exclude_items_complex(self, findmnt):
            # Test the process function with modified include and exclude files that will require more complex
            # processing to generate the list of items to be scanned
            # Because we are including items in /var/lib, we only need to list the contents of the /var/lib directory
            # We don't need to list the contents of the /var directory
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            mdc.parse_scan_options()

            mdc.scan_fsobjects = ["/var/lib", "/var/log"]
            mdc.filesystem_scan_exclude_list = [
                "/var/lib/systemd",
                "/var/lib/misc/",
                "/var/log/wtmp",
            ]

            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert list(scan_dict.keys()) == ["/var"]
            assert sorted(scan_dict["/var"]["exclude"]["items"]) == [
                "/var/lib/misc",
                "/var/lib/systemd",
                "/var/log/wtmp",
            ]
            # The exclude items shouldn't be in the include items
            # Nor should other items that aren't in the explicitly included items
            assert all(
                [
                    x not in scan_dict["/var"]["include"]
                    for x in [
                        "/var/lib/misc",
                        "/var/lib/systemd",
                        "/var/log/wtmp",
                        "/var/cache",
                        "/var/lib",
                        "/var/log",
                        "/var/tmp",
                        "/tmp",
                    ]
                ]
            )
            # In 'include' will be items that are in the same directory as the excluded items, eg /var/log/lastlog
            # but not the excluded items, eg /var/log/wtmp
            # Some of these directories may not exist on the test system, but if they do they will be included
            maybe_dirs = list(
                filter(
                    lambda path: os.path.exists(path),
                    [
                        "/var/lib/dbus",
                        "/var/lib/pam",
                        "/var/lib/rpm",
                        "/var/log/lastlog",
                    ],
                )
            )
            assert all([x in scan_dict["/var"]["include"] for x in maybe_dirs])

            # Change the include directory to /var
            # Now immediate child directories of /var will be in the include list, eg /var/cache and /var/tmp
            # Because now we have to list the contents of the /var and /var/lib directories
            mdc.scan_fsobjects.append("/var")
            scan_dict = process_include_exclude_items(
                include_items=mdc.scan_fsobjects,
                exclude_items=mdc.filesystem_scan_exclude_list,
            )
            assert list(scan_dict.keys()) == ["/var"]
            assert sorted(scan_dict["/var"]["exclude"]["items"]) == [
                "/var/lib/misc",
                "/var/lib/systemd",
                "/var/log/wtmp",
            ]
            assert all(
                [
                    x not in scan_dict["/var"]["include"]
                    for x in [
                        "/var/lib/misc",
                        "/var/lib/systemd",
                        "/var/log/wtmp",
                        "/var/lib",
                        "/var/log",
                        "/tmp",
                    ]
                ]
            )
            # Some of these directories may not exist on the test system, but if they do they will be included
            maybe_dirs = list(
                filter(
                    lambda path: os.path.exists(path),
                    [
                        "/var/cache",
                        "/var/tmp",
                        "/var/lib/dbus",
                        "/var/lib/pam",
                        "/var/lib/rpm",
                        "/var/log/lastlog",
                    ],
                )
            )
            assert all([x in scan_dict["/var"]["include"] for x in maybe_dirs])

    @patch(CONFIG_FILE_TARGET, TEMP_CONFIG_FILE)
    @patch(FINDMNT_TARGET)
    @patch.dict(os.environ, {"TEST_SCAN": "false"})
    class TestParseScanOutput:

        def test_contrived_scan_output(self, findmnt):
            # Parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            mdc.parse_scan_options()
            assert mdc.disabled_rules == []
            mdc.add_metadata = False
            mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

            # Expect 5 rule matches and 8 source/file matches across the 5 rules
            # 1 source/file match for rule 'this', 3 source/file matches for rule 'Rule',
            # 2 for 'another_matching_rule', 1 for 'Iyamtho' and 1 for 'n_m3_t00'
            assert len(mdc.host_scan) == 5  # 5 rules matched
            assert mdc.matches == 8  # 8 sources/files matched across the 5 rules

            # 1 matching source/file and 1 matching string for rule 'this'
            rule_match = mdc.host_scan["this"]
            rule_sources = set(map(lambda x: x["source"], rule_match))
            assert len(rule_sources) == 1
            assert len(rule_match) == 1
            assert "e-r-r-o-r s-c-a-n-n-i-n-g" in rule_match[0]["source"]
            assert rule_match[0]["string_data"] == "matches 'this' rule"
            assert rule_match[0]["string_identifier"] == "$match"
            assert rule_match[0]["string_offset"] == 291

            # 3 source/file matches and 14 matching strings across those sources for rule 'Rule'
            rule_match = mdc.host_scan["Rule"]
            rule_sources = set(map(lambda x: x["source"], rule_match))
            assert len(rule_sources) == 3
            assert len(rule_match) == 14
            assert rule_match[0]["source"] == MATCHING_ENTITY_FILE
            assert (
                rule_match[0]["string_data"]
                == 'string match in the file "matching_entity"'
            )
            assert rule_match[0]["string_identifier"] == "$match0"
            assert rule_match[0]["string_offset"] == 21
            assert rule_match[1]["source"] == MATCHING_ENTITY_FILE
            assert (
                rule_match[1]["string_data"]
                == "another string match in matching_entity"
            )
            assert rule_match[1]["string_identifier"] == "$match1"
            assert rule_match[1]["string_offset"] == 83
            assert rule_match[2]["source"] == MATCHING_ENTITY_FILE
            assert (
                rule_match[2]["string_data"]
                == "string with different types of quotes 'here' and \"here\""
            )
            assert rule_match[2]["string_identifier"] == "$match2"
            assert rule_match[2]["string_offset"] == 230

            # Rule matches for ANOTHER_MATCHING_ENTITY_FILE (which has a space in the filename)
            assert rule_match[3]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert (
                rule_match[3]["string_data"]
                == "string match containing error scanning but it's ok because its not in a rule line"
            )
            assert rule_match[3]["string_identifier"] == "$match3"
            assert rule_match[3]["string_offset"] == 2
            assert rule_match[4]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[4]["string_data"] == "contains ="
            assert rule_match[4]["string_identifier"] == "$grep1"
            assert rule_match[4]["string_offset"] == 97
            assert rule_match[6]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[6]["string_data"] == "contains .+"
            assert rule_match[6]["string_identifier"] == "$grep2"
            assert rule_match[6]["string_offset"] == 153
            assert rule_match[8]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[8]["string_data"] == 'contains "'
            assert rule_match[8]["string_identifier"] == "$grep3"
            assert rule_match[8]["string_offset"] == 213
            assert rule_match[9]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[9]["string_data"] == "contains '"
            assert rule_match[9]["string_identifier"] == "$grep4"
            assert rule_match[9]["string_offset"] == 241
            assert rule_match[10]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[10]["string_data"] == "contains ()[]"
            assert rule_match[10]["string_identifier"] == "$grep5"
            assert rule_match[10]["string_offset"] == 269
            assert rule_match[11]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[11]["string_data"] == "contains {"
            assert rule_match[11]["string_identifier"] == "$grep6"
            assert rule_match[11]["string_offset"] == 299
            assert rule_match[12]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[12]["string_data"] == "contains ^$"
            assert rule_match[12]["string_identifier"] == "$grep7"
            assert rule_match[12]["string_offset"] == 327

            assert rule_match[13]["source"].startswith("matching_entity_3")
            assert rule_match[13]["string_data"] == ""
            assert rule_match[13]["string_identifier"] == ""
            assert rule_match[13]["string_offset"] == -1

            # 2 source matches and 4 matching strings for 'another_matching_rule'
            rule_match = mdc.host_scan["another_matching_rule"]
            rule_sources = set(map(lambda x: x["source"], rule_match))
            assert len(rule_sources) == 2
            assert len(rule_match) == 4
            assert rule_match[2]["source"].endswith(
                "snap/signal-desktop/350/opt/Signal/resources/app.asar"
            )
            assert rule_match[2]["string_data"] == "#!/bin/sh"
            assert rule_match[2]["string_identifier"] == "$s0"
            assert rule_match[2]["string_offset"] == 60783814
            assert rule_match[3]["source"] == "1234567"
            assert rule_match[3]["string_data"] == "#!/bin/sh"
            assert rule_match[3]["string_identifier"] == "$s0"
            assert rule_match[3]["string_offset"] == 0

            # 1 matching source and 1 matching string for 'Iyamtho'
            rule_match = mdc.host_scan["Iyamtho"]
            assert len(rule_match) == 1
            assert rule_match[0]["source"] == " yep"
            assert rule_match[0]["string_data"] == ""
            assert rule_match[0]["string_identifier"] == ""
            assert rule_match[0]["string_offset"] == -1

            # 1 matching source and 1 matching string for 'n_m3_t00'
            rule_match = mdc.host_scan["n_m3_t00"]
            assert len(rule_match) == 1
            assert rule_match[0]["source"] == "damn   straight"
            assert rule_match[0]["string_data"] == ""
            assert rule_match[0]["string_identifier"] == ""
            assert rule_match[0]["string_offset"] == -1

        def test_contrived_scan_output_metadata(
            self,
            findmnt,
            create_test_files_fake_yara,
        ):
            # Again, parse the CONTRIVED_SCAN_OUTPUT to find actual rule matches amongst malformed output lines,
            # but this time check the expected metadata values too

            # Again, need to populate rules_file_location with any rule, but its not relevant for the tests
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            mdc.parse_scan_options()

            mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)

            # Matches and metadata for MATCHING_ENTITY_FILE
            rule_match = mdc.host_scan["Rule"]
            assert rule_match[0]["source"] == MATCHING_ENTITY_FILE
            assert rule_match[0]["string_offset"] == 21
            metadata = rule_match[0]["metadata"]
            assert metadata["source_type"] == "file"
            assert metadata["file_type"] == "ASCII text"
            assert metadata["mime_type"] == "text/plain; charset=us-ascii"
            assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
            assert metadata["line_number"] == 1
            assert metadata["line"] == urlencode(
                'This line contains a string match in the file "matching_entity"'
            )

            # Testing displaying long lines
            assert rule_match[1]["source"] == MATCHING_ENTITY_FILE
            assert rule_match[1]["string_offset"] == 83
            metadata = rule_match[1]["metadata"]
            assert metadata["source_type"] == "file"
            assert metadata["file_type"] == "ASCII text"
            assert metadata["mime_type"] == "text/plain; charset=us-ascii"
            assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
            assert metadata["line_number"] == 2
            assert metadata["line"] == urlencode(
                "This line contains another string match in matching_entity and it is very long for testing the ellipses that are added o..."
            )

            # Testing matching/displaying a mixture of quote types in the string_data
            assert rule_match[2]["source"] == MATCHING_ENTITY_FILE
            assert rule_match[2]["string_offset"] == 230
            metadata = rule_match[2]["metadata"]
            assert metadata["source_type"] == "file"
            assert metadata["file_type"] == "ASCII text"
            assert metadata["mime_type"] == "text/plain; charset=us-ascii"
            assert metadata["md5sum"] == "9dd5c5e00d28520dc9da3c509c0db2a0"
            assert metadata["line_number"] == 4
            assert metadata["line"] == urlencode(
                """And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough"""
            )

            # Rule match metadata for ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[3]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[3]["string_offset"] == 2
            metadata = rule_match[3]["metadata"]
            assert metadata["source_type"] == "file"
            assert metadata["file_type"] == "ASCII text"
            assert metadata["mime_type"] == "text/plain; charset=us-ascii"
            assert metadata["md5sum"] == "64764d295e92ffeec36d3fcd646a3af4"
            assert metadata["line_number"] == 3
            assert metadata["line"] == urlencode(
                "string match containing error scanning but it's ok because its not in a rule line"
            )

            assert rule_match[4]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[4]["string_offset"] == 97
            metadata = rule_match[4]["metadata"]
            assert metadata["md5sum"] == "64764d295e92ffeec36d3fcd646a3af4"
            assert metadata["line_number"] == 7
            assert metadata["line"] == urlencode("This line contains = char")

            assert rule_match[5]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[5]["string_offset"] == 123
            metadata = rule_match[5]["metadata"]
            assert metadata["line_number"] == 8
            assert metadata["line"] == urlencode("This line contains = char too")

            assert rule_match[6]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[6]["string_offset"] == 153
            metadata = rule_match[6]["metadata"]
            assert metadata["line_number"] == 9
            assert metadata["line"] == urlencode("This line contains .+ chars")

            assert rule_match[8]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[8]["string_offset"] == 213
            metadata = rule_match[8]["metadata"]
            assert metadata["line_number"] == 11
            assert metadata["line"] == urlencode('This line contains "" chars')

            assert rule_match[9]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[9]["string_offset"] == 241
            metadata = rule_match[9]["metadata"]
            assert metadata["line_number"] == 12
            assert metadata["line"] == urlencode("This line contains '' chars")

            assert rule_match[10]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[10]["string_offset"] == 269
            metadata = rule_match[10]["metadata"]
            assert metadata["line_number"] == 13
            assert metadata["line"] == urlencode("This line contains ()[] chars")

            assert rule_match[11]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[11]["string_offset"] == 299
            metadata = rule_match[11]["metadata"]
            assert metadata["line_number"] == 14
            assert metadata["line"] == urlencode("This line contains {} chars")

            assert rule_match[12]["source"] == ANOTHER_MATCHING_ENTITY_FILE
            assert rule_match[12]["string_offset"] == 327
            metadata = rule_match[12]["metadata"]
            assert metadata["line_number"] == 15
            assert metadata["line"] == urlencode("This line contains ^$ chars")

            # Testing a missing file - expect minimal metadata because we can't know the other values
            assert (
                rule_match[13]["source"]
                == "matching_entity_3, but without any string matches - yes that's ok"
            )
            metadata = rule_match[13]["metadata"]
            assert metadata["source_type"] == "file"
            assert all(
                [
                    key not in ["file_type", "md5sum", "line_number"]
                    for key in metadata.keys()
                ]
            )

            # Testing a missing file for another rule - again, expect minimal metadata because we can't find out more info
            rule_match = mdc.host_scan["another_matching_rule"]
            assert rule_match[2]["source"].endswith(
                "snap/signal-desktop/350/opt/Signal/resources/app.asar"
            )
            metadata = rule_match[2]["metadata"]
            assert metadata["source_type"] == "file"
            assert all(
                [
                    key not in ["file_type", "md5sum", "line_number"]
                    for key in metadata.keys()
                ]
            )

            # Testing a missing process - again, expect minimal metadata because we can't find out more info
            assert rule_match[3]["source"] == "1234567"
            metadata = rule_match[3]["metadata"]
            assert metadata["source_type"] == "process"
            assert all(
                [
                    key not in ["process_name", "file_type", "md5sum", "line_number"]
                    for key in metadata.keys()
                ]
            )

        @patch(LOGGER_TARGET)
        def test_contrived_scan_output_with_disabled_rules(
            self,
            log_mock,
            findmnt,
        ):
            # Parse the CONTRIVED_SCAN_OUTPUT but with a number of disabled rules
            # Disable 3 of the rules in CONTRIVED_SCAN_OUTPUT, expect 2 matching rules
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            # manually set disabled rules
            mdc.disabled_rules = ["this", "rule", "another_matching_rule"]
            mdc.parse_scan_options()

            mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)
            assert mdc.matches == 2
            assert all(
                list(
                    map(
                        lambda x: x not in ["this", "Rule", "another_matching_rule"],
                        mdc.host_scan,
                    )
                )
            )
            assert all(list(map(lambda x: x in ["Iyamtho", "n_m3_t00"], mdc.host_scan)))
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "this", "file", ANY
            )
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "Rule", "file", ANY
            )
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s", "Iyamtho", "file", ANY
            )
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s", "n_m3_t00", "file", ANY
            )

            # disable all rules except 'Rule', because it isn't excluded
            log_mock.debug.reset_mock()
            log_mock.info.reset_mock()

            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            # manually set disabled rules
            mdc.disabled_rules = [
                "this",
                "rool",
                "another_matching_rule",
                "iyamtho",
                "n_m3_t00",
            ]
            mdc.parse_scan_options()

            mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)
            assert list(mdc.host_scan) == ["Rule"]
            assert mdc.matches == 3
            sources = set(map(lambda x: x["source"], mdc.host_scan["Rule"]))
            assert len(sources) == 3
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "Iyamtho", "file", ANY
            )
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s", "Rule", "file", ANY
            )

        def test_random_output(self, findmnt):
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            mdc.parse_scan_options()

            assert mdc.disabled_rules == []
            mdc.parse_scan_output(RANDOM_OUTPUT)
            assert mdc.matches == 2
            rule_match = mdc.host_scan["Lorem"]
            assert rule_match[0]["source"].startswith("ipsum dolor")
            assert rule_match[0]["string_data"] == ""
            assert rule_match[0]["string_identifier"] == ""
            assert rule_match[0]["string_offset"] == -1
            rule_match = mdc.host_scan["Dictum"]
            assert rule_match[0]["source"].startswith("at tempor")
            assert rule_match[0]["string_data"] == ""
            assert rule_match[0]["string_identifier"] == ""
            assert rule_match[0]["string_offset"] == -1

        @patch(LOGGER_TARGET)
        def test_random_output_with_disabled_rules(
            self,
            log_mock,
            findmnt,
        ):
            # Test various disabled rules with parsing RANDOM_OUTPUT
            # Disable 'Lorem' rule (and others) and expect just to match the 'Dictum' rule
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            # manually set disabled rules
            mdc.disabled_rules = ["random", "rules", "and", "lorem"]
            mdc.parse_scan_options()

            mdc.parse_scan_output(RANDOM_OUTPUT)
            assert mdc.matches == 1
            assert list(mdc.host_scan) == ["Dictum"]
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "Lorem", "file", ANY
            )

            # Disable both 'Lorem' and 'Dictum' rules and expect to have no matches
            log_mock.debug.reset_mock()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            # manually set disabled rules
            mdc.disabled_rules = ["dictum", "lorem"]
            mdc.parse_scan_options()

            mdc.parse_scan_output(RANDOM_OUTPUT)
            assert mdc.matches == 0
            assert mdc.host_scan == {}
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "Dictum", "file", ANY
            )
            log_mock.debug.assert_any_call(
                "Skipping matches for disabled rule %s in %s %s", "Lorem", "file", ANY
            )

            # Disable rules other than 'Lorem' and 'Dictum' and expect match both those rules
            altered_malware_config = load_or_create_malware_config()
            mdc = MalwareDetectionClient(
                InsightsConfig(),
                altered_malware_config,
                FAKE_YARA,
                FAKE_YARA_VERSION,
            )
            # manually set rules
            mdc.rules_files = [RULES_FILE]
            # manually set disabled rules
            mdc.disabled_rules = ["dictumm", "lore", "and", "other", "rules"]
            mdc.parse_scan_options()

            mdc.parse_scan_output(RANDOM_OUTPUT)
            assert mdc.matches == 2
            assert sorted(mdc.host_scan) == ["Dictum", "Lorem"]
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s", "Dictum", "file", ANY
            )
            log_mock.info.assert_any_call(
                "Matched rule %s in %s %s", "Lorem", "file", ANY
            )


# Base64 representation of a tgz file containing simple files to be extracted into /tmp to be used for scanning
# It is decoded and unzipped in the extract_tmp_files fixture
SCAN_FILES_BASE64 = """
H4sIAD+feGEAA+1a247TMBDtc79iVCEVhARxrk888A+8IajSxt1Ym8YlcXZVIf6dcbZG2WzTkm5t
ijpnH3KxHbt7PPaZGdertFxs+MeJRXiIJIn0lSWR170aTFjIgpixJAyCicdY5IcTiGwOyqCpVVoB
TDZ5o/Ij9U6V/6eo9/yX/HGxFgW30YcmOI7DEfwHvh9NwLMxmD6I/5Z/WWRXxT/ziX8XMPxvxZbb
mgBn8B8kyQRiC2N5AeK/5T+TpVrUdsTA+P0/ZFFE+78LHOR/k6pVLsq7BS+VULvX9nHK/iMv6PGf
+Fid1n8H+JKLGgpRcljhDEhFWUMKtaqQfWinAYgSVM5B7w0w682M2fRQ+1Jig+rFV3ptsV4GQgG2
f+DVDgqJldeyAsVrpRvqXnlRiG3Na3xIFaQVhzTLeAbYl+w00wOop9PP+EV15Ac9CpVDJtZrXuEY
QO22+GW5hh+NxE5hjqPm83ZcM3072w+xfupESQnLRgH+vKcXvJTNXT791xS+Csbkl5W85+UC/3H3
F+/jaf1PRqz/MYtw//dtDsrgxu3f8G9p628xfv8P8I/2fxfo86/XvYVYpJsL9jFe/4dJRP6fE/T4
t+ICtvyHw/wnQdTn34ti4t8FptNnMm2vmfQLXlUoxvS8aB+18hFqjnrpHpZ8lTY1b6WRVkMo7lKo
GhSIWnhNEQdk4SdY5Wk1XKL11aHSD+/b4vpY2VDb2Wy47Xw+XPb23ddvw6U/fw2XfX9zumw/Wg7b
ij8I2ezrpUa9SnzQYlPLXXFXygoFb6olMN+175Z8J9u6HDK+TptCAfOey+1CbIT6G2Vq7F9rLJvx
n1H6z2e4AqD+s+mUGty4/Zt1H83YWg5ovP7zQ4/yP07Q5d9WDugM/cc8yv84QZd/WzmgM/j3EtL/
TtDl31YO6Az+/YjyP07Q5f/PPX/g1QXVwPj9P/KZR/u/Cwzzb8L4r9fdp+z/hf/v4zWh9d8FyP8n
/9/YvyUP+4z8bxSxgOzfBSj/S/lfY/+2YoCj438sCWKd/7W1IHVx4/Zv+MfJfV3xPzr/5QRd/rvh
9ktOiDP8v4QlxL8LHOX/Qi7geP/PDyn/6wbk/5H/Z8z9qvI/ZP9O0OX/qvI/5P87QZf/a8r/xB7l
f1ygy7+t49Zn+P9ee/6Hzn9bR5d/W7GA8f5fGOv1n/w/+xjg/6LbQLv+Hzn/eyD+j7e0/7sAxf8p
/m/s/2ri/34Y+EHv/O8lA1Jd3Lj9EwgEAoFAIBBuC78BaSEregBQAAA=""".replace(
    "\n", ""
)


MATCHING_ENTITY_FILE_CONTENTS = """
This line contains a string match in the file "matching_entity"
This line contains another string match in matching_entity and it is very long for testing the ellipses that are added onto very long lines

And this line contains a string with different types of quotes 'here' and "here" and its long too but not long enough
""".lstrip()

ANOTHER_MATCHING_ENTITY_FILE_CONTENTS = """


string match containing error scanning but it's ok because its not in a rule line



This line contains = char
This line contains = char too
This line contains .+ chars
This line contains .+ chars too
This line contains "" chars
This line contains '' chars
This line contains ()[] chars
This line contains {} chars
This line contains ^$ chars
This line contains ^$ chars too
The previous line and this one too are ignored as they are beyond the default 10 string match limit
"""[
    1:
]  # Ignore first newline char otherwise it changes the md5sum

TEST_RULE_FILE_CONTENTS = """
rule TEST_RedHatInsightsMalwareDetection
// Verifies the Red Hat Insights Malware Detection Client app is present on the system
{
    strings:
        $re1 = /Malware ?Detection ?Client/
    condition:
        $re1
}
""".lstrip()

THIRD_PARTY_RULES_FILE_CONTENTS = """
rule TEST_3RD_PARTY_RULES
// 3rd party rules added to system to be used by malware detection
{
    strings:
        $re1 = /Malware ?Detection ?Client/
    condition:
        $re1
}
""".lstrip()

TEST_RULE_SCRIPT_CONTENTS = """
#!/bin/sh
# As a process this will match the TEST_RedHatInsightsMalwareDetection rule
echo "Malware Detection Client"
sleep 3
""".lstrip()

CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
Rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
Rule %s
0x15:$match0: string match in the file "matching_entity"
0x53:$match1: another string match in matching_entity
0xe6:$match2: string with different types of quotes 'here' and "here"
Rule %s
0x2:$match3: string match containing error scanning but it's ok because its not in a rule line
0x61:$grep1: contains =
0x7b:$grep1: contains =
0x99:$grep2: contains .+
0xb5:$grep2: contains .+
0xd5:$grep3: contains "
0xf1:$grep4: contains '
0x10d:$grep5: contains ()[]
0x12b:$grep6: contains {
0x147:$grep7: contains ^$
0x163:$grep7: contains ^$
0x179:$ignored: The previous line and this one too are ignored as they are beyond the default 10 string match limit
Rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 1234567
0x0:$s0: #!/bin/sh
0x1badoffset:$s1: skip this line
0x2error scanning skip/this/line/too: need more colons
badoffset_but_notarule:$s2: a bad offset line that looks a bit like a rule line but really isn't
007 isn't considered a valid rule name
666neither is this
_me neither
 same here
nor: I
Iyamtho  yep
n_m3_t00 damn   straight
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
""" % (
    MATCHING_ENTITY_FILE,
    ANOTHER_MATCHING_ENTITY_FILE,
)

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""

# Base64 representation of a tgz file containing simple files to be extracted into /tmp to be used for scanning
# It is decoded and unzipped in the extract_tmp_files fixture
SCAN_FILES_BASE64 = """
H4sIAD+feGEAA+1a247TMBDtc79iVCEVhARxrk888A+8IajSxt1Ym8YlcXZVIf6dcbZG2WzTkm5t
ijpnH3KxHbt7PPaZGdertFxs+MeJRXiIJIn0lSWR170aTFjIgpixJAyCicdY5IcTiGwOyqCpVVoB
TDZ5o/Ij9U6V/6eo9/yX/HGxFgW30YcmOI7DEfwHvh9NwLMxmD6I/5Z/WWRXxT/ziX8XMPxvxZbb
mgBn8B8kyQRiC2N5AeK/5T+TpVrUdsTA+P0/ZFFE+78LHOR/k6pVLsq7BS+VULvX9nHK/iMv6PGf
+Fid1n8H+JKLGgpRcljhDEhFWUMKtaqQfWinAYgSVM5B7w0w682M2fRQ+1Jig+rFV3ptsV4GQgG2
f+DVDgqJldeyAsVrpRvqXnlRiG3Na3xIFaQVhzTLeAbYl+w00wOop9PP+EV15Ac9CpVDJtZrXuEY
QO22+GW5hh+NxE5hjqPm83ZcM3072w+xfupESQnLRgH+vKcXvJTNXT791xS+Csbkl5W85+UC/3H3
F+/jaf1PRqz/MYtw//dtDsrgxu3f8G9p628xfv8P8I/2fxfo86/XvYVYpJsL9jFe/4dJRP6fE/T4
t+ICtvyHw/wnQdTn34ti4t8FptNnMm2vmfQLXlUoxvS8aB+18hFqjnrpHpZ8lTY1b6WRVkMo7lKo
GhSIWnhNEQdk4SdY5Wk1XKL11aHSD+/b4vpY2VDb2Wy47Xw+XPb23ddvw6U/fw2XfX9zumw/Wg7b
ij8I2ezrpUa9SnzQYlPLXXFXygoFb6olMN+175Z8J9u6HDK+TptCAfOey+1CbIT6G2Vq7F9rLJvx
n1H6z2e4AqD+s+mUGty4/Zt1H83YWg5ovP7zQ4/yP07Q5d9WDugM/cc8yv84QZd/WzmgM/j3EtL/
TtDl31YO6Az+/YjyP07Q5f/PPX/g1QXVwPj9P/KZR/u/Cwzzb8L4r9fdp+z/hf/v4zWh9d8FyP8n
/9/YvyUP+4z8bxSxgOzfBSj/S/lfY/+2YoCj438sCWKd/7W1IHVx4/Zv+MfJfV3xPzr/5QRd/rvh
9ktOiDP8v4QlxL8LHOX/Qi7geP/PDyn/6wbk/5H/Z8z9qvI/ZP9O0OX/qvI/5P87QZf/a8r/xB7l
f1ygy7+t49Zn+P9ee/6Hzn9bR5d/W7GA8f5fGOv1n/w/+xjg/6LbQLv+Hzn/eyD+j7e0/7sAxf8p
/m/s/2ri/34Y+EHv/O8lA1Jd3Lj9EwgEAoFAIBBuC78BaSEregBQAAA=""".replace(
    "\n", ""
)

TEST_RULE1 = b"""
rule MalwareDetectionClientRule
{
    strings:
        $text1 = "MalwareDetectionClient" fullword

    condition:
        $text1
}
"""

TEST_RULE2 = b"""
rule MiscellaneousStringsRule
// sent""
// ata_sff\\\\x00bioset\\\\x00bond0\\\\x00cifsd\\\\x00
{
    strings:
        $string1 = "sent\\"" fullword
        $string2 = "ata_sff\\\\x00bioset\\\\x00bond0\\\\x00cifsd\\\\x00"

    condition:
         any of them
}
"""

RULE_RULE_FILE_CONTENTS = r"""
rule Rule
/*
   Strings to trigger matches in the tests/matching_entity and tests/another\\ matching_entity files
   Output from this rule against those files should look like CONTRIVED_SCAN_OUTPUT in tests/test_parse_scan_output.py
   This file is also used in tests for testing rules files with spaces in them
*/
{
    meta:
        description = "Strings to trigger matches in the test/*matching_entity files"

    strings:
        $match0 = "string match in the file \\"matching_entity\\""
        $match1 = "another string match in matching_entity"
        $match2 = "string with different types of quotes 'here' and \\"here\\""
        $match3 = "string match containing error scanning but it's ok because its not in a rule line"

        $grep1 = "contains ="
        $grep2 = "contains .+"
        $grep3 = "contains \\""
        $grep4 = "contains '"
        $grep5 = "contains ()[]"
        $grep6 = "contains {"
        $grep7 = "contains ^$"

    condition:
        any of them
}
"""

RULE_METADATA_TEST_FILE_CONTENTS = r"""rule MetadataTestRule
/*
    // These rule strings will match the rule strings below unmodified ...
    Testing $s4 = "for ssh_creds in ${allThreads[@]}; do" ascii fullword
    Testing $s8 = "allThreads=($1)" ascii fullword
    Testing $s9 = "$(host): encrypt files. Done." ascii fullword

    // These rule strings with some modifications match the rule strings below ...
    Testing $s1 = "echo -e \"[-] Ping \\033[31m${host_name}\\033[0m bad" ascii fullword
    Testing $s2 = ""${user_name}"@"${host_name}" -p "${port}" ascii fullword
    Testing $s3 = "'$password' &" <<< GMANcode27'" ascii fullword
    Testing $s5 = ""text=$MSG" "$MSG_URL$id&"" ascii fullword
    Testing $s6 = "--exclude=\*.☢ -l" fullword
    Testing $s7 = "--include=\*.{txt,sh,exe}" ascii fullword
*/
{
    strings:
        $s1 = "echo -e \\"[-] Ping \\\\033[31m${host_name}\\\\033[0m bad\\"" ascii fullword
        $s2 = "\\"${user_name}\\"@\\"${host_name}\\" -p \\"${port}" ascii fullword
        $s3 = "'$password' &\\" <<< GMANcode27'" ascii fullword
        $s4 = "for ssh_creds in ${allThreads[@]}; do" ascii fullword
        $s5 = "\\"text=$MSG\\" \\"$MSG_URL$id&\\"" ascii fullword
        $s6 = "--exclude=\\\\*.☢ -l" fullword
        $s7 = "--include=\\\\*.{txt,sh,exe}" ascii fullword
        $s8 = "allThreads=($1)" ascii fullword
        $s9 = "$(host): encrypt files. Done." ascii fullword

    condition:
        any of them
}
"""

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

# -*- coding: UTF-8 -*-
import os
from mock.mock import patch

from insights.specs.datasources.malware_detection.scan_utils import (
    get_toplevel_dirs,
    get_parent_dirs,
    process_include_items,
    process_exclude_items,
    remove_child_items,
    remove_included_excluded_items,
    process_include_exclude_items,
    logger,
)

from insights.tests.datasources.malware_detection.conftest import (
    SCAN_UTILS_LOGGER_TARGET,
    TEMP_TEST_DIR,
)

# Some of the toplevel directories that will be included/excluded by default when listing root (/)
TLDS = [
    "/boot",
    "/dev",
    "/etc",
    "/home",
    "/opt",
    "/proc",
    "/root",
    "/sys",
    "/tmp",
    "/usr",
    "/var",
]

DEFAULT_SCAN_EXCLUDE = [
    "/cgroup",
    "/media",
    "/mnt",
    "/net",
    "/proc",
    "/selinux",
    "/sys",
]


class TestsMalwareDetectionScanUtils:
    def test_toplevel_dirs(self):
        tlds = get_toplevel_dirs()
        assert all([x in tlds for x in TLDS])
        assert any([x in tlds for x in DEFAULT_SCAN_EXCLUDE])

    def test_get_parent_dirs(self):
        parent_dir_list = []
        get_parent_dirs("/usr/lib/systemd/user/basic.target", parent_dir_list)
        assert sorted(parent_dir_list) == [
            "/usr",
            "/usr/lib",
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

        parent_dir_list = []
        get_parent_dirs(
            "/usr/lib/systemd/user/basic.target", parent_dir_list, "/usr/lib"
        )
        assert sorted(parent_dir_list) == [
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

        parent_dir_list = []
        get_parent_dirs("/usr/lib/systemd/user/basic.target", parent_dir_list, "/var")
        assert sorted(parent_dir_list) == [
            "/usr",
            "/usr/lib",
            "/usr/lib/systemd",
            "/usr/lib/systemd/user",
            "/usr/lib/systemd/user/basic.target",
        ]

    def test_remove_child_items(self):
        # Simple example from the function docstring
        items = [
            "/path/to/some/item/child",
            "/path/to/another/item",
            "/path/to/some/item",
        ]
        assert remove_child_items(items) == [
            "/path/to/another/item",
            "/path/to/some/item",
        ]

        # More complex test with duplicate items and items whose names start with another's name
        # (rather than start with the same path) and names with spaces in them
        items = [
            "/var/lib64",
            "/home/bob",
            "/var/lib/docker",
            "/home/bob",
            "/var/lib",
            "/home/bobby-droptables",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib63/im ok",
            "/var/lib64/im not",
        ]
        assert remove_child_items(items) == [
            "/home/bob",
            "/home/bobby-droptables",
            "/var/lib",
            "/var/lib63/im ok",
            "/var/lib64",
        ]

        # /path is common to both so that will be all that is returned
        items = ["/path/to/another/item", "/path/to/some/item", "/path"]
        assert remove_child_items(items) == ["/path"]

        # The root directory will always win
        items = ["/path/to/another/item", "/path/to/some/item", "/"]
        assert remove_child_items(items) == ["/"]

        # Any non-full path items (doesn't start with /) are removed from the list
        items = ["/path/to/another/item", "", "/path/to/some/item"]
        assert remove_child_items(items) == [
            "/path/to/another/item",
            "/path/to/some/item",
        ]

    def test_remove_included_excluded_items(self):
        include_items = ["/home/bob", "/tmp", "/var/www/html"]
        exclude_items = [
            "/home/bo",
            "/home/bob/exclude",
            "/home/bobby",
            "/temp",
            "/var/www",
        ]
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ["/home/bob", "/tmp"]

        # Some fairly random lists similar to before
        include_items = [
            "/var/lib64/docker",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib/docker",
            "/home/bob",
            "/var/lib",
            "/usr",
        ]
        exclude_items = [
            "/var/lib/docker2",
            "/home/bob",
            "/home/bobby-droptables",
            r"/home/bob/this\ is\ bobs/child",
            "/var/lib63/im ok",
            "/var/lib64/im not",
            "/boot",
        ]
        include_items = remove_included_excluded_items(include_items, exclude_items)
        assert include_items == ["/usr", "/var/lib", "/var/lib64/docker"]

    def test_default_include_items(self):
        # Call process_include_items with an empty list.
        # If nothing is passed to the function, the a list of the top level directories is produced
        default_list = process_include_items()
        assert default_list == get_toplevel_dirs()

    def test_default_exclude_items(self):
        # Call process_exclude_items with an empty list.
        # If nothing is passed to the function, then nothing to exclude
        default_list = process_exclude_items()
        assert default_list == []

    @patch(SCAN_UTILS_LOGGER_TARGET)
    def test_process_include_items(self, scan_utils_log_mock):
        # Add some valid entries to include_items list, esp subdirectories
        include_items = ["/etc/pam.d", "/tmp", "/var/log/", "#test"]
        processed_items = process_include_items(include_items)
        assert processed_items == ["/etc/pam.d", "/tmp", "/var/log"]

        # Add some more subdirectories
        include_items.extend(["/etc/alternatives", "/tmp", "/var/lib/"])
        processed_items = process_include_items(include_items)
        assert processed_items == [
            "/etc/alternatives",
            "/etc/pam.d",
            "/tmp",
            "/var/lib",
            "/var/log",
        ]

        # Add some top level directories to override the subdirectories
        include_items.extend(["/etc", "/var"])
        processed_items = process_include_items(include_items)
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add some invalid entries that will get ignored
        include_items.extend(["..", "/var/run", "/missing"])
        processed_items = process_include_items(include_items)
        scan_utils_log_mock.debug.assert_any_call(
            "Include items: %s", ["/etc", "/tmp", "/var"]
        )
        scan_utils_log_mock.debug.assert_any_call(
            "Skipping missing item '%s' ...", "/missing"
        )
        scan_utils_log_mock.debug.assert_any_call("Skipping link '%s' ...", "/var/run")
        scan_utils_log_mock.debug.assert_any_call(
            "Skipping partial directory path '%s' ...", ".."
        )
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add the root directory (/) which will override all the other entries
        scan_utils_log_mock.clear()
        include_items.append("/")
        processed_items = process_include_items(include_items)
        scan_utils_log_mock.debug.assert_any_call(
            "Found root directory in list of items to scan. Ignoring the other items ..."
        )
        assert all([x in processed_items for x in TLDS])
        assert any([x in processed_items for x in DEFAULT_SCAN_EXCLUDE])

    @patch(SCAN_UTILS_LOGGER_TARGET)
    def test_process_exclude_items(self, scan_utils_log_mock):
        # Call process_exclude_items with variously populated lists
        logger.setLevel("DEBUG")

        # Remove the default entries from the exclude file
        processed_items = process_exclude_items()
        scan_utils_log_mock.debug.assert_any_call("No items specified to be excluded")
        assert processed_items == []

        # Add some valid entries to exclude items (links are ok in the exclude list ... why?)
        exclude_items = ["/etc/ssh", "/tmp", "/var/run/", "#test"]
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ["/etc/ssh", "/tmp", "/var/run"]

        # Add some more subdirectories
        exclude_items.extend(["/etc/alternatives", "/tmp", "/var/lock/"])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == [
            "/etc/alternatives",
            "/etc/ssh",
            "/tmp",
            "/var/lock",
            "/var/run",
        ]

        # Add some top level directories to override the subdirectories
        exclude_items.extend(["/etc", "/var"])
        processed_items = process_exclude_items(exclude_items)
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add some invalid entries to exclude items
        exclude_items.extend(["..", "/missing"])
        processed_items = process_exclude_items(exclude_items)
        scan_utils_log_mock.debug.assert_any_call(
            "Skipping partial directory path '%s' ...", ".."
        )
        scan_utils_log_mock.debug.assert_any_call(
            "Skipping missing item '%s' ...", "/missing"
        )
        assert processed_items == ["/etc", "/tmp", "/var"]

        # Add the root directory
        exclude_items.append("/")
        processed_items = process_exclude_items(exclude_items)
        scan_utils_log_mock.debug.assert_any_call(
            "Found root directory in the exclude list. Expanding it to all toplevel directories ..."
        )
        assert processed_items == get_toplevel_dirs()

    @patch(
        "insights.specs.datasources.malware_detection.scan_utils.get_toplevel_dirs",
        return_value=[],
    )
    @patch(SCAN_UTILS_LOGGER_TARGET)
    def test_empty_process_include_exclude_items(
        self, scan_utils_log_mock, get_top_dirs
    ):
        # test empty dir so that process_include_exclude has no items
        scan_dict = process_include_exclude_items(include_items=[], exclude_items=[])
        assert scan_dict == {}
        scan_utils_log_mock.error.assert_any_call(
            "No filesystem items to scan because the include items doesn't contain any valid items"
        )

    def test_process_include_exclude_tmp_files(self, extract_tmp_files):
        # Test the including/excluding some of the files in the tmp archive
        # Specifically tests excluding link files (good or broken) and pipe files (as well as explicit exclude items)

        include_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me", "scan_me_too"])
        )
        exclude_items = list(
            map(
                lambda x: os.path.join(TEMP_TEST_DIR, x),
                ["scan_me_not", "scan_me/dont_scan_me", "scan_me_too/dont_scan_me_too"],
            )
        )
        scan_dict = process_include_exclude_items(
            include_items=include_items, exclude_items=exclude_items
        )
        assert list(scan_dict.keys()) == ["/tmp"]
        assert sorted(list(scan_dict["/tmp"]["exclude"]["items"])) == sorted(
            exclude_items
        )

        include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/new_file",
                        "scan_me/old_file",
                        "scan_me/scan_me",
                        "scan_me/scan_me_file",
                        "scan_me_too/new_file",
                        "scan_me_too/old_file",
                        "scan_me_too/scan_me_too",
                        "scan_me_too/scan_me_too_file",
                    ],
                )
            )
        )
        dont_include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/link_file",
                        "scan_me/pipe_file",
                        "scan_me/broken_link",
                        "scan_me/dont_scan_me",
                        "scan_me_too/link_file",
                        "scan_me_too/pipe_file",
                        "scan_me_too/broken_link",
                        "scan_me_too/dont_scan_me_too",
                    ],
                )
            )
        )
        assert sorted(scan_dict["/tmp"]["include"]) == include_files
        assert all([x not in scan_dict["/tmp"]["include"] for x in dont_include_files])

        # Another test to assert a bug I found is fixed ... due to only having scan_items = set([])
        # Basically include_files should = ['scan_me/scan_me'] but the bug made include_files = []
        include_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me/scan_me"])
        )
        exclude_items = list(
            map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me_not"])
        )
        scan_dict = process_include_exclude_items(
            include_items=include_items, exclude_items=exclude_items
        )

        include_files = sorted(
            list(map(lambda x: os.path.join(TEMP_TEST_DIR, x), ["scan_me/scan_me"]))
        )
        assert sorted(scan_dict["/tmp"]["include"]) == include_files
        dont_include_files = sorted(
            list(
                map(
                    lambda x: os.path.join(TEMP_TEST_DIR, x),
                    [
                        "scan_me/scan_me_file",
                        "scan_me/dont_scan_me",
                        "scan_me/scan_me/here_i_am",
                    ],
                )
            )
        )
        assert all([x not in scan_dict["/tmp"]["include"] for x in dont_include_files])

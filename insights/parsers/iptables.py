"""
iptables-save and ip6tables-save - Command
==========================================

Module for processing output of the ``iptables-save`` and ``ip6tables-save``
commands.

Sample input data looks like::

    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *filter
    :INPUT ACCEPT [0:0]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [769:196899]
    :REJECT-LOG - [0:0]
    -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
    -A INPUT -s 192.168.0.0/24 -j ACCEPT
    -A INPUT -p icmp -j ACCEPT
    -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
    -A INPUT -j REJECT --reject-with icmp-host-prohibited
    -A REJECT-LOG -p tcp -j REJECT --reject-with tcp-reset
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016
    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *mangle
    :PREROUTING ACCEPT [451:22060]
    :INPUT ACCEPT [451:22060]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [594:47151]
    :POSTROUTING ACCEPT [594:47151]
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016
    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *nat
    :PREROUTING ACCEPT [0:0]
    :POSTROUTING ACCEPT [3:450]
    :OUTPUT ACCEPT [3:450]
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016

Each table of iptables starting with a ``# Generated by ...``.
Each table is marked like ``*<table-name>``, for example ``*filter``.
Each chain specifications starting with a ``:`` sign.
A chain specification looks like ``:<chain-name> <chain-policy> [<packet-counter>:<byte-counter>]``
The chain-name may be for example ``INPUT``. Each ``iptables`` rule starts with a `-` sign.

Examples:

    >>> ipt = shared[IPTables]
    >>> ipt6 = shared[IP6Tables]
    >>> ipt.rules[0]
    {'chain': 'INPUT',
     'constraints': '',
     'rule': '-j INPUT_direct',
     'table': 'security',
     'target': 'INPUT_direct',
     'target_action': 'jump',
     'target_options': None}
    >>> ipt.get_chain('INPUT')
    [{'chain': 'INPUT',
      'constraints': '-m state --state RELATED,ESTABLISHED',
      'rule': '-m state --state RELATED,ESTABLISHED -j ACCEPT',
      'table': 'filter',
      'target': 'ACCEPT',
      'target_action': 'jump',
      'target_options': None},
     {'chain': 'INPUT',
      'constraints': '-s fe80::/64',
      'rule': '-s fe80::/64 -j ACCEPT',
      'table': 'filter',
      'target': 'ACCEPT',
      'target_action': 'jump',
      'target_options': None},
     {'chain': 'INPUT', 'rule': '-s fe80::/64', 'table': 'filter'}]
    >>> ipt.table_chains('mangle')
    {'FORWARD': [], 'INPUT': [], 'POSTROUTING': [], 'PREROUTING': [], 'OUTPUT': []}
    >>> ipt.get_table('nat'))
    [{'byte_counter': 0,
      'name': 'PREROUTING',
      'packet_counter': 0,
      'policy': 'ACCEPT',
      'table': 'nat'},
     {'byte_counter': 0,
      'name': 'INPUT',
      'packet_counter': 0,
      'policy': 'ACCEPT',
      'table': 'nat'},
     {'byte_counter': 0,
      'name': 'OUTPUT',
      'packet_counter': 0,
      'policy': 'ACCEPT',
      'table': 'nat'},
     {'byte_counter': 0,
      'name': 'POSTROUTING',
      'packet_counter': 0,
      'policy': 'ACCEPT',
      'table': 'nat'}]
"""

from .. import Parser, parser, get_active_lines


class IPTablesConfiguration(Parser):
    """A general class for parsing iptables configuration in the ``iptables-save``-like format."""
    def parse_content(self, content):
        self.chains = []
        self.rules = []
        current_table = None
        for line in get_active_lines(content):
            if line.startswith("*"):
                current_table = line[1:].strip()
            elif line.startswith(":"):
                name, policy, counter = line[1:].split()
                packet_counter, byte_counter = counter.strip("[]").split(":")
                self.chains.append({
                    "policy": policy if policy != "-" else None,
                    "table": current_table,
                    "name": name,
                    "packet_counter": int(packet_counter),
                    "byte_counter": int(byte_counter),
                })
            elif line.startswith("-"):
                chain_name, rule = line[3:].split(None, 1)
                target_option = [i for i in ('-j', '-g') if i in rule]
                if target_option:
                    constraints, target = [i.strip() for i in rule.split(target_option[-1])]
                    if " " in target:
                        target, target_options = target.split(None, 1)
                    else:
                        target_options = None
                    self.rules.append({
                        "table": current_table,
                        "chain": chain_name,
                        "rule": rule,
                        "target_action": "jump" if target_option[-1] == "-j" else "goto",
                        "constraints": constraints,
                        "target": target,
                        "target_options": target_options
                    })
                else:
                    self.rules.append({
                        "table": current_table,
                        "chain": chain_name,
                        "rule": rule
                    })

    def get_chain(self, name, table="filter"):
        """
        Get the list of rules for a particular chain. Chain order is kept intact.

        Args:
            name (str): chain name, e.g. ``
            table (str): table name, defaults to ``filter``

        Returns:
            list: rules
        """
        return [r for r in self.rules if r["table"] == table and r["chain"] == name]

    def get_table(self, name="filter"):
        """
        Get the list of chains for a particular table.

        Args:
            name (str): table name, defaults to ``filter``

        Returns:
            list: chains
        """
        return [c for c in self.chains if c["table"] == name]

    def table_chains(self, table="filter"):
        """
        Get a dict where the keys are all the chains for the given table
        and each value is the set of rules defined for the given chain.

        Args:
            table (str): table name, defaults to ``filter``

        Returns:
            dict: chains with set of defined rules
        """
        return {c["name"]: self.get_chain(c["name"], table) for c in self.get_table(table)}

    def get_rule(self, s):
        """
        Get the list of rules that contain the given string.

        Args:
            s (str): string to look for in iptables rules

        Returns:
            list: rules containing given string
        """
        return [r for r in self.rules if s in r["rule"]]

    def __contains__(self, s):
        return any(s in r["rule"] for r in self.rules)


@parser("iptables")
class IPTables(IPTablesConfiguration):
    """
    Process output of the ``iptables-save`` command.

    See ``IPTablesConfiguration`` class for additional information.
    """
    pass


@parser("ip6tables")
class IP6Tables(IPTablesConfiguration):
    """
    Process output of the ``ip6tables-save`` command.

    See ``IPTablesConfiguration`` class for additional information.
    """
    pass


@parser("iptables_permanent")
class IPTabPermanent(IPTablesConfiguration):
    """
    Process ``iptables`` configuration saved in file ``/etc/sysconfig/iptables``.

    The configuration in this file is loaded by the ``iptables`` service when the system boots.
    New configuration is saved by using the ``service iptables save`` command. This configuration
    file is not available on a system with ``firewalld`` service.

    See ``IPTablesConfiguration`` class for additional information.
    """
    pass


@parser("ip6tables_permanent")
class IP6TabPermanent(IPTablesConfiguration):
    """
    Process ``ip6tables`` configuration saved in file ``/etc/sysconfig/ip6tables``.

    The configuration in this file is loaded by the ``ip6tables`` service when the system boots.
    New configuration is saved by using the ``service ip6tables save`` command. This configuration
    file is not available on a system with ``firewalld`` service.

    See ``IPTablesConfiguration`` class for additional information.
    """
    pass
